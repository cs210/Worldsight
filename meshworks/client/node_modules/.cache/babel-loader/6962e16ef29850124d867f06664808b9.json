{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c;\n\nimport { AnimationMixer, Box3, Object3D, Vector3 } from 'three';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport { Hotspot } from './Hotspot.js';\nimport { moveChildren, reduceVertices } from './ModelUtils.js';\nimport { Shadow } from './Shadow.js';\nexport var DEFAULT_FOV_DEG = 45;\nvar DEFAULT_HALF_FOV = DEFAULT_FOV_DEG / 2 * Math.PI / 180;\nexport var SAFE_RADIUS_RATIO = Math.sin(DEFAULT_HALF_FOV);\nexport var DEFAULT_TAN_FOV = Math.tan(DEFAULT_HALF_FOV);\nexport var $shadow = Symbol('shadow');\nvar $cancelPendingSourceChange = Symbol('cancelPendingSourceChange');\nvar $currentGLTF = Symbol('currentGLTF');\nvar $loader = Symbol('loader');\nvar view = new Vector3();\nvar target = new Vector3();\nvar normalWorld = new Vector3();\n/**\n * An Object3D that can swap out its underlying model.\n */\n\nvar Model = /*#__PURE__*/function (_Object3D) {\n  _inherits(Model, _Object3D);\n\n  var _super = _createSuper(Model);\n\n  /**\n   * Creates a model.\n   */\n  function Model() {\n    var _this;\n\n    _classCallCheck(this, Model);\n\n    _this = _super.call(this);\n    _this[_a] = null;\n    _this[_b] = null;\n    _this[_c] = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    _this.animations = [];\n    _this.animationsByName = new Map();\n    _this.currentAnimationAction = null;\n    _this.modelContainer = new Object3D();\n    _this.animationNames = [];\n    _this.boundingBox = new Box3();\n    _this.size = new Vector3();\n    _this.idealCameraDistance = 0;\n    _this.fieldOfViewAspect = 0;\n    _this.userData = {\n      url: null\n    };\n    _this.url = null;\n    _this.name = 'Model';\n    _this.modelContainer.name = 'ModelContainer';\n\n    _this.add(_this.modelContainer);\n\n    _this.mixer = new AnimationMixer(_this.modelContainer);\n    return _this;\n  }\n\n  _createClass(Model, [{\n    key: \"hasModel\",\n\n    /**\n     * Returns a boolean indicating whether or not there is a\n     * loaded model attached.\n     */\n    value: function hasModel() {\n      return !!this.modelContainer.children.length;\n    }\n    /**\n     * Pass in a THREE.Object3D to be controlled\n     * by this model.\n     */\n\n  }, {\n    key: \"setObject\",\n    value: function setObject(model) {\n      this.clear();\n      this.modelContainer.add(model);\n      this.updateFraming();\n      this.dispatchEvent({\n        type: 'model-load'\n      });\n    }\n  }, {\n    key: \"setSource\",\n    value: function () {\n      var _setSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url, progressCallback) {\n        var _this2 = this;\n\n        var gltf, _gltf, animations, animationsByName, animationNames, _iterator, _step, animation;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(!url || url === this.url)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                if (progressCallback) {\n                  progressCallback(1);\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                // If we have pending work due to a previous source change in progress,\n                // cancel it so that we do not incur a race condition:\n                if (this[$cancelPendingSourceChange] != null) {\n                  this[$cancelPendingSourceChange]();\n                  this[$cancelPendingSourceChange] = null;\n                }\n\n                this.url = url;\n                _context2.prev = 5;\n                _context2.next = 8;\n                return new Promise( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n                    var result;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _this2[$cancelPendingSourceChange] = function () {\n                              return reject();\n                            };\n\n                            _context.prev = 1;\n                            _context.next = 4;\n                            return _this2.loader.load(url, progressCallback);\n\n                          case 4:\n                            result = _context.sent;\n                            resolve(result);\n                            _context.next = 11;\n                            break;\n\n                          case 8:\n                            _context.prev = 8;\n                            _context.t0 = _context[\"catch\"](1);\n                            reject(_context.t0);\n\n                          case 11:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[1, 8]]);\n                  }));\n\n                  return function (_x3, _x4) {\n                    return _ref.apply(this, arguments);\n                  };\n                }());\n\n              case 8:\n                gltf = _context2.sent;\n                _context2.next = 16;\n                break;\n\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](5);\n\n                if (!(_context2.t0 == null)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 15:\n                throw _context2.t0;\n\n              case 16:\n                this.clear();\n                this[$currentGLTF] = gltf;\n\n                if (gltf != null) {\n                  moveChildren(gltf.scene, this.modelContainer);\n                }\n\n                _gltf = gltf, animations = _gltf.animations;\n                animationsByName = new Map();\n                animationNames = [];\n                _iterator = _createForOfIteratorHelper(animations);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    animation = _step.value;\n                    animationsByName.set(animation.name, animation);\n                    animationNames.push(animation.name);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                this.animations = animations;\n                this.animationsByName = animationsByName;\n                this.animationNames = animationNames;\n                this.userData.url = url;\n                this.updateFraming();\n                this.dispatchEvent({\n                  type: 'model-load',\n                  url: url\n                });\n\n              case 30:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[5, 11]]);\n      }));\n\n      function setSource(_x, _x2) {\n        return _setSource.apply(this, arguments);\n      }\n\n      return setSource;\n    }()\n  }, {\n    key: \"playAnimation\",\n\n    /**\n     * Plays an animation if there are any associated with the current model.\n     * Accepts an optional string name of an animation to play. If no name is\n     * provided, or if no animation is found by the given name, always falls back\n     * to playing the first animation.\n     */\n    value: function playAnimation() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var crossfadeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var animations = this.animations;\n\n      if (animations == null || animations.length === 0) {\n        console.warn(\"Cannot play animation (model does not have any animations)\");\n        return;\n      }\n\n      var animationClip = null;\n\n      if (name != null) {\n        animationClip = this.animationsByName.get(name);\n      }\n\n      if (animationClip == null) {\n        animationClip = animations[0];\n      }\n\n      try {\n        var lastAnimationAction = this.currentAnimationAction;\n        this.currentAnimationAction = this.mixer.clipAction(animationClip, this).play();\n        this.currentAnimationAction.enabled = true;\n\n        if (lastAnimationAction != null && this.currentAnimationAction !== lastAnimationAction) {\n          this.currentAnimationAction.crossFadeFrom(lastAnimationAction, crossfadeTime, false);\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation() {\n      if (this.currentAnimationAction != null) {\n        this.currentAnimationAction.stop();\n        this.currentAnimationAction.reset();\n        this.currentAnimationAction = null;\n      }\n\n      this.mixer.stopAllAction();\n    }\n  }, {\n    key: \"updateAnimation\",\n    value: function updateAnimation(step) {\n      this.mixer.update(step);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.url = null;\n      this.userData = {\n        url: null\n      };\n      var gltf = this[$currentGLTF]; // Remove all current children\n\n      if (gltf != null) {\n        moveChildren(this.modelContainer, gltf.scene);\n        gltf.dispose();\n        this[$currentGLTF] = null;\n      }\n\n      if (this.currentAnimationAction != null) {\n        this.currentAnimationAction.stop();\n        this.currentAnimationAction = null;\n      }\n\n      this.mixer.stopAllAction();\n      this.mixer.uncacheRoot(this);\n    }\n    /**\n     * Calculates the idealCameraDistance and fieldOfViewAspect that allows the 3D\n     * object to be framed tightly in a 2D window of any aspect ratio without\n     * clipping at any camera orbit. The camera's center target point can be\n     * optionally specified. If no center is specified, it defaults to the center\n     * of the bounding box, which means asymmetric models will tend to be tight on\n     * one side instead of both. Proper choice of center can correct this.\n     */\n\n  }, {\n    key: \"updateFraming\",\n    value: function updateFraming() {\n      var _this3 = this;\n\n      var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this.remove(this.modelContainer);\n\n      if (center == null) {\n        this.boundingBox.setFromObject(this.modelContainer);\n        this.boundingBox.getSize(this.size);\n        center = this.boundingBox.getCenter(new Vector3());\n      }\n\n      var radiusSquared = function radiusSquared(value, vertex) {\n        return Math.max(value, center.distanceToSquared(vertex));\n      };\n\n      var framedRadius = Math.sqrt(reduceVertices(this.modelContainer, radiusSquared));\n      this.idealCameraDistance = framedRadius / SAFE_RADIUS_RATIO;\n\n      var horizontalFov = function horizontalFov(value, vertex) {\n        vertex.sub(center);\n        var radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);\n        return Math.max(value, radiusXZ / (_this3.idealCameraDistance - Math.abs(vertex.y)));\n      };\n\n      this.fieldOfViewAspect = reduceVertices(this.modelContainer, horizontalFov) / DEFAULT_TAN_FOV;\n      this.add(this.modelContainer);\n    }\n    /**\n     * Sets the shadow's intensity, lazily creating the shadow as necessary.\n     */\n\n  }, {\n    key: \"setShadowIntensity\",\n    value: function setShadowIntensity(shadowIntensity, shadowSoftness) {\n      var shadow = this[$shadow];\n\n      if (shadow != null) {\n        shadow.setIntensity(shadowIntensity);\n        shadow.setModel(this, shadowSoftness);\n      } else if (shadowIntensity > 0) {\n        shadow = new Shadow(this, shadowSoftness);\n        shadow.setIntensity(shadowIntensity);\n        this[$shadow] = shadow;\n      }\n    }\n    /**\n     * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n     * shadow's resolution. This involves reallocation, so it should not be\n     * changed frequently. Softer shadows are cheaper to render.\n     */\n\n  }, {\n    key: \"setShadowSoftness\",\n    value: function setShadowSoftness(softness) {\n      var shadow = this[$shadow];\n\n      if (shadow != null) {\n        shadow.setSoftness(softness);\n      }\n    }\n    /**\n     * The shadow must be rotated manually to match any global rotation applied to\n     * this model. The input is the global orientation about the Y axis.\n     */\n\n  }, {\n    key: \"setShadowRotation\",\n    value: function setShadowRotation(radiansY) {\n      var shadow = this[$shadow];\n\n      if (shadow != null) {\n        shadow.setRotation(radiansY);\n      }\n    }\n    /**\n     * Call when updating the shadow; returns true if an update is needed and\n     * resets the state.\n     */\n\n  }, {\n    key: \"updateShadow\",\n    value: function updateShadow() {\n      var shadow = this[$shadow];\n\n      if (shadow == null) {\n        return false;\n      } else {\n        var needsUpdate = shadow.needsUpdate;\n        shadow.needsUpdate = false;\n        return needsUpdate;\n      }\n    }\n    /**\n     * Shift the floor vertically from the bottom of the model's bounding box by\n     * offset (should generally be negative).\n     */\n\n  }, {\n    key: \"setShadowScaleAndOffset\",\n    value: function setShadowScaleAndOffset(scale, offset) {\n      var shadow = this[$shadow];\n\n      if (shadow != null) {\n        shadow.setScaleAndOffset(scale, offset);\n      }\n    }\n    /**\n     * The following methods are for operating on the set of Hotspot objects\n     * attached to the scene. These come from DOM elements, provided to slots by\n     * the Annotation Mixin.\n     */\n\n  }, {\n    key: \"addHotspot\",\n    value: function addHotspot(hotspot) {\n      this.add(hotspot);\n    }\n  }, {\n    key: \"removeHotspot\",\n    value: function removeHotspot(hotspot) {\n      this.remove(hotspot);\n    }\n    /**\n     * Helper method to apply a function to all hotspots.\n     */\n\n  }, {\n    key: \"forHotspots\",\n    value: function forHotspots(func) {\n      var children = this.children;\n\n      for (var i = 0, l = children.length; i < l; i++) {\n        var hotspot = children[i];\n\n        if (hotspot instanceof Hotspot) {\n          func(hotspot);\n        }\n      }\n    }\n    /**\n     * Update the CSS visibility of the hotspots based on whether their normals\n     * point toward the camera.\n     */\n\n  }, {\n    key: \"updateHotspots\",\n    value: function updateHotspots(viewerPosition) {\n      var _this4 = this;\n\n      this.forHotspots(function (hotspot) {\n        view.copy(viewerPosition);\n        target.setFromMatrixPosition(hotspot.matrixWorld);\n        view.sub(target);\n        normalWorld.copy(hotspot.normal).transformDirection(_this4.matrixWorld);\n\n        if (view.dot(normalWorld) < 0) {\n          hotspot.hide();\n        } else {\n          hotspot.show();\n        }\n      });\n    }\n    /**\n     * Rotate all hotspots to an absolute orientation given by the input number of\n     * radians. Zero returns them to upright.\n     */\n\n  }, {\n    key: \"orientHotspots\",\n    value: function orientHotspots(radians) {\n      this.forHotspots(function (hotspot) {\n        hotspot.orient(radians);\n      });\n    }\n    /**\n     * Set the rendering visibility of all hotspots. This is used to hide them\n     * during transitions and such.\n     */\n\n  }, {\n    key: \"setHotspotsVisibility\",\n    value: function setHotspotsVisibility(visible) {\n      this.forHotspots(function (hotspot) {\n        hotspot.visible = visible;\n      });\n    }\n  }, {\n    key: \"loader\",\n    get: function get() {\n      return this[$loader];\n    }\n  }, {\n    key: \"animationTime\",\n    set: function set(value) {\n      this.mixer.setTime(value);\n    },\n    get: function get() {\n      if (this.currentAnimationAction != null) {\n        return this.currentAnimationAction.time;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"hasActiveAnimation\",\n    get: function get() {\n      return this.currentAnimationAction != null;\n    }\n  }]);\n\n  return Model;\n}(Object3D);\n\nexport { Model as default };\n_a = $shadow, _b = $currentGLTF, _c = $loader;","map":{"version":3,"sources":["../../src/three-components/Model.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {AnimationAction, AnimationClip, AnimationMixer, Box3, Object3D, Vector3} from 'three';\n\nimport {CachingGLTFLoader} from './CachingGLTFLoader.js';\nimport {ModelViewerGLTFInstance} from './gltf-instance/ModelViewerGLTFInstance.js';\nimport {Hotspot} from './Hotspot.js';\nimport {moveChildren, reduceVertices} from './ModelUtils.js';\nimport {Shadow} from './Shadow.js';\n\nexport const DEFAULT_FOV_DEG = 45;\nconst DEFAULT_HALF_FOV = (DEFAULT_FOV_DEG / 2) * Math.PI / 180;\nexport const SAFE_RADIUS_RATIO = Math.sin(DEFAULT_HALF_FOV);\nexport const DEFAULT_TAN_FOV = Math.tan(DEFAULT_HALF_FOV);\n\nexport const $shadow = Symbol('shadow');\nconst $cancelPendingSourceChange = Symbol('cancelPendingSourceChange');\nconst $currentGLTF = Symbol('currentGLTF');\nconst $loader = Symbol('loader');\n\nconst view = new Vector3();\nconst target = new Vector3();\nconst normalWorld = new Vector3();\n\n/**\n * An Object3D that can swap out its underlying model.\n */\nexport default class Model extends Object3D {\n  protected[$shadow]: Shadow|null = null;\n\n  private[$currentGLTF]: ModelViewerGLTFInstance|null = null;\n  private[$loader] = new CachingGLTFLoader(ModelViewerGLTFInstance);\n  private mixer: AnimationMixer;\n  private[$cancelPendingSourceChange]: (() => void)|null;\n  private animations: Array<AnimationClip> = [];\n  private animationsByName: Map<string, AnimationClip> = new Map();\n  private currentAnimationAction: AnimationAction|null = null;\n\n  public modelContainer = new Object3D();\n  public animationNames: Array<string> = [];\n  public boundingBox = new Box3();\n  public size = new Vector3();\n  public idealCameraDistance = 0;\n  public fieldOfViewAspect = 0;\n  public userData: {url: string|null} = {url: null};\n  public url: string|null = null;\n\n  get loader() {\n    return this[$loader];\n  }\n\n  /**\n   * Creates a model.\n   */\n  constructor() {\n    super();\n\n    this.name = 'Model';\n    this.modelContainer.name = 'ModelContainer';\n\n    this.add(this.modelContainer);\n    this.mixer = new AnimationMixer(this.modelContainer);\n  }\n\n  /**\n   * Returns a boolean indicating whether or not there is a\n   * loaded model attached.\n   */\n  hasModel(): boolean {\n    return !!this.modelContainer.children.length;\n  }\n\n  /**\n   * Pass in a THREE.Object3D to be controlled\n   * by this model.\n   */\n  setObject(model: Object3D) {\n    this.clear();\n    this.modelContainer.add(model);\n    this.updateFraming();\n    this.dispatchEvent({type: 'model-load'});\n  }\n\n  async setSource(\n      url: string|null, progressCallback?: (progress: number) => void) {\n    if (!url || url === this.url) {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n      return;\n    }\n\n    // If we have pending work due to a previous source change in progress,\n    // cancel it so that we do not incur a race condition:\n    if (this[$cancelPendingSourceChange] != null) {\n      this[$cancelPendingSourceChange]!();\n      this[$cancelPendingSourceChange] = null;\n    }\n\n    this.url = url;\n\n    let gltf: ModelViewerGLTFInstance;\n\n    try {\n      gltf = await new Promise<ModelViewerGLTFInstance>(\n          async (resolve, reject) => {\n            this[$cancelPendingSourceChange] = () => reject();\n            try {\n              const result = await this.loader.load(url, progressCallback);\n              resolve(result);\n            } catch (error) {\n              reject(error);\n            }\n          });\n    } catch (error) {\n      if (error == null) {\n        // Loading was cancelled, so silently return\n        return;\n      }\n\n      throw error;\n    }\n\n    this.clear();\n    this[$currentGLTF] = gltf;\n\n    if (gltf != null) {\n      moveChildren(gltf.scene, this.modelContainer);\n    }\n\n    const {animations} = gltf!;\n    const animationsByName = new Map();\n    const animationNames = [];\n\n    for (const animation of animations) {\n      animationsByName.set(animation.name, animation);\n      animationNames.push(animation.name);\n    }\n\n    this.animations = animations;\n    this.animationsByName = animationsByName;\n    this.animationNames = animationNames;\n\n    this.userData.url = url;\n\n    this.updateFraming();\n\n    this.dispatchEvent({type: 'model-load', url});\n  }\n\n  set animationTime(value: number) {\n    this.mixer.setTime(value);\n  }\n\n  get animationTime(): number {\n    if (this.currentAnimationAction != null) {\n      return this.currentAnimationAction.time;\n    }\n\n    return 0;\n  }\n\n  get hasActiveAnimation(): boolean {\n    return this.currentAnimationAction != null;\n  }\n\n  /**\n   * Plays an animation if there are any associated with the current model.\n   * Accepts an optional string name of an animation to play. If no name is\n   * provided, or if no animation is found by the given name, always falls back\n   * to playing the first animation.\n   */\n  playAnimation(name: string|null = null, crossfadeTime: number = 0) {\n    const {animations} = this;\n    if (animations == null || animations.length === 0) {\n      console.warn(\n          `Cannot play animation (model does not have any animations)`);\n      return;\n    }\n\n    let animationClip = null;\n\n    if (name != null) {\n      animationClip = this.animationsByName.get(name);\n    }\n\n    if (animationClip == null) {\n      animationClip = animations[0];\n    }\n\n    try {\n      const {currentAnimationAction: lastAnimationAction} = this;\n\n      this.currentAnimationAction =\n          this.mixer.clipAction(animationClip, this).play();\n      this.currentAnimationAction.enabled = true;\n\n      if (lastAnimationAction != null &&\n          this.currentAnimationAction !== lastAnimationAction) {\n        this.currentAnimationAction.crossFadeFrom(\n            lastAnimationAction, crossfadeTime, false);\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  stopAnimation() {\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction.reset();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n  }\n\n  updateAnimation(step: number) {\n    this.mixer.update(step);\n  }\n\n  clear() {\n    this.url = null;\n    this.userData = {url: null};\n    const gltf = this[$currentGLTF];\n    // Remove all current children\n    if (gltf != null) {\n      moveChildren(this.modelContainer, gltf.scene);\n      gltf.dispose();\n      this[$currentGLTF] = null;\n    }\n\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n    this.mixer.uncacheRoot(this);\n  }\n\n  /**\n   * Calculates the idealCameraDistance and fieldOfViewAspect that allows the 3D\n   * object to be framed tightly in a 2D window of any aspect ratio without\n   * clipping at any camera orbit. The camera's center target point can be\n   * optionally specified. If no center is specified, it defaults to the center\n   * of the bounding box, which means asymmetric models will tend to be tight on\n   * one side instead of both. Proper choice of center can correct this.\n   */\n  updateFraming(center: Vector3|null = null) {\n    this.remove(this.modelContainer);\n\n    if (center == null) {\n      this.boundingBox.setFromObject(this.modelContainer);\n      this.boundingBox.getSize(this.size);\n      center = this.boundingBox.getCenter(new Vector3);\n    }\n\n    const radiusSquared = (value: number, vertex: Vector3): number => {\n      return Math.max(value, center!.distanceToSquared(vertex));\n    };\n    const framedRadius =\n        Math.sqrt(reduceVertices(this.modelContainer, radiusSquared));\n\n    this.idealCameraDistance = framedRadius / SAFE_RADIUS_RATIO;\n\n    const horizontalFov = (value: number, vertex: Vector3): number => {\n      vertex.sub(center!);\n      const radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);\n      return Math.max(\n          value, radiusXZ / (this.idealCameraDistance - Math.abs(vertex.y)));\n    };\n    this.fieldOfViewAspect =\n        reduceVertices(this.modelContainer, horizontalFov) / DEFAULT_TAN_FOV;\n\n    this.add(this.modelContainer);\n  }\n\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n  setShadowIntensity(shadowIntensity: number, shadowSoftness: number) {\n    let shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setIntensity(shadowIntensity);\n      shadow.setModel(this, shadowSoftness);\n    } else if (shadowIntensity > 0) {\n      shadow = new Shadow(this, shadowSoftness);\n      shadow.setIntensity(shadowIntensity);\n      this[$shadow] = shadow;\n    }\n  }\n\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n  setShadowSoftness(softness: number) {\n    const shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setSoftness(softness);\n    }\n  }\n\n  /**\n   * The shadow must be rotated manually to match any global rotation applied to\n   * this model. The input is the global orientation about the Y axis.\n   */\n  setShadowRotation(radiansY: number) {\n    const shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setRotation(radiansY);\n    }\n  }\n\n  /**\n   * Call when updating the shadow; returns true if an update is needed and\n   * resets the state.\n   */\n  updateShadow(): boolean {\n    const shadow = this[$shadow];\n    if (shadow == null) {\n      return false;\n    } else {\n      const {needsUpdate} = shadow;\n      shadow.needsUpdate = false;\n      return needsUpdate;\n    }\n  }\n\n  /**\n   * Shift the floor vertically from the bottom of the model's bounding box by\n   * offset (should generally be negative).\n   */\n  setShadowScaleAndOffset(scale: number, offset: number) {\n    const shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setScaleAndOffset(scale, offset);\n    }\n  }\n\n  /**\n   * The following methods are for operating on the set of Hotspot objects\n   * attached to the scene. These come from DOM elements, provided to slots by\n   * the Annotation Mixin.\n   */\n  addHotspot(hotspot: Hotspot) {\n    this.add(hotspot);\n  }\n\n  removeHotspot(hotspot: Hotspot) {\n    this.remove(hotspot);\n  }\n\n  /**\n   * Helper method to apply a function to all hotspots.\n   */\n  forHotspots(func: (hotspot: Hotspot) => void) {\n    const {children} = this;\n    for (let i = 0, l = children.length; i < l; i++) {\n      const hotspot = children[i];\n      if (hotspot instanceof Hotspot) {\n        func(hotspot);\n      }\n    }\n  }\n\n  /**\n   * Update the CSS visibility of the hotspots based on whether their normals\n   * point toward the camera.\n   */\n  updateHotspots(viewerPosition: Vector3) {\n    this.forHotspots((hotspot) => {\n      view.copy(viewerPosition);\n      target.setFromMatrixPosition(hotspot.matrixWorld);\n      view.sub(target);\n      normalWorld.copy(hotspot.normal).transformDirection(this.matrixWorld);\n      if (view.dot(normalWorld) < 0) {\n        hotspot.hide();\n      } else {\n        hotspot.show();\n      }\n    });\n  }\n\n  /**\n   * Rotate all hotspots to an absolute orientation given by the input number of\n   * radians. Zero returns them to upright.\n   */\n  orientHotspots(radians: number) {\n    this.forHotspots((hotspot) => {\n      hotspot.orient(radians);\n    });\n  }\n\n  /**\n   * Set the rendering visibility of all hotspots. This is used to hide them\n   * during transitions and such.\n   */\n  setHotspotsVisibility(visible: boolean) {\n    this.forHotspots((hotspot) => {\n      hotspot.visible = visible;\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}