{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nimport { Model } from './model.js';\nvar $model = Symbol('model');\nvar $elementsByInternalId = Symbol('elementsByInternalId');\n/**\n * ModelGraft\n *\n * This is a coordination primitive between a scene graph as represented by the\n * output for Three.js' GLTFLoader and a counterpart 3DOM facade. Since this is\n * the Three.js-specific implementation of the facade, the input is a GLTF-like\n * object whose keys refer to Three.js-specific constructs (e.g., gltf.scene is\n * a THREE.Scene).\n *\n * When created, the ModelGraft produces a Model that can be traversed and\n * manipulated to mutate the Three.js scene graph synchronously (but\n * indirectly). The benefit of this is that mutations to the Three.js scene can\n * be performed in a Three.js-agnostic fashion that is potentially portable to\n * alternative rendering backends.\n *\n * The scene graph representation produced by the ModelGraft is designed to\n * match the structures described in the glTF 2.0 spec as closely as possible.\n * Where there are deviations, it is usually for the purpose of making\n * synchronization easier, or else for ergonomics. For example, in glTF 2.0, the\n * graph is a series of flat arrays where nodes cross-reference each other by\n * index to represent hierarchy, but in a Model nodes have array members\n * containing refrences to their hierarchical children.\n *\n * An important goal of ModelGraft is to enable a scene in one JavaScript\n * context to be manipulated by script in a remote context, such as a distant\n * worker thread or even a different process. So, every node in the graph\n * is able to be serialized, and the serialized form includes an ID that is\n * locally unique to the ModelGraft instance that the node came from so that\n * the remote context can refer back to it. A ModelGraft can be thought of as\n * the host execution context counterpart to the ModelKernel in the scene graph\n * execution context.\n */\n\nexport var ModelGraft = /*#__PURE__*/function (_EventTarget) {\n  _inherits(ModelGraft, _EventTarget);\n\n  var _super = _createSuper(ModelGraft);\n\n  function ModelGraft(modelUri, gltf) {\n    var _this;\n\n    _classCallCheck(this, ModelGraft);\n\n    _this = _super.call(this);\n    _this[_a] = new Map();\n    _this[$model] = new Model(_assertThisInitialized(_this), modelUri, gltf);\n    return _this;\n  }\n\n  _createClass(ModelGraft, [{\n    key: \"getElementByInternalId\",\n    value: function getElementByInternalId(id) {\n      var element = this[$elementsByInternalId].get(id);\n\n      if (element == null) {\n        return null;\n      }\n\n      return element;\n    }\n  }, {\n    key: \"adopt\",\n    value: function adopt(element) {\n      this[$elementsByInternalId].set(element.internalID, element);\n    }\n  }, {\n    key: \"mutate\",\n    value: function () {\n      var _mutate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id, property, value) {\n        var element;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // TODO(#1005): Manipulations probably need to be validated against\n                // allowed capabilities here. We already do this on the scene graph\n                // execution context side, but it would be safer to do it on both sides\n                element = this.getElementByInternalId(id);\n\n                if (element != null && property in element) {\n                  element[property] = value;\n                  this.dispatchEvent(new CustomEvent('mutation', {\n                    detail: {\n                      element: element\n                    }\n                  }));\n                }\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function mutate(_x, _x2, _x3) {\n        return _mutate.apply(this, arguments);\n      }\n\n      return mutate;\n    }()\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this[$model];\n    }\n  }]);\n\n  return ModelGraft;\n}( /*#__PURE__*/_wrapNativeSuper(EventTarget));\n_a = $elementsByInternalId;","map":{"version":3,"sources":["../../../src/facade/three-js/model-graft.ts"],"names":[],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;;;;;AAmBA,SAAQ,KAAR,QAAoB,YAApB;AAGA,IAAM,MAAM,GAAG,MAAM,CAAC,OAAD,CAArB;AACA,IAAM,qBAAqB,GAAG,MAAM,CAAC,sBAAD,CAApC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,WAAa,UAAb;AAAA;;AAAA;;AAKE,sBAAY,QAAZ,EAA8B,IAA9B,EAAwC;AAAA;;AAAA;;AACtC;AAHK,UAAA,EAAA,IAA0B,IAAI,GAAJ,EAA1B;AAIL,UAAK,MAAL,IAAe,IAAI,KAAJ,gCAAgB,QAAhB,EAA0B,IAA1B,CAAf;AAFsC;AAGvC;;AARH;AAAA;AAAA,2CAcyB,EAdzB,EAcmC;AAC/B,UAAM,OAAO,GAAG,KAAK,qBAAL,EAA4B,GAA5B,CAAgC,EAAhC,CAAhB;;AAEA,UAAI,OAAO,IAAI,IAAf,EAAqB;AACnB,eAAO,IAAP;AACD;;AAED,aAAO,OAAP;AACD;AAtBH;AAAA;AAAA,0BAwBQ,OAxBR,EAwBgC;AAC5B,WAAK,qBAAL,EAA4B,GAA5B,CAAgC,OAAO,CAAC,UAAxC,EAAoD,OAApD;AACD;AA1BH;AAAA;AAAA;AAAA,8FA4Be,EA5Bf,EA4B2B,QA5B3B,EA4B6C,KA5B7C;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BI;AACA;AACA;AACM,gBAAA,OAhCV,GAgCoB,KAAK,sBAAL,CAA4B,EAA5B,CAhCpB;;AAkCI,oBAAI,OAAO,IAAI,IAAX,IAAmB,QAAQ,IAAI,OAAnC,EAA4C;AACzC,kBAAA,OAAiD,CAAC,QAAD,CAAjD,GAA8D,KAA9D;AAED,uBAAK,aAAL,CACI,IAAI,WAAJ,CAAgB,UAAhB,EAA4B;AAAC,oBAAA,MAAM,EAAE;AAAC,sBAAA,OAAO,EAAE;AAAV;AAAT,mBAA5B,CADJ;AAED;;AAvCL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,wBAUW;AACP,aAAO,KAAK,MAAL,CAAP;AACD;AAZH;;AAAA;AAAA,iCAAgC,WAAhC;KAGU,qB","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {ModelGraft as ModelGraftInterface} from '../api.js';\n\nimport {Model} from './model.js';\nimport {ThreeDOMElement} from './three-dom-element.js';\n\nconst $model = Symbol('model');\nconst $elementsByInternalId = Symbol('elementsByInternalId');\n\n/**\n * ModelGraft\n *\n * This is a coordination primitive between a scene graph as represented by the\n * output for Three.js' GLTFLoader and a counterpart 3DOM facade. Since this is\n * the Three.js-specific implementation of the facade, the input is a GLTF-like\n * object whose keys refer to Three.js-specific constructs (e.g., gltf.scene is\n * a THREE.Scene).\n *\n * When created, the ModelGraft produces a Model that can be traversed and\n * manipulated to mutate the Three.js scene graph synchronously (but\n * indirectly). The benefit of this is that mutations to the Three.js scene can\n * be performed in a Three.js-agnostic fashion that is potentially portable to\n * alternative rendering backends.\n *\n * The scene graph representation produced by the ModelGraft is designed to\n * match the structures described in the glTF 2.0 spec as closely as possible.\n * Where there are deviations, it is usually for the purpose of making\n * synchronization easier, or else for ergonomics. For example, in glTF 2.0, the\n * graph is a series of flat arrays where nodes cross-reference each other by\n * index to represent hierarchy, but in a Model nodes have array members\n * containing refrences to their hierarchical children.\n *\n * An important goal of ModelGraft is to enable a scene in one JavaScript\n * context to be manipulated by script in a remote context, such as a distant\n * worker thread or even a different process. So, every node in the graph\n * is able to be serialized, and the serialized form includes an ID that is\n * locally unique to the ModelGraft instance that the node came from so that\n * the remote context can refer back to it. A ModelGraft can be thought of as\n * the host execution context counterpart to the ModelKernel in the scene graph\n * execution context.\n */\nexport class ModelGraft extends EventTarget implements ModelGraftInterface {\n  private[$model]: Model;\n\n  private[$elementsByInternalId] = new Map<number, ThreeDOMElement>();\n\n  constructor(modelUri: string, gltf: GLTF) {\n    super();\n    this[$model] = new Model(this, modelUri, gltf);\n  }\n\n  get model() {\n    return this[$model];\n  }\n\n  getElementByInternalId(id: number): ThreeDOMElement|null {\n    const element = this[$elementsByInternalId].get(id);\n\n    if (element == null) {\n      return null;\n    }\n\n    return element;\n  }\n\n  adopt(element: ThreeDOMElement) {\n    this[$elementsByInternalId].set(element.internalID, element);\n  }\n\n  async mutate(id: number, property: string, value: unknown) {\n    // TODO(#1005): Manipulations probably need to be validated against\n    // allowed capabilities here. We already do this on the scene graph\n    // execution context side, but it would be safer to do it on both sides\n    const element = this.getElementByInternalId(id);\n\n    if (element != null && property in element) {\n      (element as unknown as {[index: string]: unknown})[property] = value;\n\n      this.dispatchEvent(\n          new CustomEvent('mutation', {detail: {element: element}}));\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}