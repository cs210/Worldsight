{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { clamp } from '../utilities.js';\nvar $ongoingActivities = Symbol('ongoingActivities');\nvar $announceTotalProgress = Symbol('announceTotalProgress');\nvar $eventDelegate = Symbol('eventDelegate');\nvar ACTIVITY_PROGRESS_WEIGHT = 0.5;\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents a abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\n\nexport var ProgressTracker = /*#__PURE__*/function () {\n  function ProgressTracker() {\n    var _this = this;\n\n    _classCallCheck(this, ProgressTracker);\n\n    // NOTE(cdata): This eventDelegate hack is a quick trick to let us get the\n    // EventTarget interface without implementing or requiring a full polyfill. We\n    // should remove this once EventTarget is inheritable everywhere.\n    this[_a] = document.createDocumentFragment(); // NOTE(cdata): We declare each of these methods independently here so that we\n    // can inherit the correct types from EventTarget's interface. Maybe there is\n    // a better way to do this dynamically so that we don't repeat ourselves?\n\n    this.addEventListener = function () {\n      var _this$$eventDelegate;\n\n      return (_this$$eventDelegate = _this[$eventDelegate]).addEventListener.apply(_this$$eventDelegate, arguments);\n    };\n\n    this.removeEventListener = function () {\n      var _this$$eventDelegate2;\n\n      return (_this$$eventDelegate2 = _this[$eventDelegate]).removeEventListener.apply(_this$$eventDelegate2, arguments);\n    };\n\n    this.dispatchEvent = function () {\n      var _this$$eventDelegate3;\n\n      return (_this$$eventDelegate3 = _this[$eventDelegate]).dispatchEvent.apply(_this$$eventDelegate3, arguments);\n    };\n\n    this[_b] = new Set();\n  }\n  /**\n   * The total number of activities currently being tracked.\n   */\n\n\n  _createClass(ProgressTracker, [{\n    key: \"beginActivity\",\n\n    /**\n     * Registers a new activity to be tracked by the progress tracker. The method\n     * returns a special callback that should be invoked whenever new progress is\n     * ready to be reported. The progress should be reported as a value between 0\n     * and 1, where 0 would represent the beginning of the action and 1 would\n     * represent its completion.\n     *\n     * There is no built-in notion of a time-out for ongoing activities, so once\n     * an ongoing activity is begun, it is up to the consumer of this API to\n     * update the progress until that activity is no longer ongoing.\n     *\n     * Progress is only allowed to move forward for any given activity. If a lower\n     * progress is reported than the previously reported progress, it will be\n     * ignored.\n     */\n    value: function beginActivity() {\n      var _this2 = this;\n\n      var activity = {\n        progress: 0\n      };\n      this[$ongoingActivities].add(activity);\n\n      if (this.ongoingActivityCount === 1) {\n        // Announce the first progress event (which should always be 0 / 1\n        // total progress):\n        this[$announceTotalProgress]();\n      }\n\n      return function (progress) {\n        var nextProgress;\n        nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n\n        if (nextProgress !== activity.progress) {\n          activity.progress = nextProgress;\n\n          _this2[$announceTotalProgress]();\n        }\n\n        return activity.progress;\n      };\n    }\n  }, {\n    key: (_a = $eventDelegate, _b = $ongoingActivities, $announceTotalProgress),\n    value: function value() {\n      var totalProgress = 0;\n      var statusCount = 0;\n      var completedActivities = 0;\n\n      var _iterator = _createForOfIteratorHelper(this[$ongoingActivities]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var activity = _step.value;\n          var progress = activity.progress;\n          var compoundWeight = ACTIVITY_PROGRESS_WEIGHT / Math.pow(2, statusCount++);\n          totalProgress += progress * compoundWeight;\n\n          if (progress === 1.0) {\n            completedActivities++;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (completedActivities === this.ongoingActivityCount) {\n        totalProgress = 1.0;\n        this[$ongoingActivities].clear();\n      }\n\n      this.dispatchEvent(new CustomEvent('progress', {\n        detail: {\n          totalProgress: totalProgress\n        }\n      }));\n    }\n  }, {\n    key: \"ongoingActivityCount\",\n    get: function get() {\n      return this[$ongoingActivities].size;\n    }\n  }]);\n\n  return ProgressTracker;\n}();","map":{"version":3,"sources":["../../src/utilities/progress-tracker.ts"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;AAeA,SAAQ,KAAR,QAAoB,iBAApB;AAKA,IAAM,kBAAkB,GAAG,MAAM,CAAC,mBAAD,CAAjC;AACA,IAAM,sBAAsB,GAAG,MAAM,CAAC,uBAAD,CAArC;AACA,IAAM,cAAc,GAAG,MAAM,CAAC,eAAD,CAA7B;AAEA,IAAM,wBAAwB,GAAG,GAAjC;AAmBA;;;;;;;;;;;;;;;;;;;;;AAoBA,WAAa,eAAb;AAAA,6BAAA;AAAA;;AAAA;;AACE;AACA;AACA;AACS,SAAA,EAAA,IACL,QAAQ,CAAC,sBAAT,EADK,CAJX,CAOE;AACA;AACA;;AACO,SAAA,gBAAA,GACH;AAAA;;AAAA,aAAa,wBAAA,KAAI,CAAC,cAAD,CAAJ,EAAqB,gBAArB,uCAAb;AAAA,KADG;;AAEA,SAAA,mBAAA,GACH;AAAA;;AAAA,aAAa,yBAAA,KAAI,CAAC,cAAD,CAAJ,EAAqB,mBAArB,wCAAb;AAAA,KADG;;AAEA,SAAA,aAAA,GACH;AAAA;;AAAA,aAAa,yBAAA,KAAI,CAAC,cAAD,CAAJ,EAAqB,aAArB,wCAAb;AAAA,KADG;;AAIE,SAAA,EAAA,IAA6C,IAAI,GAAJ,EAA7C;AA0EV;AAxEC;;;;;AApBF;AAAA;;AA2BE;;;;;;;;;;;;;;;AA3BF,oCA0Ce;AAAA;;AACX,UAAM,QAAQ,GAAoB;AAAC,QAAA,QAAQ,EAAE;AAAX,OAAlC;AAEA,WAAK,kBAAL,EAAyB,GAAzB,CAA6B,QAA7B;;AAEA,UAAI,KAAK,oBAAL,KAA8B,CAAlC,EAAqC;AACnC;AACA;AACA,aAAK,sBAAL;AACD;;AAED,aAAO,UAAC,QAAD,EAA6B;AAClC,YAAI,YAAJ;AAEA,QAAA,YAAY,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,QAAD,EAAW,CAAX,EAAc,CAAd,CAAd,EAAgC,QAAQ,CAAC,QAAzC,CAAf;;AAEA,YAAI,YAAY,KAAK,QAAQ,CAAC,QAA9B,EAAwC;AACtC,UAAA,QAAQ,CAAC,QAAT,GAAoB,YAApB;;AACA,UAAA,MAAI,CAAC,sBAAD,CAAJ;AACD;;AAED,eAAO,QAAQ,CAAC,QAAhB;AACD,OAXD;AAYD;AAjEH;AAAA,UAmEE,EAAA,GA/DU,cA+DV,EA/DwB,EAAA,GAcd,kBAiDV,EAAC,sBAnEH;AAAA,4BAmE0B;AACtB,UAAI,aAAa,GAAG,CAApB;AACA,UAAI,WAAW,GAAG,CAAlB;AACA,UAAI,mBAAmB,GAAG,CAA1B;;AAHsB,iDAKC,KAAK,kBAAL,CALD;AAAA;;AAAA;AAKtB,4DAAiD;AAAA,cAAtC,QAAsC;AAAA,cACxC,QADwC,GAC5B,QAD4B,CACxC,QADwC;AAE/C,cAAM,cAAc,GAChB,wBAAwB,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,WAAW,EAAvB,CAD/B;AAGA,UAAA,aAAa,IAAI,QAAQ,GAAG,cAA5B;;AAEA,cAAI,QAAQ,KAAK,GAAjB,EAAsB;AACpB,YAAA,mBAAmB;AACpB;AACF;AAfqB;AAAA;AAAA;AAAA;AAAA;;AAiBtB,UAAI,mBAAmB,KAAK,KAAK,oBAAjC,EAAuD;AACrD,QAAA,aAAa,GAAG,GAAhB;AACA,aAAK,kBAAL,EAAyB,KAAzB;AACD;;AAED,WAAK,aAAL,CAAmB,IAAI,WAAJ,CACf,UADe,EACH;AAAC,QAAA,MAAM,EAAE;AAAC,UAAA,aAAa,EAAb;AAAD;AAAT,OADG,CAAnB;AAED;AA3FH;AAAA;AAAA,wBAuB0B;AACtB,aAAO,KAAK,kBAAL,EAAyB,IAAhC;AACD;AAzBH;;AAAA;AAAA","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {clamp} from '../utilities.js';\n\ninterface OngoingActivity {\n  progress: number;\n}\nconst $ongoingActivities = Symbol('ongoingActivities');\nconst $announceTotalProgress = Symbol('announceTotalProgress');\nconst $eventDelegate = Symbol('eventDelegate');\n\nconst ACTIVITY_PROGRESS_WEIGHT = 0.5;\n\n/**\n * An Activity is represented by a callback that accepts values from 0 to 1,\n * where 1 represents the completion of the activity. The callback returns the\n * actual progress as it is stored by the ProgressTracker (which may be clamped,\n * and can never be lower than its previous value).\n */\nexport type Activity = (progress: number) => number;\n\n/**\n * A progress event contains the total progress of all ongoing activities in the\n * ProgressTracker. The progress is a heuristic, should not be considered an\n * absolute representation of progress across any or all events.\n */\nexport interface ProgressDetails {\n  totalProgress: number;\n}\n\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents a abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\nexport class ProgressTracker implements EventTarget {\n  // NOTE(cdata): This eventDelegate hack is a quick trick to let us get the\n  // EventTarget interface without implementing or requiring a full polyfill. We\n  // should remove this once EventTarget is inheritable everywhere.\n  protected[$eventDelegate]: DocumentFragment =\n      document.createDocumentFragment();\n\n  // NOTE(cdata): We declare each of these methods independently here so that we\n  // can inherit the correct types from EventTarget's interface. Maybe there is\n  // a better way to do this dynamically so that we don't repeat ourselves?\n  public addEventListener: typeof EventTarget.prototype.addEventListener =\n      (...args) => this[$eventDelegate].addEventListener(...args);\n  public removeEventListener: typeof EventTarget.prototype.removeEventListener =\n      (...args) => this[$eventDelegate].removeEventListener(...args);\n  public dispatchEvent: typeof EventTarget.prototype.dispatchEvent =\n      (...args) => this[$eventDelegate].dispatchEvent(...args);\n\n\n  protected[$ongoingActivities]: Set<OngoingActivity> = new Set();\n\n  /**\n   * The total number of activities currently being tracked.\n   */\n  get ongoingActivityCount(): number {\n    return this[$ongoingActivities].size;\n  }\n\n  /**\n   * Registers a new activity to be tracked by the progress tracker. The method\n   * returns a special callback that should be invoked whenever new progress is\n   * ready to be reported. The progress should be reported as a value between 0\n   * and 1, where 0 would represent the beginning of the action and 1 would\n   * represent its completion.\n   *\n   * There is no built-in notion of a time-out for ongoing activities, so once\n   * an ongoing activity is begun, it is up to the consumer of this API to\n   * update the progress until that activity is no longer ongoing.\n   *\n   * Progress is only allowed to move forward for any given activity. If a lower\n   * progress is reported than the previously reported progress, it will be\n   * ignored.\n   */\n  beginActivity(): Activity {\n    const activity: OngoingActivity = {progress: 0};\n\n    this[$ongoingActivities].add(activity);\n\n    if (this.ongoingActivityCount === 1) {\n      // Announce the first progress event (which should always be 0 / 1\n      // total progress):\n      this[$announceTotalProgress]();\n    }\n\n    return (progress: number): number => {\n      let nextProgress: number;\n\n      nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n\n      if (nextProgress !== activity.progress) {\n        activity.progress = nextProgress;\n        this[$announceTotalProgress]();\n      }\n\n      return activity.progress;\n    };\n  }\n\n  [$announceTotalProgress]() {\n    let totalProgress = 0;\n    let statusCount = 0;\n    let completedActivities = 0;\n\n    for (const activity of this[$ongoingActivities]) {\n      const {progress} = activity;\n      const compoundWeight =\n          ACTIVITY_PROGRESS_WEIGHT / Math.pow(2, statusCount++);\n\n      totalProgress += progress * compoundWeight;\n\n      if (progress === 1.0) {\n        completedActivities++;\n      }\n    }\n\n    if (completedActivities === this.ongoingActivityCount) {\n      totalProgress = 1.0;\n      this[$ongoingActivities].clear();\n    }\n\n    this.dispatchEvent(new CustomEvent<ProgressDetails>(\n        'progress', {detail: {totalProgress}}));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}