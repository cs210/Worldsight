{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { ALLOWLISTED_GLOBALS } from './context/allowlist.js';\nimport { generateAPI } from './context/generate-api.js';\nimport { generateCapabilityFilter } from './context/generate-capability-filter.js';\nimport { generateContextPatch } from './context/generate-context-patch.js';\nimport { generateInitializer } from './context/generate-initializer.js';\nimport { ThreeDOMMessageType } from './protocol.js';\nvar $modelGraft = Symbol('modelGraft');\nvar $port = Symbol('port');\nvar $messageEventHandler = Symbol('messageEventHandler');\nvar $onMessageEvent = Symbol('onMessageEvent');\n/**\n * A ModelGraftManipulator is an internal construct intended to consolidate\n * any mutations that operate on the backing scene graph. It can be thought\n * of as a host execution context counterpart to the ModelKernel in the scene\n * graph execution context.\n */\n\nvar ModelGraftManipulator = /*#__PURE__*/function () {\n  function ModelGraftManipulator(modelGraft, port) {\n    var _this = this;\n\n    _classCallCheck(this, ModelGraftManipulator);\n\n    this[_a] = function (event) {\n      return _this[$onMessageEvent](event);\n    };\n\n    this[$modelGraft] = modelGraft;\n    this[$port] = port;\n    this[$port].addEventListener('message', this[$messageEventHandler]);\n    this[$port].start();\n  }\n  /**\n   * Clean up internal state so that the ModelGraftManipulator can be properly\n   * garbage collected.\n   */\n\n\n  _createClass(ModelGraftManipulator, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this[$port].removeEventListener('message', this[$messageEventHandler]);\n      this[$port].close();\n    }\n  }, {\n    key: (_a = $messageEventHandler, $onMessageEvent),\n    value: function value(event) {\n      var data = event.data;\n\n      if (data && data.type) {\n        if (data.type === ThreeDOMMessageType.MUTATE) {\n          var applied = false;\n          var mutationId = data.mutationId;\n\n          try {\n            this[$modelGraft].mutate(data.id, data.property, data.value);\n            applied = true;\n          } finally {\n            this[$port].postMessage({\n              type: ThreeDOMMessageType.MUTATION_RESULT,\n              applied: applied,\n              mutationId: mutationId\n            });\n          }\n        }\n      }\n    }\n  }]);\n\n  return ModelGraftManipulator;\n}();\n\nvar ALL_CAPABILITIES = Object.freeze(['messaging', 'material-properties', 'fetch']);\n/**\n * Constructs and returns a string representing a fully-formed scene graph\n * execution context script, including context patching, capabilities and\n * scene graph API constructs.\n */\n\nexport var generateContextScriptSource = function generateContextScriptSource() {\n  var capabilities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ALL_CAPABILITIES;\n  return \";(function() {\\nvar ThreeDOMMessageType = \".concat(JSON.stringify(ThreeDOMMessageType), \";\\n\\nvar preservedContext = {\\n  postMessage: self.postMessage.bind(self),\\n  addEventListener: self.addEventListener.bind(self),\\n  importScripts: self.importScripts.bind(self)\\n};\\n\\n\").concat(generateContextPatch(ALLOWLISTED_GLOBALS), \"\\n\").concat(generateAPI(), \"\\n\").concat(generateCapabilityFilter(capabilities), \"\\n\").concat(generateInitializer(), \"\\n\\ninitialize.call(self, ModelKernel, preservedContext);\\n\\n})();\");\n};\nvar $worker = Symbol('worker');\nvar $workerInitializes = Symbol('workerInitializes');\nvar $modelGraftManipulator = Symbol('modelGraftManipulator');\n/**\n * A ThreeDOMExecutionContext is created in the host execution context that\n * wishes to invoke scripts in a specially crafted and carefully isolated\n * script context, referred to as the scene graph execution context. For\n * practical implementation purposes, the scene graph execution context is\n * a Worker whose global scope has been heavily patched before any custom\n * script is subsequently invoked in it.\n *\n * The ThreeDOMExecutionContext must be given a set of allowed capabilities\n * when it is created. The allowed capabilities cannot be changed after the\n * scene graph execution context has been established.\n */\n\nexport var ThreeDOMExecutionContext = /*#__PURE__*/function (_EventTarget) {\n  _inherits(ThreeDOMExecutionContext, _EventTarget);\n\n  var _super = _createSuper(ThreeDOMExecutionContext);\n\n  function ThreeDOMExecutionContext(capabilities) {\n    var _this2;\n\n    _classCallCheck(this, ThreeDOMExecutionContext);\n\n    _this2 = _super.call(this);\n    _this2[_b] = null;\n    var contextScriptSource = generateContextScriptSource(capabilities);\n    var url = URL.createObjectURL(new Blob([contextScriptSource], {\n      type: 'text/javascript'\n    }));\n    _this2[$worker] = new Worker(url);\n    _this2[$workerInitializes] = new Promise(function (resolve) {\n      var _MessageChannel = new MessageChannel(),\n          port1 = _MessageChannel.port1,\n          port2 = _MessageChannel.port2;\n\n      var onMessageEvent = function onMessageEvent(event) {\n        if (event.data && event.data.type === ThreeDOMMessageType.CONTEXT_INITIALIZED) {\n          port1.removeEventListener('message', onMessageEvent);\n          resolve(port1);\n        }\n      };\n\n      _this2[$worker].postMessage({\n        type: ThreeDOMMessageType.HANDSHAKE\n      }, [port2]);\n\n      port1.addEventListener('message', onMessageEvent);\n      port1.start();\n    });\n    return _this2;\n  }\n\n  _createClass(ThreeDOMExecutionContext, [{\n    key: \"changeModel\",\n    value: function () {\n      var _changeModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(modelGraft) {\n        var port, _MessageChannel2, port1, port2, modelGraftManipulator;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this[$workerInitializes];\n\n              case 2:\n                port = _context.sent;\n                _MessageChannel2 = new MessageChannel(), port1 = _MessageChannel2.port1, port2 = _MessageChannel2.port2;\n                port.postMessage({\n                  type: ThreeDOMMessageType.MODEL_CHANGE,\n                  model: modelGraft != null && modelGraft.model != null ? modelGraft.model.toJSON() : null\n                }, [port2]);\n                modelGraftManipulator = this[$modelGraftManipulator];\n\n                if (modelGraftManipulator != null) {\n                  modelGraftManipulator.dispose();\n                  this[$modelGraftManipulator] = null;\n                }\n\n                if (modelGraft != null) {\n                  this[$modelGraftManipulator] = new ModelGraftManipulator(modelGraft, port1);\n                }\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function changeModel(_x) {\n        return _changeModel.apply(this, arguments);\n      }\n\n      return changeModel;\n    }()\n    /**\n     * Evaluate an arbitrary chunk of script in the scene graph execution context.\n     * The script is guaranteed to be evaluated after the scene graph execution\n     * context is fully initialized. It is not guaranteed to be evaluated before\n     * or after a Model is made available in the scene graph execution context.\n     *\n     * Note that web browsers do not universally support module scripts (\"ESM\") in\n     * Workers, so for now all scripts must be valid non-module scripts.\n     */\n\n  }, {\n    key: \"eval\",\n    value: function () {\n      var _eval2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(scriptSource) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.import(URL.createObjectURL(new Blob([scriptSource], {\n                  type: 'text/javascript'\n                })));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _eval(_x2) {\n        return _eval2.apply(this, arguments);\n      }\n\n      return _eval;\n    }()\n    /* end eval marker (do not remove) */\n\n    /**\n     * Load a script by URL in the scene graph execution context. Generally works\n     * the same as eval, but is generally safer because it allows you full control\n     * of the script text. Like eval, does not support module scripts.\n     */\n\n  }, {\n    key: \"import\",\n    value: function () {\n      var _import2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url) {\n        var port;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this[$workerInitializes];\n\n              case 2:\n                port = _context3.sent;\n                port.postMessage({\n                  type: ThreeDOMMessageType.IMPORT_SCRIPT,\n                  url: url\n                });\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _import(_x3) {\n        return _import2.apply(this, arguments);\n      }\n\n      return _import;\n    }()\n    /**\n     * Terminates the scene graph execution context, closes the designated\n     * messaging port and generally cleans up the ThreeDOMExecutionContext\n     * so that it can be properly garbage collected.\n     */\n\n  }, {\n    key: \"terminate\",\n    value: function () {\n      var _terminate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var modelGraftManipulator, port;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this[$worker].terminate();\n                modelGraftManipulator = this[$modelGraftManipulator];\n\n                if (modelGraftManipulator != null) {\n                  modelGraftManipulator.dispose();\n                  this[$modelGraftManipulator] = null;\n                }\n\n                _context4.next = 5;\n                return this[$workerInitializes];\n\n              case 5:\n                port = _context4.sent;\n                port.close();\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function terminate() {\n        return _terminate.apply(this, arguments);\n      }\n\n      return terminate;\n    }()\n  }, {\n    key: \"worker\",\n    get: function get() {\n      return this[$worker];\n    }\n  }]);\n\n  return ThreeDOMExecutionContext;\n}( /*#__PURE__*/_wrapNativeSuper(EventTarget));\n_b = $modelGraftManipulator;","map":{"version":3,"sources":["../src/context.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ThreeDOMCapability} from './api.js';\nimport {ALLOWLISTED_GLOBALS} from './context/allowlist.js';\nimport {generateAPI} from './context/generate-api.js';\nimport {generateCapabilityFilter} from './context/generate-capability-filter.js';\nimport {generateContextPatch} from './context/generate-context-patch.js';\nimport {generateInitializer} from './context/generate-initializer.js';\nimport {ModelGraft} from './facade/api.js';\nimport {MutateMessage, ThreeDOMMessageType} from './protocol.js';\n\nconst $modelGraft = Symbol('modelGraft');\nconst $port = Symbol('port');\n\nconst $messageEventHandler = Symbol('messageEventHandler');\nconst $onMessageEvent = Symbol('onMessageEvent');\n\n/**\n * A ModelGraftManipulator is an internal construct intended to consolidate\n * any mutations that operate on the backing scene graph. It can be thought\n * of as a host execution context counterpart to the ModelKernel in the scene\n * graph execution context.\n */\nclass ModelGraftManipulator {\n  protected[$port]: MessagePort;\n  protected[$modelGraft]: ModelGraft;\n\n  protected[$messageEventHandler] = (event: MessageEvent) =>\n      this[$onMessageEvent](event);\n\n  constructor(modelGraft: ModelGraft, port: MessagePort) {\n    this[$modelGraft] = modelGraft;\n    this[$port] = port;\n    this[$port].addEventListener('message', this[$messageEventHandler]);\n    this[$port].start();\n  }\n\n  /**\n   * Clean up internal state so that the ModelGraftManipulator can be properly\n   * garbage collected.\n   */\n  dispose() {\n    this[$port].removeEventListener('message', this[$messageEventHandler]);\n    this[$port].close();\n  }\n\n  [$onMessageEvent](event: MessageEvent) {\n    const {data} = event;\n    if (data && data.type) {\n      if (data.type === ThreeDOMMessageType.MUTATE) {\n        let applied = false;\n        const {mutationId} = data as MutateMessage;\n        try {\n          this[$modelGraft].mutate(data.id, data.property, data.value);\n          applied = true;\n        } finally {\n          this[$port].postMessage(\n              {type: ThreeDOMMessageType.MUTATION_RESULT, applied, mutationId});\n        }\n      }\n    }\n  }\n}\n\n\nconst ALL_CAPABILITIES: Readonly<Array<ThreeDOMCapability>> =\n    Object.freeze(['messaging', 'material-properties', 'fetch']);\n\n/**\n * Constructs and returns a string representing a fully-formed scene graph\n * execution context script, including context patching, capabilities and\n * scene graph API constructs.\n */\nexport const generateContextScriptSource =\n    (capabilities: Readonly<Array<ThreeDOMCapability>> = ALL_CAPABILITIES) => {\n      return `;(function() {\nvar ThreeDOMMessageType = ${JSON.stringify(ThreeDOMMessageType)};\n\nvar preservedContext = {\n  postMessage: self.postMessage.bind(self),\n  addEventListener: self.addEventListener.bind(self),\n  importScripts: self.importScripts.bind(self)\n};\n\n${generateContextPatch(ALLOWLISTED_GLOBALS)}\n${generateAPI()}\n${generateCapabilityFilter(capabilities)}\n${generateInitializer()}\n\ninitialize.call(self, ModelKernel, preservedContext);\n\n})();`;\n    };\n\n\nconst $worker = Symbol('worker');\nconst $workerInitializes = Symbol('workerInitializes');\nconst $modelGraftManipulator = Symbol('modelGraftManipulator');\n\n/**\n * A ThreeDOMExecutionContext is created in the host execution context that\n * wishes to invoke scripts in a specially crafted and carefully isolated\n * script context, referred to as the scene graph execution context. For\n * practical implementation purposes, the scene graph execution context is\n * a Worker whose global scope has been heavily patched before any custom\n * script is subsequently invoked in it.\n *\n * The ThreeDOMExecutionContext must be given a set of allowed capabilities\n * when it is created. The allowed capabilities cannot be changed after the\n * scene graph execution context has been established.\n */\nexport class ThreeDOMExecutionContext extends EventTarget {\n  get worker() {\n    return this[$worker];\n  }\n\n  protected[$worker]: Worker;\n  protected[$workerInitializes]: Promise<MessagePort>;\n  protected[$modelGraftManipulator]: ModelGraftManipulator|null = null;\n\n  constructor(capabilities: Array<ThreeDOMCapability>) {\n    super();\n\n    const contextScriptSource = generateContextScriptSource(capabilities);\n    const url = URL.createObjectURL(\n        new Blob([contextScriptSource], {type: 'text/javascript'}));\n\n    this[$worker] = new Worker(url);\n    this[$workerInitializes] = new Promise<MessagePort>((resolve) => {\n      const {port1, port2} = new MessageChannel();\n      const onMessageEvent = (event: MessageEvent) => {\n        if (event.data &&\n            event.data.type === ThreeDOMMessageType.CONTEXT_INITIALIZED) {\n          port1.removeEventListener('message', onMessageEvent);\n\n          resolve(port1);\n        }\n      };\n\n      this[$worker].postMessage({type: ThreeDOMMessageType.HANDSHAKE}, [port2]);\n\n      port1.addEventListener('message', onMessageEvent);\n      port1.start();\n    });\n  }\n\n  async changeModel(modelGraft: ModelGraft|null): Promise<void> {\n    const port = await this[$workerInitializes];\n    const {port1, port2} = new MessageChannel();\n\n    port.postMessage(\n        {\n          type: ThreeDOMMessageType.MODEL_CHANGE,\n          model: modelGraft != null && modelGraft.model != null ?\n              modelGraft.model.toJSON() :\n              null\n        },\n        [port2]);\n\n    const modelGraftManipulator = this[$modelGraftManipulator];\n\n    if (modelGraftManipulator != null) {\n      modelGraftManipulator.dispose();\n      this[$modelGraftManipulator] = null;\n    }\n\n    if (modelGraft != null) {\n      this[$modelGraftManipulator] =\n          new ModelGraftManipulator(modelGraft, port1);\n    }\n  }\n\n  /**\n   * Evaluate an arbitrary chunk of script in the scene graph execution context.\n   * The script is guaranteed to be evaluated after the scene graph execution\n   * context is fully initialized. It is not guaranteed to be evaluated before\n   * or after a Model is made available in the scene graph execution context.\n   *\n   * Note that web browsers do not universally support module scripts (\"ESM\") in\n   * Workers, so for now all scripts must be valid non-module scripts.\n   */\n  async eval(scriptSource: string): Promise<void> {\n    await this.import(URL.createObjectURL(\n        new Blob([scriptSource], {type: 'text/javascript'})));\n  } /* end eval marker (do not remove) */\n\n  /**\n   * Load a script by URL in the scene graph execution context. Generally works\n   * the same as eval, but is generally safer because it allows you full control\n   * of the script text. Like eval, does not support module scripts.\n   */\n  async import(url: string): Promise<void> {\n    const port = await this[$workerInitializes];\n    port.postMessage({type: ThreeDOMMessageType.IMPORT_SCRIPT, url});\n  }\n\n  /**\n   * Terminates the scene graph execution context, closes the designated\n   * messaging port and generally cleans up the ThreeDOMExecutionContext\n   * so that it can be properly garbage collected.\n   */\n  async terminate() {\n    this[$worker].terminate();\n\n    const modelGraftManipulator = this[$modelGraftManipulator];\n\n    if (modelGraftManipulator != null) {\n      modelGraftManipulator.dispose();\n      this[$modelGraftManipulator] = null;\n    }\n\n    const port = await this[$workerInitializes];\n    port.close();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}