{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d;\n\nimport { ASTWalker } from './parsers';\nvar $instances = Symbol('instances');\nvar $activateListener = Symbol('activateListener');\nvar $deactivateListener = Symbol('deactivateListener');\nvar $notifyInstances = Symbol('notifyInstances');\nvar $notify = Symbol('notify');\nvar $scrollCallback = Symbol('callback');\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance anlyses) as well as potential memory leaks.\n */\n\nvar ScrollObserver = /*#__PURE__*/function () {\n  function ScrollObserver(callback) {\n    _classCallCheck(this, ScrollObserver);\n\n    this[$scrollCallback] = callback;\n  }\n\n  _createClass(ScrollObserver, [{\n    key: \"observe\",\n\n    /**\n     * Listen for scroll events. The configured callback (passed to the\n     * constructor) will be invoked for subsequent global scroll events.\n     */\n    value: function observe() {\n      if (ScrollObserver[$instances].size === 0) {\n        ScrollObserver[$activateListener]();\n      }\n\n      ScrollObserver[$instances].add(this);\n    }\n    /**\n     * Stop listening for scroll events.\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      ScrollObserver[$instances].delete(this);\n\n      if (ScrollObserver[$instances].size === 0) {\n        ScrollObserver[$deactivateListener]();\n      }\n    }\n  }, {\n    key: $notify,\n    value: function value() {\n      this[$scrollCallback]();\n    }\n  }], [{\n    key: $notifyInstances,\n    value: function value() {\n      var _iterator = _createForOfIteratorHelper(ScrollObserver[$instances]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var instance = _step.value;\n          instance[$notify]();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: (_a = $instances, $activateListener),\n    value: function value() {\n      window.addEventListener('scroll', this[$notifyInstances], {\n        passive: true\n      });\n    }\n  }, {\n    key: $deactivateListener,\n    value: function value() {\n      window.removeEventListener('scroll', this[$notifyInstances]);\n    }\n  }]);\n\n  return ScrollObserver;\n}();\n\nScrollObserver[_a] = new Set();\nvar $computeStyleCallback = Symbol('computeStyleCallback');\nvar $astWalker = Symbol('astWalker');\nvar $dependencies = Symbol('dependencies');\nvar $scrollHandler = Symbol('scrollHandler');\nvar $onScroll = Symbol('onScroll');\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\n\nexport var StyleEffector = /*#__PURE__*/function () {\n  function StyleEffector(callback) {\n    var _this = this;\n\n    _classCallCheck(this, StyleEffector);\n\n    this[_b] = {};\n    this[_c] = new ASTWalker(['function']);\n\n    this[_d] = function () {\n      return _this[$onScroll]();\n    };\n\n    this[$computeStyleCallback] = callback;\n  }\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n\n\n  _createClass(StyleEffector, [{\n    key: \"observeEffectsFor\",\n    value: function observeEffectsFor(ast) {\n      var _this2 = this;\n\n      var newDependencies = {};\n      var oldDependencies = this[$dependencies];\n      this[$astWalker].walk(ast, function (functionNode) {\n        var name = functionNode.name;\n        var firstArgument = functionNode.arguments[0];\n        var firstTerm = firstArgument.terms[0];\n\n        if (name.value !== 'env' || firstTerm == null || firstTerm.type !== 'ident') {\n          return;\n        }\n\n        switch (firstTerm.value) {\n          case 'window-scroll-y':\n            if (newDependencies['window-scroll'] == null) {\n              var observer = 'window-scroll' in oldDependencies ? oldDependencies['window-scroll'] : new ScrollObserver(_this2[$scrollHandler]);\n              observer.observe();\n              delete oldDependencies['window-scroll'];\n              newDependencies['window-scroll'] = observer;\n            }\n\n            break;\n        }\n      });\n\n      for (var environmentState in oldDependencies) {\n        var observer = oldDependencies[environmentState];\n        observer.disconnect();\n      }\n\n      this[$dependencies] = newDependencies;\n    }\n    /**\n     * Disposes of the StyleEffector by disconnecting all observers of external\n     * effects.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var environmentState in this[$dependencies]) {\n        var observer = this[$dependencies][environmentState];\n        observer.disconnect();\n      }\n    }\n  }, {\n    key: (_b = $dependencies, _c = $astWalker, _d = $scrollHandler, $onScroll),\n    value: function value() {\n      this[$computeStyleCallback]({\n        relatedState: 'window-scroll'\n      });\n    }\n  }]);\n\n  return StyleEffector;\n}();","map":{"version":3,"sources":["../../src/styles/style-effector.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ASTWalker, ExpressionNode, FunctionNode} from './parsers';\n\ninterface AnyObserver {\n  observe(): void;\n  disconnect(): void;\n}\n\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n\ntype ScrollObserverCallback = () => void;\n\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance anlyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n  private static[$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n  private static[$instances]: Set<ScrollObserver> = new Set();\n  private static[$activateListener]() {\n    window.addEventListener('scroll', this[$notifyInstances], {passive: true});\n  }\n  private static[$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n\n  private[$scrollCallback]: ScrollObserverCallback;\n\n  constructor(callback: ScrollObserverCallback) {\n    this[$scrollCallback] = callback;\n  }\n\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n    ScrollObserver[$instances].add(this);\n  }\n\n  /**\n   * Stop listening for scroll events.\n   */\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n\n  private[$notify]() {\n    this[$scrollCallback]();\n  };\n}\n\n\nexport type EnvironmentState = 'window-scroll';\n\nexport type StyleEffectorCallback = (record: EnvironmentChangeRecord) => void;\nexport interface EnvironmentChangeRecord {\n  relatedState: EnvironmentState;\n}\n\ntype EnvironmentDependencies = {\n  [key in EnvironmentState]?: AnyObserver\n};\n\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\n\nconst $scrollHandler = Symbol('scrollHandler');\nconst $onScroll = Symbol('onScroll');\n\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nexport class StyleEffector {\n  protected[$dependencies]: EnvironmentDependencies = {};\n\n  protected[$computeStyleCallback]: StyleEffectorCallback;\n  protected[$astWalker] = new ASTWalker<FunctionNode>(['function']);\n\n  protected[$scrollHandler] = () => this[$onScroll]();\n\n  constructor(callback: StyleEffectorCallback) {\n    this[$computeStyleCallback] = callback;\n  }\n\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n  observeEffectsFor(ast: Array<ExpressionNode>) {\n    const newDependencies: EnvironmentDependencies = {};\n    const oldDependencies = this[$dependencies];\n\n    this[$astWalker].walk(ast, functionNode => {\n      const {name} = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n\n      if (name.value !== 'env' || firstTerm == null ||\n          firstTerm.type !== 'ident') {\n        return;\n      }\n\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ?\n                oldDependencies['window-scroll'] :\n                new ScrollObserver(this[$scrollHandler]);\n            observer!.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n          break;\n      }\n    });\n\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n\n    this[$dependencies] = newDependencies;\n  }\n\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer =\n          this[$dependencies][environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n  }\n\n  protected[$onScroll]() {\n    this[$computeStyleCallback]({relatedState: 'window-scroll'});\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}