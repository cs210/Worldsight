{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\nimport { property } from 'lit-element';\nimport { UpdatingElement } from 'lit-element/lib/updating-element';\nimport { HAS_INTERSECTION_OBSERVER, HAS_RESIZE_OBSERVER } from './constants.js';\nimport { makeTemplate } from './template.js';\nimport { $evictionPolicy, CachingGLTFLoader } from './three-components/CachingGLTFLoader.js';\nimport { ModelScene } from './three-components/ModelScene.js';\nimport { Renderer } from './three-components/Renderer.js';\nimport { debounce, deserializeUrl, resolveDpr } from './utilities.js';\nimport { dataUrlToBlob } from './utilities/data-conversion.js';\nimport { ProgressTracker } from './utilities/progress-tracker.js';\nvar CLEAR_MODEL_TIMEOUT_MS = 1000;\nvar FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nvar ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nvar UNSIZED_MEDIA_WIDTH = 300;\nvar UNSIZED_MEDIA_HEIGHT = 150;\nvar blobCanvas = document.createElement('canvas');\nvar blobContext = null;\nvar $selectCanvas = Symbol('selectCanvas');\nvar $updateSize = Symbol('updateSize');\nvar $loaded = Symbol('loaded');\nvar $template = Symbol('template');\nvar $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nvar $defaultAriaLabel = Symbol('defaultAriaLabel');\nvar $resizeObserver = Symbol('resizeObserver');\nvar $intersectionObserver = Symbol('intersectionObserver');\nvar $lastDpr = Symbol('lastDpr');\nvar $clearModelTimeout = Symbol('clearModelTimeout');\nvar $onContextLost = Symbol('onContextLost');\nvar $contextLostHandler = Symbol('contextLostHandler');\nexport var $isElementInViewport = Symbol('isElementInViewport');\nexport var $announceModelVisibility = Symbol('announceModelVisibility');\nexport var $ariaLabel = Symbol('ariaLabel');\nexport var $loadedTime = Symbol('loadedTime');\nexport var $updateSource = Symbol('updateSource');\nexport var $markLoaded = Symbol('markLoaded');\nexport var $container = Symbol('container');\nexport var $userInputElement = Symbol('input');\nexport var $canvas = Symbol('canvas');\nexport var $displayCanvas = Symbol('displayCanvas');\nexport var $scene = Symbol('scene');\nexport var $needsRender = Symbol('needsRender');\nexport var $tick = Symbol('tick');\nexport var $onModelLoad = Symbol('onModelLoad');\nexport var $onResize = Symbol('onResize');\nexport var $renderer = Symbol('renderer');\nexport var $progressTracker = Symbol('progressTracker');\nexport var $getLoaded = Symbol('getLoaded');\nexport var $getModelIsVisible = Symbol('getModelIsVisible');\nexport var toVector3D = function toVector3D(v) {\n  return {\n    x: v.x,\n    y: v.y,\n    z: v.z,\n    toString: function toString() {\n      return \"\".concat(this.x, \"m \").concat(this.y, \"m \").concat(this.z, \"m\");\n    }\n  };\n};\n/**\n * Definition for a basic <model-viewer> element.\n */\n\nvar ModelViewerElementBase = /*#__PURE__*/function (_UpdatingElement) {\n  _inherits(ModelViewerElementBase, _UpdatingElement);\n\n  var _super = _createSuper(ModelViewerElementBase);\n\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  function ModelViewerElementBase() {\n    var _this;\n\n    _classCallCheck(this, ModelViewerElementBase);\n\n    _this = _super.call(this);\n    _this.alt = null;\n    _this.src = null;\n    _this[_a] = false;\n    _this[_b] = false;\n    _this[_c] = 0;\n    _this[_d] = resolveDpr();\n    _this[_e] = null;\n    _this[_f] = debounce(function () {\n      var boundingRect = _this.getBoundingClientRect();\n\n      _this[$updateSize](boundingRect);\n    }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n    _this[_g] = debounce(function (oldVisibility) {\n      var newVisibility = _this.modelIsVisible;\n\n      if (newVisibility !== oldVisibility) {\n        _this.dispatchEvent(new CustomEvent('model-visibility', {\n          detail: {\n            visible: newVisibility\n          }\n        }));\n      }\n    }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n    _this[_h] = null;\n    _this[_j] = null;\n    _this[_k] = new ProgressTracker();\n\n    _this[_l] = function (event) {\n      return _this[$onContextLost](event);\n    }; // NOTE(cdata): It is *very important* to access this template first so that\n    // the ShadyCSS template preparation steps happen before element styling in\n    // IE11:\n\n\n    var template = _this.constructor.template;\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleElement(_assertThisInitialized(_this), {});\n    } // NOTE(cdata): The canonical ShadyCSS examples suggest that the Shadow Root\n    // should be created after the invocation of ShadyCSS.styleElement\n\n\n    _this.attachShadow({\n      mode: 'open'\n    });\n\n    var shadowRoot = _this.shadowRoot;\n    shadowRoot.appendChild(template.content.cloneNode(true));\n    _this[$container] = shadowRoot.querySelector('.container');\n    _this[$userInputElement] = shadowRoot.querySelector('.userInput');\n    _this[$canvas] = shadowRoot.querySelector('canvas');\n    _this[$defaultAriaLabel] = _this[$userInputElement].getAttribute('aria-label'); // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n\n    var width, height;\n\n    if (_this.isConnected) {\n      var rect = _this.getBoundingClientRect();\n\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    } // Create the underlying ModelScene.\n\n\n    _this[$scene] = new ModelScene({\n      canvas: _this[$canvas],\n      element: _assertThisInitialized(_this),\n      width: width,\n      height: height\n    });\n\n    _this[$scene].addEventListener('model-load', function (event) {\n      _this[$markLoaded]();\n\n      _this[$onModelLoad](event);\n\n      _this.dispatchEvent(new CustomEvent('load', {\n        detail: {\n          url: event.url\n        }\n      }));\n    }); // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n\n\n    Promise.resolve().then(function () {\n      _this[$updateSize](_this.getBoundingClientRect(), true);\n    });\n\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      _this[$resizeObserver] = new ResizeObserver(function (entries) {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (_this[$renderer].isPresenting) {\n          return;\n        }\n\n        var _iterator = _createForOfIteratorHelper(entries),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var entry = _step.value;\n\n            if (entry.target === _assertThisInitialized(_this)) {\n              _this[$updateSize](entry.contentRect);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      var enterRenderTreeProgress = _this[$progressTracker].beginActivity();\n\n      _this[$intersectionObserver] = new IntersectionObserver(function (entries) {\n        var _iterator2 = _createForOfIteratorHelper(entries),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var entry = _step2.value;\n\n            if (entry.target === _assertThisInitialized(_this)) {\n              var oldVisibility = _this.modelIsVisible;\n              var oldValue = _this[$isElementInViewport];\n              _this[$isElementInViewport] = _this[$scene].visible = entry.isIntersecting;\n\n              _this.requestUpdate($isElementInViewport, oldValue);\n\n              _this[$announceModelVisibility](oldVisibility);\n\n              if (_this[$isElementInViewport]) {\n                // Wait a microtask to give other properties a chance to respond\n                // to the state change, then resolve progress on entering the\n                // render tree:\n                Promise.resolve().then(function () {\n                  enterRenderTreeProgress(1);\n                });\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }, {\n        root: null,\n        rootMargin: '10px',\n        threshold: 0\n      });\n    } else {\n      // If there is no intersection obsever, then all models should be visible\n      // at all times:\n      _this[$isElementInViewport] = _this[$scene].visible = true;\n\n      _this.requestUpdate($isElementInViewport, false);\n    }\n\n    return _this;\n  }\n\n  _createClass(ModelViewerElementBase, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(ModelViewerElementBase.prototype), \"connectedCallback\", this) && _get(_getPrototypeOf(ModelViewerElementBase.prototype), \"connectedCallback\", this).call(this);\n\n      if (HAS_RESIZE_OBSERVER) {\n        this[$resizeObserver].observe(this);\n      } else {\n        self.addEventListener('resize', this[$fallbackResizeHandler]);\n      }\n\n      if (HAS_INTERSECTION_OBSERVER) {\n        this[$intersectionObserver].observe(this);\n      }\n\n      this[$renderer].addEventListener('contextlost', this[$contextLostHandler]);\n      this[$renderer].registerScene(this[$scene]);\n      this[$selectCanvas]();\n      this[$scene].isDirty = true;\n\n      if (this[$clearModelTimeout] != null) {\n        self.clearTimeout(this[$clearModelTimeout]);\n        this[$clearModelTimeout] = null; // Force an update in case the model has been evicted from our GLTF cache\n        // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate\n\n        this.requestUpdate('src', null);\n      }\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(ModelViewerElementBase.prototype), \"disconnectedCallback\", this) && _get(_getPrototypeOf(ModelViewerElementBase.prototype), \"disconnectedCallback\", this).call(this);\n\n      if (HAS_RESIZE_OBSERVER) {\n        this[$resizeObserver].unobserve(this);\n      } else {\n        self.removeEventListener('resize', this[$fallbackResizeHandler]);\n      }\n\n      if (HAS_INTERSECTION_OBSERVER) {\n        this[$intersectionObserver].unobserve(this);\n      }\n\n      this[$renderer].removeEventListener('contextlost', this[$contextLostHandler]);\n      this[$renderer].unregisterScene(this[$scene]);\n      this[$selectCanvas]();\n      this[$clearModelTimeout] = self.setTimeout(function () {\n        _this2[$scene].model.clear();\n      }, CLEAR_MODEL_TIMEOUT_MS);\n    }\n  }, {\n    key: \"updated\",\n    value: function updated(changedProperties) {\n      _get(_getPrototypeOf(ModelViewerElementBase.prototype), \"updated\", this).call(this, changedProperties); // NOTE(cdata): If a property changes from values A -> B -> A in the space\n      // of a microtask, LitElement/UpdatingElement will notify of a change even\n      // though the value has effectively not changed, so we need to check to make\n      // sure that the value has actually changed before changing the loaded flag.\n\n\n      if (changedProperties.has('src') && (this.src == null || this.src !== this[$scene].model.url)) {\n        this[$loaded] = false;\n        this[$loadedTime] = 0;\n        this[$updateSource]();\n      }\n\n      if (changedProperties.has('alt')) {\n        var ariaLabel = this.alt == null ? this[$defaultAriaLabel] : this.alt;\n        this[$userInputElement].setAttribute('aria-label', ariaLabel);\n      }\n    }\n    /** @export */\n\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL(type, encoderOptions) {\n      return this[$displayCanvas].toDataURL(type, encoderOptions);\n    }\n    /** @export */\n\n  }, {\n    key: \"toBlob\",\n    value: function () {\n      var _toBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n        var _this3 = this;\n\n        var mimeType, qualityArgument, idealAspect, _this$$scene, width, height, model, aspect, dpr, outputWidth, outputHeight, offsetX, offsetY, oldHeight, oldWidth;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                mimeType = options ? options.mimeType : undefined;\n                qualityArgument = options ? options.qualityArgument : undefined;\n                idealAspect = options ? options.idealAspect : undefined;\n                _this$$scene = this[$scene], width = _this$$scene.width, height = _this$$scene.height, model = _this$$scene.model, aspect = _this$$scene.aspect;\n                dpr = resolveDpr();\n                outputWidth = width * dpr;\n                outputHeight = height * dpr;\n                offsetX = 0;\n                offsetY = 0;\n\n                if (idealAspect === true) {\n                  if (model.fieldOfViewAspect > aspect) {\n                    oldHeight = outputHeight;\n                    outputHeight = Math.round(outputWidth / model.fieldOfViewAspect);\n                    offsetY = (oldHeight - outputHeight) / 2;\n                  } else {\n                    oldWidth = outputWidth;\n                    outputWidth = Math.round(outputHeight * model.fieldOfViewAspect);\n                    offsetX = (oldWidth - outputWidth) / 2;\n                  }\n                }\n\n                blobCanvas.width = outputWidth;\n                blobCanvas.height = outputHeight;\n                _context2.prev = 12;\n                return _context2.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (blobContext == null) {\n                              blobContext = blobCanvas.getContext('2d');\n                            }\n\n                            blobContext.drawImage(_this3[$displayCanvas], offsetX, offsetY, outputWidth, outputHeight, 0, 0, outputWidth, outputHeight);\n\n                            if (!blobCanvas.msToBlob) {\n                              _context.next = 5;\n                              break;\n                            }\n\n                            if (!(!mimeType || mimeType === 'image/png')) {\n                              _context.next = 5;\n                              break;\n                            }\n\n                            return _context.abrupt(\"return\", resolve(blobCanvas.msToBlob()));\n\n                          case 5:\n                            if (blobCanvas.toBlob) {\n                              _context.next = 11;\n                              break;\n                            }\n\n                            _context.t0 = resolve;\n                            _context.next = 9;\n                            return dataUrlToBlob(blobCanvas.toDataURL(mimeType, qualityArgument));\n\n                          case 9:\n                            _context.t1 = _context.sent;\n                            return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n\n                          case 11:\n                            blobCanvas.toBlob(function (blob) {\n                              if (!blob) {\n                                return reject(new Error('Unable to retrieve canvas blob'));\n                              }\n\n                              resolve(blob);\n                            }, mimeType, qualityArgument);\n\n                          case 12:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2, _x3) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 14:\n                _context2.prev = 14;\n                this[$updateSize]({\n                  width: width,\n                  height: height\n                });\n                return _context2.finish(14);\n\n              case 17:\n                ;\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[12,, 14, 17]]);\n      }));\n\n      function toBlob(_x) {\n        return _toBlob.apply(this, arguments);\n      }\n\n      return toBlob;\n    }()\n  }, {\n    key: $getLoaded,\n    // NOTE(cdata): Although this may seem extremely redundant, it is required in\n    // order to support overloading when TypeScript is compiled to ES5\n    // @see https://github.com/Polymer/lit-element/pull/745\n    // @see https://github.com/microsoft/TypeScript/issues/338\n    value: function value() {\n      return this[$loaded];\n    } // @see [$getLoaded]\n\n  }, {\n    key: $getModelIsVisible,\n    value: function value() {\n      return this[$isElementInViewport];\n    }\n    /**\n     * The function enables an optimization, where when there is only a single\n     * <model-viewer> element, we can use the renderer's 3D canvas directly for\n     * display. Otherwise we need to use the element's 2D canvas and copy the\n     * renderer's result into it.\n     */\n\n  }, {\n    key: $selectCanvas,\n    value: function value() {\n      if (this[$renderer].hasOnlyOneScene) {\n        this[$userInputElement].appendChild(this[$renderer].canvasElement);\n        this[$canvas].classList.remove('show');\n      } else {\n        this[$renderer].canvasElement.classList.remove('show');\n      }\n    }\n  }, {\n    key: $updateSize,\n\n    /**\n     * Called on initialization and when the resize observer fires.\n     */\n    value: function value(_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height;\n      var forceApply = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var _this$$scene$getSize = this[$scene].getSize(),\n          prevWidth = _this$$scene$getSize.width,\n          prevHeight = _this$$scene$getSize.height; // Round off the pixel size\n\n\n      var intWidth = parseInt(width, 10);\n      var intHeight = parseInt(height, 10);\n      this[$container].style.width = \"\".concat(width, \"px\");\n      this[$container].style.height = \"\".concat(height, \"px\");\n\n      if (forceApply || prevWidth !== intWidth || prevHeight !== intHeight) {\n        this[$onResize]({\n          width: intWidth,\n          height: intHeight\n        });\n      }\n    }\n  }, {\n    key: $tick,\n    value: function value(_time, _delta) {\n      var dpr = resolveDpr(); // There is no standard way to detect when DPR changes on account of zoom.\n      // Here we keep a local copy of DPR updated, and when it changes we invoke\n      // the fallback resize handler. It might be better to invoke the resize\n      // handler directly in this case, but the fallback is debounced which will\n      // save us from doing too much work when DPR and window size changes at the\n      // same time.\n\n      if (dpr !== this[$lastDpr]) {\n        this[$lastDpr] = dpr;\n        this[$fallbackResizeHandler]();\n      }\n    }\n  }, {\n    key: $markLoaded,\n    value: function value() {\n      if (this[$loaded]) {\n        return;\n      }\n\n      this[$loaded] = true;\n      this[$loadedTime] = performance.now(); // Asynchronously invoke `update`:\n\n      this.requestUpdate();\n    }\n  }, {\n    key: $needsRender,\n    value: function value() {\n      this[$scene].isDirty = true;\n    }\n  }, {\n    key: $onModelLoad,\n    value: function value(_event) {\n      this[$needsRender]();\n    }\n  }, {\n    key: $onResize,\n    value: function value(e) {\n      this[$scene].setSize(e.width, e.height);\n      this[$needsRender]();\n    }\n  }, {\n    key: $onContextLost,\n    value: function value(event) {\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: {\n          type: 'webglcontextlost',\n          sourceError: event.sourceEvent\n        }\n      }));\n    }\n    /**\n     * Parses the element for an appropriate source URL and\n     * sets the views to use the new model based off of the `preload`\n     * attribute.\n     */\n\n  }, {\n    key: $updateSource,\n    value: function () {\n      var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var updateSourceProgress, source, canvas;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                updateSourceProgress = this[$progressTracker].beginActivity();\n                source = this.src;\n                canvas = this[$displayCanvas];\n                _context3.prev = 3;\n                canvas.classList.add('show');\n                _context3.next = 7;\n                return this[$scene].setModelSource(source, function (progress) {\n                  return updateSourceProgress(progress * 0.9);\n                });\n\n              case 7:\n                _context3.next = 13;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](3);\n                canvas.classList.remove('show');\n                this.dispatchEvent(new CustomEvent('error', {\n                  detail: _context3.t0\n                }));\n\n              case 13:\n                _context3.prev = 13;\n                updateSourceProgress(1.0);\n                return _context3.finish(13);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 9, 13, 16]]);\n      }));\n\n      function value() {\n        return _value.apply(this, arguments);\n      }\n\n      return value;\n    }()\n  }, {\n    key: \"loaded\",\n\n    /** @export */\n    get: function get() {\n      return this[$getLoaded]();\n    }\n  }, {\n    key: (_a = $isElementInViewport, _b = $loaded, _c = $loadedTime, _d = $lastDpr, _e = $clearModelTimeout, _f = $fallbackResizeHandler, _g = $announceModelVisibility, _h = $resizeObserver, _j = $intersectionObserver, _k = $progressTracker, _l = $contextLostHandler, $renderer),\n    get: function get() {\n      return Renderer.singleton;\n    }\n    /** @export */\n\n  }, {\n    key: \"modelIsVisible\",\n    get: function get() {\n      return this[$getModelIsVisible]();\n    }\n  }, {\n    key: $ariaLabel,\n    get: function get() {\n      return this.alt == null || this.alt === 'null' ? this[$defaultAriaLabel] : this.alt;\n    }\n  }, {\n    key: $displayCanvas,\n    get: function get() {\n      return this[$renderer].hasOnlyOneScene ? this[$renderer].canvasElement : this[$canvas];\n    }\n  }], [{\n    key: \"is\",\n    get: function get() {\n      return 'model-viewer';\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"template\",\n    get: function get() {\n      if (!this.hasOwnProperty($template)) {\n        this[$template] = makeTemplate(this.is);\n      }\n\n      return this[$template];\n    }\n    /** @export */\n\n  }, {\n    key: \"modelCacheSize\",\n    set: function set(value) {\n      CachingGLTFLoader[$evictionPolicy].evictionThreshold = value;\n    }\n    /** @export */\n    ,\n    get: function get() {\n      return CachingGLTFLoader[$evictionPolicy].evictionThreshold;\n    }\n  }]);\n\n  return ModelViewerElementBase;\n}(UpdatingElement);\n\nexport { ModelViewerElementBase as default };\n\n__decorate([property({\n  type: String\n})], ModelViewerElementBase.prototype, \"alt\", void 0);\n\n__decorate([property({\n  converter: {\n    fromAttribute: deserializeUrl\n  }\n})], ModelViewerElementBase.prototype, \"src\", void 0);","map":{"version":3,"sources":["../src/model-viewer-base.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit-element';\nimport {UpdatingElement} from 'lit-element/lib/updating-element';\nimport {Event as ThreeEvent, Vector3} from 'three';\n\nimport {HAS_INTERSECTION_OBSERVER, HAS_RESIZE_OBSERVER} from './constants.js';\nimport {makeTemplate} from './template.js';\nimport {$evictionPolicy, CachingGLTFLoader} from './three-components/CachingGLTFLoader.js';\nimport {ModelScene} from './three-components/ModelScene.js';\nimport {ContextLostEvent, Renderer} from './three-components/Renderer.js';\nimport {debounce, deserializeUrl, resolveDpr} from './utilities.js';\nimport {dataUrlToBlob} from './utilities/data-conversion.js';\nimport {ProgressTracker} from './utilities/progress-tracker.js';\n\nconst CLEAR_MODEL_TIMEOUT_MS = 1000;\nconst FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nconst ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nconst UNSIZED_MEDIA_WIDTH = 300;\nconst UNSIZED_MEDIA_HEIGHT = 150;\n\nconst blobCanvas = document.createElement('canvas');\nlet blobContext: CanvasRenderingContext2D|null = null;\n\nconst $selectCanvas = Symbol('selectCanvas');\nconst $updateSize = Symbol('updateSize');\nconst $loaded = Symbol('loaded');\nconst $template = Symbol('template');\nconst $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nconst $defaultAriaLabel = Symbol('defaultAriaLabel');\nconst $resizeObserver = Symbol('resizeObserver');\nconst $intersectionObserver = Symbol('intersectionObserver');\nconst $lastDpr = Symbol('lastDpr');\nconst $clearModelTimeout = Symbol('clearModelTimeout');\nconst $onContextLost = Symbol('onContextLost');\nconst $contextLostHandler = Symbol('contextLostHandler');\n\nexport const $isElementInViewport = Symbol('isElementInViewport');\nexport const $announceModelVisibility = Symbol('announceModelVisibility');\nexport const $ariaLabel = Symbol('ariaLabel');\nexport const $loadedTime = Symbol('loadedTime');\nexport const $updateSource = Symbol('updateSource');\nexport const $markLoaded = Symbol('markLoaded');\nexport const $container = Symbol('container');\nexport const $userInputElement = Symbol('input');\nexport const $canvas = Symbol('canvas');\nexport const $displayCanvas = Symbol('displayCanvas');\nexport const $scene = Symbol('scene');\nexport const $needsRender = Symbol('needsRender');\nexport const $tick = Symbol('tick');\nexport const $onModelLoad = Symbol('onModelLoad');\nexport const $onResize = Symbol('onResize');\nexport const $renderer = Symbol('renderer');\nexport const $progressTracker = Symbol('progressTracker');\nexport const $getLoaded = Symbol('getLoaded');\nexport const $getModelIsVisible = Symbol('getModelIsVisible');\n\nexport interface Vector3D {\n  x: number\n  y: number\n  z: number\n  toString(): string\n}\n\nexport const toVector3D = (v: Vector3) => {\n  return {\n    x: v.x,\n    y: v.y,\n    z: v.z,\n    toString() {\n      return `${this.x}m ${this.y}m ${this.z}m`;\n    }\n  };\n};\n\ninterface ToBlobOptions {\n  mimeType?: string, qualityArgument?: number, idealAspect?: boolean\n}\n\n/**\n * Definition for a basic <model-viewer> element.\n */\nexport default class ModelViewerElementBase extends UpdatingElement {\n  protected static[$template]: HTMLTemplateElement|void;\n\n  static get is() {\n    return 'model-viewer';\n  }\n\n  /** @nocollapse */\n  static get template() {\n    if (!this.hasOwnProperty($template)) {\n      this[$template] = makeTemplate(this.is);\n    }\n\n    return this[$template];\n  }\n\n  /** @export */\n  static set modelCacheSize(value: number) {\n    CachingGLTFLoader[$evictionPolicy].evictionThreshold = value;\n  }\n\n  /** @export */\n  static get modelCacheSize(): number {\n    return CachingGLTFLoader[$evictionPolicy].evictionThreshold\n  }\n\n  @property({type: String}) alt: string|null = null;\n\n  @property({converter: {fromAttribute: deserializeUrl}})\n  src: string|null = null;\n\n  protected[$isElementInViewport] = false;\n  protected[$loaded] = false;\n  protected[$loadedTime] = 0;\n  protected[$scene]: ModelScene;\n  protected[$container]: HTMLDivElement;\n  protected[$userInputElement]: HTMLDivElement;\n  protected[$canvas]: HTMLCanvasElement;\n  protected[$defaultAriaLabel]: string;\n  protected[$lastDpr]: number = resolveDpr();\n  protected[$clearModelTimeout]: number|null = null;\n\n  protected[$fallbackResizeHandler] = debounce(() => {\n    const boundingRect = this.getBoundingClientRect();\n    this[$updateSize](boundingRect);\n  }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n\n  protected[$announceModelVisibility] = debounce((oldVisibility: boolean) => {\n    const newVisibility = this.modelIsVisible;\n    if (newVisibility !== oldVisibility) {\n      this.dispatchEvent(new CustomEvent(\n          'model-visibility', {detail: {visible: newVisibility}}));\n    }\n  }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n\n  protected[$resizeObserver]: ResizeObserver|null = null;\n  protected[$intersectionObserver]: IntersectionObserver|null = null;\n\n  protected[$progressTracker]: ProgressTracker = new ProgressTracker();\n\n  protected[$contextLostHandler] = (event: ContextLostEvent) =>\n      this[$onContextLost](event);\n\n  /** @export */\n  get loaded() {\n    return this[$getLoaded]();\n  }\n\n  get[$renderer]() {\n    return Renderer.singleton;\n  }\n\n  /** @export */\n  get modelIsVisible() {\n    return this[$getModelIsVisible]();\n  }\n\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  constructor() {\n    super();\n\n    // NOTE(cdata): It is *very important* to access this template first so that\n    // the ShadyCSS template preparation steps happen before element styling in\n    // IE11:\n    const template = (this.constructor as any).template as HTMLTemplateElement;\n\n    if ((window as any).ShadyCSS) {\n      (window as any).ShadyCSS.styleElement(this, {});\n    }\n\n    // NOTE(cdata): The canonical ShadyCSS examples suggest that the Shadow Root\n    // should be created after the invocation of ShadyCSS.styleElement\n    this.attachShadow({mode: 'open'});\n\n    const shadowRoot = this.shadowRoot!;\n\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this[$container] = shadowRoot.querySelector('.container') as HTMLDivElement;\n    this[$userInputElement] =\n        shadowRoot.querySelector('.userInput') as HTMLDivElement;\n    this[$canvas] = shadowRoot.querySelector('canvas') as HTMLCanvasElement;\n    this[$defaultAriaLabel] =\n        this[$userInputElement].getAttribute('aria-label')!;\n\n    // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n    let width, height;\n    if (this.isConnected) {\n      const rect = this.getBoundingClientRect();\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    }\n\n    // Create the underlying ModelScene.\n    this[$scene] =\n        new ModelScene({canvas: this[$canvas], element: this, width, height});\n\n    this[$scene].addEventListener('model-load', (event) => {\n      this[$markLoaded]();\n      this[$onModelLoad](event);\n\n      this.dispatchEvent(\n          new CustomEvent('load', {detail: {url: (event as any).url}}));\n    });\n\n    // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n    Promise.resolve().then(() => {\n      this[$updateSize](this.getBoundingClientRect(), true);\n    });\n\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      this[$resizeObserver] = new ResizeObserver((entries) => {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (this[$renderer].isPresenting) {\n          return;\n        }\n\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$updateSize](entry.contentRect);\n          }\n        }\n      });\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      const enterRenderTreeProgress = this[$progressTracker].beginActivity();\n\n      this[$intersectionObserver] = new IntersectionObserver(entries => {\n        for (let entry of entries) {\n          if (entry.target === this) {\n            const oldVisibility = this.modelIsVisible;\n            const oldValue = this[$isElementInViewport];\n            this[$isElementInViewport] = this[$scene].visible =\n                entry.isIntersecting;\n            this.requestUpdate($isElementInViewport, oldValue);\n            this[$announceModelVisibility](oldVisibility);\n\n            if (this[$isElementInViewport]) {\n              // Wait a microtask to give other properties a chance to respond\n              // to the state change, then resolve progress on entering the\n              // render tree:\n              Promise.resolve().then(() => {\n                enterRenderTreeProgress(1);\n              });\n            }\n          }\n        }\n      }, {\n        root: null,\n        rootMargin: '10px',\n        threshold: 0,\n      });\n    } else {\n      // If there is no intersection obsever, then all models should be visible\n      // at all times:\n      this[$isElementInViewport] = this[$scene].visible = true;\n      this.requestUpdate($isElementInViewport, false);\n    }\n  }\n\n  connectedCallback() {\n    super.connectedCallback && super.connectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver]!.observe(this);\n    } else {\n      self.addEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver]!.observe(this);\n    }\n\n    this[$renderer].addEventListener(\n        'contextlost',\n        this[$contextLostHandler] as (event: ThreeEvent) => void);\n\n    this[$renderer].registerScene(this[$scene]);\n    this[$selectCanvas]();\n    this[$scene].isDirty = true;\n\n    if (this[$clearModelTimeout] != null) {\n      self.clearTimeout(this[$clearModelTimeout]!);\n      this[$clearModelTimeout] = null;\n      // Force an update in case the model has been evicted from our GLTF cache\n      // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate\n      this.requestUpdate('src', null);\n    }\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback && super.disconnectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver]!.unobserve(this);\n    } else {\n      self.removeEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver]!.unobserve(this);\n    }\n\n    this[$renderer].removeEventListener(\n        'contextlost',\n        this[$contextLostHandler] as (event: ThreeEvent) => void);\n\n    this[$renderer].unregisterScene(this[$scene]);\n    this[$selectCanvas]();\n\n    this[$clearModelTimeout] = self.setTimeout(() => {\n      this[$scene].model.clear();\n    }, CLEAR_MODEL_TIMEOUT_MS);\n  }\n\n  updated(changedProperties: Map<string|number|symbol, any>) {\n    super.updated(changedProperties);\n\n    // NOTE(cdata): If a property changes from values A -> B -> A in the space\n    // of a microtask, LitElement/UpdatingElement will notify of a change even\n    // though the value has effectively not changed, so we need to check to make\n    // sure that the value has actually changed before changing the loaded flag.\n    if (changedProperties.has('src') &&\n        (this.src == null || this.src !== this[$scene].model.url)) {\n      this[$loaded] = false;\n      this[$loadedTime] = 0;\n      this[$updateSource]();\n    }\n\n    if (changedProperties.has('alt')) {\n      const ariaLabel = this.alt == null ? this[$defaultAriaLabel] : this.alt;\n      this[$userInputElement].setAttribute('aria-label', ariaLabel);\n    }\n  }\n\n  /** @export */\n  toDataURL(type?: string, encoderOptions?: number): string {\n    return this[$displayCanvas].toDataURL(type, encoderOptions);\n  }\n\n  /** @export */\n  async toBlob(options?: ToBlobOptions): Promise<Blob> {\n    const mimeType = options ? options.mimeType : undefined;\n    const qualityArgument = options ? options.qualityArgument : undefined;\n    const idealAspect = options ? options.idealAspect : undefined;\n\n    const {width, height, model, aspect} = this[$scene];\n    const dpr = resolveDpr();\n    let outputWidth = width * dpr;\n    let outputHeight = height * dpr;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (idealAspect === true) {\n      if (model.fieldOfViewAspect > aspect) {\n        const oldHeight = outputHeight;\n        outputHeight = Math.round(outputWidth / model.fieldOfViewAspect);\n        offsetY = (oldHeight - outputHeight) / 2;\n      } else {\n        const oldWidth = outputWidth;\n        outputWidth = Math.round(outputHeight * model.fieldOfViewAspect);\n        offsetX = (oldWidth - outputWidth) / 2;\n      }\n    }\n    blobCanvas.width = outputWidth;\n    blobCanvas.height = outputHeight;\n    try {\n      return new Promise<Blob>(async (resolve, reject) => {\n        if (blobContext == null) {\n          blobContext = blobCanvas.getContext('2d');\n        }\n        blobContext!.drawImage(\n            this[$displayCanvas],\n            offsetX,\n            offsetY,\n            outputWidth,\n            outputHeight,\n            0,\n            0,\n            outputWidth,\n            outputHeight);\n        if ((blobCanvas as any).msToBlob) {\n          // NOTE: msToBlob only returns image/png\n          // so ensure mimeType is not specified (defaults to image/png)\n          // or is image/png, otherwise fallback to using toDataURL on IE.\n          if (!mimeType || mimeType === 'image/png') {\n            return resolve((blobCanvas as any).msToBlob());\n          }\n        }\n\n        if (!blobCanvas.toBlob) {\n          return resolve(await dataUrlToBlob(\n              blobCanvas.toDataURL(mimeType, qualityArgument)));\n        }\n\n        blobCanvas.toBlob((blob) => {\n          if (!blob) {\n            return reject(new Error('Unable to retrieve canvas blob'));\n          }\n\n          resolve(blob);\n        }, mimeType, qualityArgument);\n      })\n    } finally {\n      this[$updateSize]({width, height});\n    };\n  }\n\n  get[$ariaLabel]() {\n    return (this.alt == null || this.alt === 'null') ? this[$defaultAriaLabel] :\n                                                       this.alt;\n  }\n\n  // NOTE(cdata): Although this may seem extremely redundant, it is required in\n  // order to support overloading when TypeScript is compiled to ES5\n  // @see https://github.com/Polymer/lit-element/pull/745\n  // @see https://github.com/microsoft/TypeScript/issues/338\n  [$getLoaded](): boolean {\n    return this[$loaded];\n  }\n\n  // @see [$getLoaded]\n  [$getModelIsVisible](): boolean {\n    return this[$isElementInViewport];\n  }\n\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  [$selectCanvas]() {\n    if (this[$renderer].hasOnlyOneScene) {\n      this[$userInputElement].appendChild(this[$renderer].canvasElement);\n      this[$canvas].classList.remove('show');\n    } else {\n      this[$renderer].canvasElement.classList.remove('show');\n    }\n  }\n\n  get[$displayCanvas]() {\n    return this[$renderer].hasOnlyOneScene ? this[$renderer].canvasElement :\n                                             this[$canvas];\n  }\n\n  /**\n   * Called on initialization and when the resize observer fires.\n   */\n  [$updateSize](\n      {width, height}: {width: any, height: any}, forceApply = false) {\n    const {width: prevWidth, height: prevHeight} = this[$scene].getSize();\n    // Round off the pixel size\n    const intWidth = parseInt(width, 10);\n    const intHeight = parseInt(height, 10);\n\n    this[$container].style.width = `${width}px`;\n    this[$container].style.height = `${height}px`;\n\n    if (forceApply || (prevWidth !== intWidth || prevHeight !== intHeight)) {\n      this[$onResize]({width: intWidth, height: intHeight});\n    }\n  }\n\n  [$tick](_time: number, _delta: number) {\n    const dpr = resolveDpr();\n    // There is no standard way to detect when DPR changes on account of zoom.\n    // Here we keep a local copy of DPR updated, and when it changes we invoke\n    // the fallback resize handler. It might be better to invoke the resize\n    // handler directly in this case, but the fallback is debounced which will\n    // save us from doing too much work when DPR and window size changes at the\n    // same time.\n    if (dpr !== this[$lastDpr]) {\n      this[$lastDpr] = dpr;\n      this[$fallbackResizeHandler]();\n    }\n  }\n\n  [$markLoaded]() {\n    if (this[$loaded]) {\n      return;\n    }\n\n    this[$loaded] = true;\n    this[$loadedTime] = performance.now();\n    // Asynchronously invoke `update`:\n    this.requestUpdate();\n  }\n\n  [$needsRender]() {\n    this[$scene].isDirty = true;\n  }\n\n  [$onModelLoad](_event: any) {\n    this[$needsRender]();\n  }\n\n  [$onResize](e: {width: number, height: number}) {\n    this[$scene].setSize(e.width, e.height);\n    this[$needsRender]();\n  }\n\n  [$onContextLost](event: ContextLostEvent) {\n    this.dispatchEvent(new CustomEvent(\n        'error',\n        {detail: {type: 'webglcontextlost', sourceError: event.sourceEvent}}));\n  }\n\n  /**\n   * Parses the element for an appropriate source URL and\n   * sets the views to use the new model based off of the `preload`\n   * attribute.\n   */\n  async[$updateSource]() {\n    const updateSourceProgress = this[$progressTracker].beginActivity();\n    const source = this.src;\n\n    const canvas = this[$displayCanvas];\n    try {\n      canvas.classList.add('show');\n      await this[$scene].setModelSource(\n          source, (progress: number) => updateSourceProgress(progress * 0.9));\n    } catch (error) {\n      canvas.classList.remove('show');\n      this.dispatchEvent(new CustomEvent('error', {detail: error}));\n    } finally {\n      updateSourceProgress(1.0);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}