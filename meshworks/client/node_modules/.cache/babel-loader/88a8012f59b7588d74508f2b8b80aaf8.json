{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;\n\nimport { EventDispatcher, Matrix4, PerspectiveCamera, Ray, Vector3 } from 'three';\nimport { $needsRender, $onResize } from '../model-viewer-base.js';\nimport { assertIsArCandidate } from '../utilities.js';\nimport { Damper } from './Damper.js';\nimport { PlacementBox } from './PlacementBox.js';\nimport { assertContext } from './WebGLUtils.js'; // AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\n\nvar AR_SHADOW_INTENSITY = 0.3;\nvar ROTATION_RATE = 1.5; // Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\n\nvar HIT_ANGLE_DEG = 20; // Slow down the dampers for initial placement.\n\nvar INTRO_DAMPER_RATE = 0.4;\nvar SCALE_SNAP_HIGH = 1.2;\nvar SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\nvar $presentedScene = Symbol('presentedScene');\nvar $placementBox = Symbol('placementBox');\nvar $lastTick = Symbol('lastTick');\nvar $turntableRotation = Symbol('turntableRotation');\nvar $oldShadowIntensity = Symbol('oldShadowIntensity');\nvar $oldBackground = Symbol('oldBackground');\nvar $rafId = Symbol('rafId');\nexport var $currentSession = Symbol('currentSession');\nvar $tick = Symbol('tick');\nvar $refSpace = Symbol('refSpace');\nvar $viewerRefSpace = Symbol('viewerRefSpace');\nvar $frame = Symbol('frame');\nvar $initialized = Symbol('initialized');\nvar $initialModelToWorld = Symbol('initialModelToWorld');\nvar $placementComplete = Symbol('placementComplete');\nvar $initialHitSource = Symbol('hitTestSource');\nvar $transientHitTestSource = Symbol('transiertHitTestSource');\nvar $inputSource = Symbol('inputSource');\nvar $isTranslating = Symbol('isTranslating');\nvar $isRotating = Symbol('isRotating');\nvar $isScaling = Symbol('isScaling');\nvar $lastDragPosition = Symbol('lastDragPosition');\nvar $lastScalar = Symbol('lastScalar');\nvar $goalPosition = Symbol('goalPosition');\nvar $goalYaw = Symbol('goalYaw');\nvar $goalScale = Symbol('goalScale');\nvar $xDamper = Symbol('xDamper');\nvar $yDamper = Symbol('yDamper');\nvar $zDamper = Symbol('zDamper');\nvar $yawDamper = Symbol('yawDamper');\nvar $scaleDamper = Symbol('scaleDamper');\nvar $damperRate = Symbol('damperRate');\nvar $resolveCleanup = Symbol('resolveCleanup');\nexport var $onWebXRFrame = Symbol('onWebXRFrame');\nvar $postSessionCleanup = Symbol('postSessionCleanup');\nvar $updateCamera = Symbol('updateCamera');\nvar $placeInitially = Symbol('placeInitially');\nvar $getHitPoint = Symbol('getHitPoint');\nvar $selectStartHandler = Symbol('selectStartHandler');\nvar $onSelectStart = Symbol('onSelectStart');\nvar $selectEndHandler = Symbol('selectHandler');\nvar $onSelectEnd = Symbol('onSelect');\nvar $fingerSeparation = Symbol('fingerSeparation');\nvar $processInput = Symbol('processInput');\nvar $moveScene = Symbol('moveScene');\nvar vector3 = new Vector3();\nvar matrix4 = new Matrix4();\nvar hitPosition = new Vector3();\nexport var ARRenderer = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(ARRenderer, _EventDispatcher);\n\n  var _super = _createSuper(ARRenderer);\n\n  function ARRenderer(renderer) {\n    var _this;\n\n    _classCallCheck(this, ARRenderer);\n\n    _this = _super.call(this);\n    _this.renderer = renderer;\n    _this.camera = new PerspectiveCamera();\n    _this[_a] = null;\n    _this[_b] = null;\n    _this[_c] = null;\n    _this[_d] = null;\n    _this[_e] = null;\n    _this[_f] = null;\n    _this[_g] = null;\n    _this[_h] = null;\n    _this[_j] = null;\n    _this[_k] = null;\n    _this[_l] = null;\n    _this[_m] = null;\n    _this[_o] = null;\n    _this[_p] = null;\n    _this[_q] = null;\n    _this[_r] = false;\n    _this[_s] = new Matrix4();\n    _this[_t] = false;\n    _this[_u] = false;\n    _this[_v] = false;\n    _this[_w] = false;\n    _this[_x] = new Vector3();\n    _this[_y] = 0;\n    _this[_z] = new Vector3();\n    _this[_0] = 0;\n    _this[_1] = 1;\n    _this[_2] = new Damper();\n    _this[_3] = new Damper();\n    _this[_4] = new Damper();\n    _this[_5] = new Damper();\n    _this[_6] = new Damper();\n    _this[_7] = 1;\n\n    _this[_8] = function (event) {\n      return _this[$onSelectStart](event);\n    };\n\n    _this[_9] = function (event) {\n      return _this[$onSelectEnd](event);\n    };\n\n    _this.threeRenderer = renderer.threeRenderer; // Turn this off, as the matrix is set directly from webXR rather than using\n    // postion, rotation, scale.\n\n    _this.camera.matrixAutoUpdate = false;\n    return _this;\n  }\n\n  _createClass(ARRenderer, [{\n    key: \"resolveARSession\",\n    value: function () {\n      var _resolveARSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(scene) {\n        var session, gl, waitForAnimationFrame;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assertIsArCandidate();\n                _context.next = 3;\n                return navigator.xr.requestSession('immersive-ar', {\n                  requiredFeatures: ['hit-test'],\n                  optionalFeatures: ['dom-overlay'],\n                  domOverlay: {\n                    root: document.querySelector('model-viewer').shadowRoot.querySelector('div.annotation-container')\n                  }\n                });\n\n              case 3:\n                session = _context.sent;\n                gl = assertContext(this.renderer.context3D); // `makeXRCompatible` replaced `setCompatibleXRDevice` in Chrome M73 @TODO\n                // #293, handle WebXR API changes. WARNING: this can cause a GL context\n                // loss according to the spec, though current implementations don't do so.\n\n                _context.next = 7;\n                return gl.makeXRCompatible();\n\n              case 7:\n                session.updateRenderState({\n                  baseLayer: new XRWebGLLayer(session, gl, {\n                    alpha: true\n                  })\n                }); // The render state update takes effect on the next animation frame. Wait\n                // for it so that we get a framebuffer.\n\n                waitForAnimationFrame = new Promise(function (resolve, _reject) {\n                  session.requestAnimationFrame(function () {\n                    return resolve();\n                  });\n                });\n                _context.next = 11;\n                return waitForAnimationFrame;\n\n              case 11:\n                // Redirect rendering to the WebXR offscreen framebuffer.\n                // TODO: this method should be added to three.js's exported interface.\n                this.threeRenderer.setFramebuffer(session.renderState.baseLayer.framebuffer);\n                scene.element[$onResize](window.screen);\n                return _context.abrupt(\"return\", session);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function resolveARSession(_x2) {\n        return _resolveARSession.apply(this, arguments);\n      }\n\n      return resolveARSession;\n    }()\n    /**\n     * The currently presented scene, if any\n     */\n\n  }, {\n    key: \"supportsPresentation\",\n\n    /**\n     * Resolves to true if the renderer has detected all the necessary qualities\n     * to support presentation in AR.\n     */\n    value: function () {\n      var _supportsPresentation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                assertIsArCandidate();\n                _context2.next = 4;\n                return navigator.xr.isSessionSupported('immersive-ar');\n\n              case 4:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 7:\n                _context2.prev = 7;\n                _context2.t0 = _context2[\"catch\"](0);\n                return _context2.abrupt(\"return\", false);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 7]]);\n      }));\n\n      function supportsPresentation() {\n        return _supportsPresentation.apply(this, arguments);\n      }\n\n      return supportsPresentation;\n    }()\n    /**\n     * Present a scene in AR\n     */\n\n  }, {\n    key: \"present\",\n    value: function () {\n      var _present = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(scene) {\n        var _this2 = this;\n\n        var currentSession, placementBox, radians, ray;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.isPresenting) {\n                  console.warn('Cannot present while a model is already presenting');\n                }\n\n                _context3.next = 3;\n                return this.resolveARSession(scene);\n\n              case 3:\n                currentSession = _context3.sent;\n                currentSession.addEventListener('end', function () {\n                  _this2[$postSessionCleanup]();\n                }, {\n                  once: true\n                });\n                _context3.next = 7;\n                return currentSession.requestReferenceSpace('local');\n\n              case 7:\n                this[$refSpace] = _context3.sent;\n                _context3.next = 10;\n                return currentSession.requestReferenceSpace('viewer');\n\n              case 10:\n                this[$viewerRefSpace] = _context3.sent;\n                placementBox = new PlacementBox(scene.model);\n                this[$placementComplete] = false;\n                scene.setCamera(this.camera);\n                this[$initialized] = false;\n                this[$damperRate] = INTRO_DAMPER_RATE;\n                this[$turntableRotation] = scene.yaw;\n                scene.yaw = 0;\n                this[$goalYaw] = 0;\n                this[$goalScale] = 1;\n                this[$oldBackground] = scene.background;\n                scene.background = null;\n                this[$oldShadowIntensity] = scene.shadowIntensity;\n                scene.setShadowIntensity(0);\n                radians = HIT_ANGLE_DEG * Math.PI / 180;\n                ray = new XRRay(new DOMPoint(0, 0, 0), new DOMPoint(0, -Math.sin(radians), -Math.cos(radians)));\n                currentSession.requestHitTestSource({\n                  space: this[$viewerRefSpace],\n                  offsetRay: ray\n                }).then(function (hitTestSource) {\n                  _this2[$initialHitSource] = hitTestSource;\n                });\n                this[$currentSession] = currentSession;\n                this[$presentedScene] = scene;\n                this[$placementBox] = placementBox;\n                this[$lastTick] = performance.now(); // Start the event loop.\n\n                this[$tick]();\n\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function present(_x3) {\n        return _present.apply(this, arguments);\n      }\n\n      return present;\n    }()\n    /**\n     * If currently presenting a scene in AR, stops presentation and exits AR.\n     */\n\n  }, {\n    key: \"stopPresenting\",\n    value: function () {\n      var _stopPresenting = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this3 = this;\n\n        var cleanupPromise, session;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.isPresenting) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                cleanupPromise = new Promise(function (resolve) {\n                  _this3[$resolveCleanup] = resolve;\n                });\n                _context4.prev = 3;\n                session = this[$currentSession];\n                session.removeEventListener('selectstart', this[$selectStartHandler]);\n                session.removeEventListener('selectend', this[$selectEndHandler]);\n                this[$currentSession] = null;\n                session.cancelAnimationFrame(this[$rafId]);\n                _context4.next = 11;\n                return session.end();\n\n              case 11:\n                _context4.next = 13;\n                return cleanupPromise;\n\n              case 13:\n                _context4.next = 20;\n                break;\n\n              case 15:\n                _context4.prev = 15;\n                _context4.t0 = _context4[\"catch\"](3);\n                console.warn('Error while trying to end AR session');\n                console.warn(_context4.t0);\n                this[$postSessionCleanup]();\n\n              case 20:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 15]]);\n      }));\n\n      function stopPresenting() {\n        return _stopPresenting.apply(this, arguments);\n      }\n\n      return stopPresenting;\n    }()\n  }, {\n    key: (_a = $placementBox, _b = $lastTick, _c = $turntableRotation, _d = $oldShadowIntensity, _e = $oldBackground, _f = $rafId, _g = $currentSession, _h = $refSpace, _j = $viewerRefSpace, _k = $frame, _l = $initialHitSource, _m = $transientHitTestSource, _o = $inputSource, _p = $presentedScene, _q = $resolveCleanup, _r = $initialized, _s = $initialModelToWorld, _t = $placementComplete, _u = $isTranslating, _v = $isRotating, _w = $isScaling, _x = $lastDragPosition, _y = $lastScalar, _z = $goalPosition, _0 = $goalYaw, _1 = $goalScale, _2 = $xDamper, _3 = $yDamper, _4 = $zDamper, _5 = $yawDamper, _6 = $scaleDamper, _7 = $damperRate, _8 = $selectStartHandler, _9 = $selectEndHandler, $postSessionCleanup),\n    value: function value() {\n      // The offscreen WebXR framebuffer is now invalid, switch\n      // back to the default framebuffer for canvas output.\n      // TODO: this method should be added to three.js's exported interface.\n      this.threeRenderer.setFramebuffer(null);\n      var scene = this[$presentedScene];\n\n      if (scene != null) {\n        var model = scene.model,\n            element = scene.element;\n        scene.setCamera(scene.camera);\n        model.remove(this[$placementBox]);\n        scene.position.set(0, 0, 0);\n        scene.scale.set(1, 1, 1);\n        model.setShadowScaleAndOffset(1, 0);\n        scene.yaw = this[$turntableRotation];\n        scene.setShadowIntensity(this[$oldShadowIntensity]);\n        scene.background = this[$oldBackground];\n        model.orientHotspots(0);\n        element.requestUpdate('cameraTarget');\n        element[$needsRender]();\n        this.renderer.expandTo(scene.width, scene.height);\n      }\n\n      if (this[$placementBox] != null) {\n        this[$placementBox].dispose();\n        this[$placementBox] = null;\n      }\n\n      this[$refSpace] = null;\n      this[$presentedScene] = null;\n\n      if (this[$resolveCleanup] != null) {\n        this[$resolveCleanup]();\n      }\n    }\n    /**\n     * True if a scene is currently in the process of being presented in AR\n     */\n\n  }, {\n    key: $updateCamera,\n    value: function value(view) {\n      var camera = this.camera;\n      var cameraMatrix = camera.matrix;\n      cameraMatrix.fromArray(view.transform.matrix);\n      camera.updateMatrixWorld(true); // position is not updated when matrix is updated.\n\n      camera.position.setFromMatrixPosition(cameraMatrix);\n\n      if (this[$initialHitSource] != null) {\n        // Target locked to screen center\n        var _this$$presentedScene = this[$presentedScene],\n            position = _this$$presentedScene.position,\n            model = _this$$presentedScene.model;\n        var radius = model.idealCameraDistance;\n        camera.getWorldDirection(position);\n        position.multiplyScalar(radius);\n        position.add(camera.position);\n      }\n\n      if (!this[$initialized]) {\n        camera.projectionMatrix.fromArray(view.projectionMatrix); // Have to set the inverse manually when setting matrix directly. This is\n        // needed for raycasting.\n\n        camera.projectionMatrixInverse.getInverse(camera.projectionMatrix); // Orient model toward camera on first frame.\n\n        var _camera$position = camera.position,\n            x = _camera$position.x,\n            z = _camera$position.z;\n        var scene = this[$presentedScene];\n        scene.pointTowards(x, z);\n        scene.model.updateMatrixWorld(true);\n        this[$goalYaw] = scene.yaw;\n        this[$initialModelToWorld].copy(scene.model.matrixWorld);\n        this[$initialized] = true;\n      }\n\n      this[$presentedScene].model.orientHotspots(Math.atan2(cameraMatrix.elements[1], cameraMatrix.elements[5]));\n    }\n  }, {\n    key: $placeInitially,\n    value: function value(frame) {\n      var _this4 = this;\n\n      var hitSource = this[$initialHitSource];\n\n      if (hitSource == null) {\n        return;\n      }\n\n      var hitTestResults = frame.getHitTestResults(hitSource);\n\n      if (hitTestResults.length == 0) {\n        return;\n      }\n\n      var hit = hitTestResults[0];\n      var hitMatrix = this[$getHitPoint](hit);\n\n      if (hitMatrix == null) {\n        return;\n      }\n\n      this.placeModel(hitMatrix);\n      hitSource.cancel();\n      this[$initialHitSource] = null;\n      var session = frame.session;\n      session.addEventListener('selectstart', this[$selectStartHandler]);\n      session.addEventListener('selectend', this[$selectEndHandler]);\n      session.requestHitTestSourceForTransientInput({\n        profile: 'generic-touchscreen'\n      }).then(function (hitTestSource) {\n        _this4[$transientHitTestSource] = hitTestSource;\n      });\n    }\n  }, {\n    key: $getHitPoint,\n    value: function value(hitResult) {\n      var pose = hitResult.getPose(this[$refSpace]);\n\n      if (pose == null) {\n        return null;\n      }\n\n      var hitMatrix = matrix4.fromArray(pose.transform.matrix); // Check that the y-coordinate of the normal is large enough that the normal\n      // is pointing up.\n\n      return hitMatrix.elements[5] > 0.75 ? hitPosition.setFromMatrixPosition(hitMatrix) : null;\n    }\n    /**\n     * This sets the initial model placement based on the input hit point. The\n     * bottom of the model will be placed on the floor (the shadow will rest on\n     * the input's y-coordinate). The XZ placement is found by first putting the\n     * scene's target at the hit point, drawing a ray from the camera to the\n     * target, and finding the XZ-intersection of this ray with the model's\n     * bounding box. The scene is then translated on the XZ plane to position this\n     * intersection point at the input hit point. If the ray does not intersect,\n     * the target is left at the hit point.\n     *\n     * This ensures the model is placed according to the chosen target, is not\n     * reoriented, and does not intersect the camera even when the model\n     * is large (unless the target is chosen outside of the model's bounding box).\n     */\n\n  }, {\n    key: \"placeModel\",\n    value: function placeModel(hit) {\n      var scene = this[$presentedScene];\n      var model = scene.model;\n      var _model$boundingBox = model.boundingBox,\n          min = _model$boundingBox.min,\n          max = _model$boundingBox.max;\n      this[$placementBox].show = true;\n      var goal = this[$goalPosition];\n      goal.copy(hit);\n      var floor = hit.y;\n      var origin = this.camera.position.clone();\n      var direction = hit.clone().sub(origin).normalize(); // Pull camera back enough to be outside of large models.\n\n      origin.sub(direction.multiplyScalar(model.idealCameraDistance));\n      var ray = new Ray(origin, direction.normalize());\n      var modelToWorld = this[$initialModelToWorld];\n      var modelPosition = new Vector3().setFromMatrixPosition(modelToWorld).add(hit);\n      modelToWorld.setPosition(modelPosition);\n      var world2Model = new Matrix4().getInverse(modelToWorld);\n      ray.applyMatrix4(world2Model); // Make the box tall so that we don't intersect the top face.\n\n      max.y += 10;\n      ray.intersectBox(model.boundingBox, modelPosition);\n      max.y -= 10;\n\n      if (modelPosition != null) {\n        modelPosition.applyMatrix4(modelToWorld);\n        goal.add(hit).sub(modelPosition);\n      } // Move the scene's target to the model's floor height.\n\n\n      var target = scene.getTarget();\n      scene.setTarget(target.x, min.y, target.z); // Ignore the y-coordinate and set on the floor instead.\n\n      goal.y = floor;\n      this.dispatchEvent({\n        type: 'modelmove'\n      });\n    }\n  }, {\n    key: $onSelectStart,\n    value: function value(event) {\n      var hitSource = this[$transientHitTestSource];\n\n      if (hitSource == null) {\n        return;\n      }\n\n      var fingers = this[$frame].getHitTestResultsForTransientInput(hitSource);\n      var scene = this[$presentedScene];\n      var box = this[$placementBox];\n\n      if (fingers.length === 1) {\n        this[$inputSource] = event.inputSource;\n        var axes = event.inputSource.gamepad.axes;\n\n        var _hitPosition = box.getHit(this[$presentedScene], axes[0], axes[1]);\n\n        box.show = true;\n\n        if (_hitPosition != null) {\n          this[$isTranslating] = true;\n          this[$lastDragPosition].copy(_hitPosition);\n        } else {\n          this[$isRotating] = true;\n          this[$lastScalar] = axes[0];\n        }\n      } else if (fingers.length === 2 && scene.canScale) {\n        box.show = true;\n        this[$isScaling] = true;\n        this[$lastScalar] = this[$fingerSeparation](fingers) / scene.scale.x;\n      }\n    }\n  }, {\n    key: $onSelectEnd,\n    value: function value(_event) {\n      this[$isTranslating] = false;\n      this[$isRotating] = false;\n      this[$isScaling] = false;\n      this[$inputSource] = null;\n      this[$goalPosition].y += this[$placementBox].offsetHeight * this[$presentedScene].scale.x;\n      this[$placementBox].show = false;\n    }\n  }, {\n    key: $fingerSeparation,\n    value: function value(fingers) {\n      var fingerOne = fingers[0].inputSource.gamepad.axes;\n      var fingerTwo = fingers[1].inputSource.gamepad.axes;\n      var deltaX = fingerTwo[0] - fingerOne[0];\n      var deltaY = fingerTwo[1] - fingerOne[1];\n      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    }\n  }, {\n    key: $processInput,\n    value: function value(frame) {\n      var _this5 = this;\n\n      var hitSource = this[$transientHitTestSource];\n\n      if (hitSource == null) {\n        return;\n      }\n\n      if (!this[$isTranslating] && !this[$isScaling] && !this[$isRotating]) {\n        return;\n      }\n\n      var fingers = frame.getHitTestResultsForTransientInput(hitSource);\n      var scene = this[$presentedScene];\n      var scale = scene.scale.x; // Rotating, translating and scaling are mutually exclusive operations; only\n      // one can happen at a time, but we can switch during a gesture.\n\n      if (this[$isScaling]) {\n        if (fingers.length < 2) {\n          // If we lose the second finger, stop scaling (in fact, stop processing\n          // input altogether until a new gesture starts).\n          this[$isScaling] = false;\n        } else {\n          var separation = this[$fingerSeparation](fingers);\n\n          var _scale = separation / this[$lastScalar];\n\n          this[$goalScale] = _scale < SCALE_SNAP_HIGH && _scale > SCALE_SNAP_LOW ? 1 : _scale;\n        }\n\n        return;\n      } else if (fingers.length === 2 && scene.canScale) {\n        // If we were rotating or translating and we get a second finger, switch\n        // to scaling instead.\n        this[$isTranslating] = false;\n        this[$isRotating] = false;\n        this[$isScaling] = true;\n        this[$lastScalar] = this[$fingerSeparation](fingers) / scale;\n        return;\n      }\n\n      if (this[$isRotating]) {\n        var thisDragX = this[$inputSource].gamepad.axes[0];\n        this[$goalYaw] += (thisDragX - this[$lastScalar]) * ROTATION_RATE;\n        this[$lastScalar] = thisDragX;\n      } else if (this[$isTranslating]) {\n        fingers.forEach(function (finger) {\n          if (finger.inputSource !== _this5[$inputSource] || finger.results.length < 1) {\n            return;\n          }\n\n          var hit = _this5[$getHitPoint](finger.results[0]);\n\n          if (hit == null) {\n            return;\n          }\n\n          _this5[$goalPosition].sub(_this5[$lastDragPosition]);\n\n          var offset = hit.y - _this5[$lastDragPosition].y; // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n\n          if (offset < 0) {\n            _this5[$placementBox].offsetHeight = offset / scale;\n\n            _this5[$presentedScene].model.setShadowScaleAndOffset(scale, offset); // Interpolate hit ray up to drag plane\n\n\n            var cameraPosition = vector3.copy(_this5.camera.position);\n            var alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n\n          _this5[$goalPosition].add(hit);\n\n          _this5[$lastDragPosition].copy(hit);\n        });\n      }\n    }\n  }, {\n    key: $moveScene,\n    value: function value(delta) {\n      var scene = this[$presentedScene];\n      var model = scene.model,\n          position = scene.position,\n          yaw = scene.yaw;\n      var radius = model.idealCameraDistance;\n      var goal = this[$goalPosition];\n      var oldScale = scene.scale.x;\n      var box = this[$placementBox];\n\n      if (this[$initialHitSource] == null && (!goal.equals(position) || this[$goalScale] !== oldScale)) {\n        var x = position.x,\n            y = position.y,\n            z = position.z;\n        delta *= this[$damperRate];\n        x = this[$xDamper].update(x, goal.x, delta, radius);\n        y = this[$yDamper].update(y, goal.y, delta, radius);\n        z = this[$zDamper].update(z, goal.z, delta, radius);\n        position.set(x, y, z);\n        var newScale = this[$scaleDamper].update(oldScale, this[$goalScale], delta, 1);\n        scene.scale.set(newScale, newScale, newScale);\n\n        if (!this[$isTranslating]) {\n          var offset = goal.y - y;\n\n          if (this[$placementComplete]) {\n            box.offsetHeight = offset / newScale;\n            model.setShadowScaleAndOffset(newScale, offset);\n          } else if (offset === 0) {\n            this[$placementComplete] = true;\n            box.show = false;\n            scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n            this[$damperRate] = 1;\n          }\n        }\n      }\n\n      box.updateOpacity(delta);\n      scene.updateTarget(delta); // This updates the model's position, which the shadow is based on.\n\n      scene.updateMatrixWorld(true); // yaw must be updated last, since this also updates the shadow position.\n\n      scene.yaw = this[$yawDamper].update(yaw, this[$goalYaw], delta, Math.PI);\n    }\n  }, {\n    key: $tick,\n    value: function value() {\n      var _this6 = this;\n\n      this[$rafId] = this[$currentSession].requestAnimationFrame(function (time, frame) {\n        return _this6[$onWebXRFrame](time, frame);\n      });\n    }\n  }, {\n    key: $onWebXRFrame,\n    value: function value(time, frame) {\n      this[$frame] = frame;\n      var pose = frame.getViewerPose(this[$refSpace]); // TODO: Notify external observers of tick\n\n      this[$tick]();\n      var scene = this[$presentedScene];\n\n      if (pose == null || scene == null) {\n        return;\n      }\n\n      this[$updateCamera](pose.views[0]);\n      this[$placeInitially](frame);\n      this[$processInput](frame);\n      var delta = time - this[$lastTick];\n      this[$moveScene](delta);\n      this.renderer.preRender(scene, time, delta);\n      this[$lastTick] = time; // NOTE: Clearing depth caused issues on Samsung devices\n      // @see https://github.com/googlecodelabs/ar-with-webxr/issues/8\n      // this.threeRenderer.clearDepth();\n\n      this.threeRenderer.render(scene, this.camera);\n    }\n  }, {\n    key: \"presentedScene\",\n    get: function get() {\n      return this[$presentedScene];\n    }\n  }, {\n    key: \"isPresenting\",\n    get: function get() {\n      return this[$presentedScene] != null;\n    }\n  }]);\n\n  return ARRenderer;\n}(EventDispatcher);","map":{"version":3,"sources":["../../src/three-components/ARRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {EventDispatcher, Matrix4, PerspectiveCamera, Ray, Vector3, WebGLRenderer} from 'three';\n\nimport {$needsRender, $onResize} from '../model-viewer-base.js';\nimport {assertIsArCandidate} from '../utilities.js';\n\nimport {Damper} from './Damper.js';\nimport {ModelScene} from './ModelScene.js';\nimport {PlacementBox} from './PlacementBox.js';\nimport {Renderer} from './Renderer.js';\nimport {assertContext} from './WebGLUtils.js';\n\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.3;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\n// Slow down the dampers for initial placement.\nconst INTRO_DAMPER_RATE = 0.4;\nconst SCALE_SNAP_HIGH = 1.2;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\n\nconst $presentedScene = Symbol('presentedScene');\nconst $placementBox = Symbol('placementBox');\nconst $lastTick = Symbol('lastTick');\nconst $turntableRotation = Symbol('turntableRotation');\nconst $oldShadowIntensity = Symbol('oldShadowIntensity');\nconst $oldBackground = Symbol('oldBackground');\nconst $rafId = Symbol('rafId');\nexport const $currentSession = Symbol('currentSession');\nconst $tick = Symbol('tick');\nconst $refSpace = Symbol('refSpace');\nconst $viewerRefSpace = Symbol('viewerRefSpace');\nconst $frame = Symbol('frame');\nconst $initialized = Symbol('initialized');\nconst $initialModelToWorld = Symbol('initialModelToWorld');\nconst $placementComplete = Symbol('placementComplete');\nconst $initialHitSource = Symbol('hitTestSource');\nconst $transientHitTestSource = Symbol('transiertHitTestSource');\nconst $inputSource = Symbol('inputSource');\nconst $isTranslating = Symbol('isTranslating');\nconst $isRotating = Symbol('isRotating');\nconst $isScaling = Symbol('isScaling');\nconst $lastDragPosition = Symbol('lastDragPosition');\nconst $lastScalar = Symbol('lastScalar');\nconst $goalPosition = Symbol('goalPosition');\nconst $goalYaw = Symbol('goalYaw');\nconst $goalScale = Symbol('goalScale');\nconst $xDamper = Symbol('xDamper');\nconst $yDamper = Symbol('yDamper');\nconst $zDamper = Symbol('zDamper');\nconst $yawDamper = Symbol('yawDamper');\nconst $scaleDamper = Symbol('scaleDamper');\nconst $damperRate = Symbol('damperRate');\nconst $resolveCleanup = Symbol('resolveCleanup');\n\nexport const $onWebXRFrame = Symbol('onWebXRFrame');\nconst $postSessionCleanup = Symbol('postSessionCleanup');\nconst $updateCamera = Symbol('updateCamera');\nconst $placeInitially = Symbol('placeInitially');\nconst $getHitPoint = Symbol('getHitPoint');\nconst $selectStartHandler = Symbol('selectStartHandler');\nconst $onSelectStart = Symbol('onSelectStart');\nconst $selectEndHandler = Symbol('selectHandler');\nconst $onSelectEnd = Symbol('onSelect');\nconst $fingerSeparation = Symbol('fingerSeparation');\nconst $processInput = Symbol('processInput');\nconst $moveScene = Symbol('moveScene');\n\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\n\nexport class ARRenderer extends EventDispatcher {\n  public threeRenderer: WebGLRenderer;\n\n  public camera: PerspectiveCamera = new PerspectiveCamera();\n\n  private[$placementBox]: PlacementBox|null = null;\n  private[$lastTick]: number|null = null;\n  private[$turntableRotation]: number|null = null;\n  private[$oldShadowIntensity]: number|null = null;\n  private[$oldBackground]: any = null;\n  private[$rafId]: number|null = null;\n  protected[$currentSession]: XRSession|null = null;\n  private[$refSpace]: XRReferenceSpace|null = null;\n  private[$viewerRefSpace]: XRReferenceSpace|null = null;\n  private[$frame]: XRFrame|null = null;\n  private[$initialHitSource]: XRHitTestSource|null = null;\n  private[$transientHitTestSource]: XRTransientInputHitTestSource|null = null;\n  private[$inputSource]: XRInputSource|null = null;\n  private[$presentedScene]: ModelScene|null = null;\n  private[$resolveCleanup]: ((...args: any[]) => void)|null = null;\n\n  private[$initialized] = false;\n  private[$initialModelToWorld] = new Matrix4();\n  private[$placementComplete] = false;\n  private[$isTranslating] = false;\n  private[$isRotating] = false;\n  private[$isScaling] = false;\n  private[$lastDragPosition] = new Vector3();\n  private[$lastScalar] = 0;\n  private[$goalPosition] = new Vector3();\n  private[$goalYaw] = 0;\n  private[$goalScale] = 1;\n  private[$xDamper] = new Damper();\n  private[$yDamper] = new Damper();\n  private[$zDamper] = new Damper();\n  private[$yawDamper] = new Damper();\n  private[$scaleDamper] = new Damper();\n  private[$damperRate] = 1;\n\n  private[$selectStartHandler] = (event: Event) =>\n      this[$onSelectStart](event as XRInputSourceEvent);\n  private[$selectEndHandler] = (event: Event) =>\n      this[$onSelectEnd](event as XRInputSourceEvent);\n\n  constructor(private renderer: Renderer) {\n    super();\n    this.threeRenderer = renderer.threeRenderer;\n    // Turn this off, as the matrix is set directly from webXR rather than using\n    // postion, rotation, scale.\n    this.camera.matrixAutoUpdate = false;\n  }\n\n  async resolveARSession(scene: ModelScene): Promise<XRSession> {\n    assertIsArCandidate();\n\n    const session: XRSession =\n        await navigator.xr!.requestSession!('immersive-ar', {\n          requiredFeatures: ['hit-test'],\n          optionalFeatures: ['dom-overlay'],\n          domOverlay: {\n            root: document.querySelector('model-viewer')!.shadowRoot!\n                      .querySelector('div.annotation-container')\n          }\n        });\n\n    const gl = assertContext(this.renderer.context3D);\n    // `makeXRCompatible` replaced `setCompatibleXRDevice` in Chrome M73 @TODO\n    // #293, handle WebXR API changes. WARNING: this can cause a GL context\n    // loss according to the spec, though current implementations don't do so.\n    await gl.makeXRCompatible();\n\n    session.updateRenderState(\n        {baseLayer: new XRWebGLLayer(session, gl, {alpha: true})});\n\n    // The render state update takes effect on the next animation frame. Wait\n    // for it so that we get a framebuffer.\n    let waitForAnimationFrame = new Promise((resolve, _reject) => {\n      session.requestAnimationFrame(() => resolve());\n    });\n    await waitForAnimationFrame;\n\n    // Redirect rendering to the WebXR offscreen framebuffer.\n    // TODO: this method should be added to three.js's exported interface.\n    (this.threeRenderer as any)\n        .setFramebuffer(session.renderState.baseLayer!.framebuffer);\n    (scene.element)[$onResize](window.screen);\n\n    return session;\n  }\n\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this[$presentedScene];\n  }\n\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr!.isSessionSupported('immersive-ar');\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Present a scene in AR\n   */\n  async present(scene: ModelScene): Promise<void> {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n\n    const currentSession = await this.resolveARSession(scene);\n    currentSession.addEventListener('end', () => {\n      this[$postSessionCleanup]();\n    }, {once: true});\n\n    this[$refSpace] = await currentSession.requestReferenceSpace('local');\n    this[$viewerRefSpace] =\n        await currentSession.requestReferenceSpace('viewer');\n\n    const placementBox = new PlacementBox(scene.model);\n    this[$placementComplete] = false;\n\n    scene.setCamera(this.camera);\n    this[$initialized] = false;\n    this[$damperRate] = INTRO_DAMPER_RATE;\n\n    this[$turntableRotation] = scene.yaw;\n    scene.yaw = 0;\n    this[$goalYaw] = 0;\n    this[$goalScale] = 1;\n\n    this[$oldBackground] = scene.background;\n    scene.background = null;\n\n    this[$oldShadowIntensity] = scene.shadowIntensity;\n    scene.setShadowIntensity(0);\n\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = new XRRay(\n        new DOMPoint(0, 0, 0),\n        new DOMPoint(0, -Math.sin(radians), -Math.cos(radians)));\n    currentSession\n        .requestHitTestSource({space: this[$viewerRefSpace]!, offsetRay: ray})\n        .then(hitTestSource => {\n          this[$initialHitSource] = hitTestSource;\n        });\n\n    this[$currentSession] = currentSession;\n    this[$presentedScene] = scene;\n    this[$placementBox] = placementBox;\n    this[$lastTick] = performance.now();\n\n    // Start the event loop.\n    this[$tick]();\n  }\n\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n\n    const cleanupPromise = new Promise((resolve) => {\n      this[$resolveCleanup] = resolve;\n    });\n\n    try {\n      const session = this[$currentSession]!;\n      session.removeEventListener('selectstart', this[$selectStartHandler]);\n      session.removeEventListener('selectend', this[$selectEndHandler]);\n\n      this[$currentSession] = null;\n      session.cancelAnimationFrame(this[$rafId]!);\n\n      await session.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end AR session');\n      console.warn(error);\n\n      this[$postSessionCleanup]();\n    }\n  }\n\n  [$postSessionCleanup]() {\n    // The offscreen WebXR framebuffer is now invalid, switch\n    // back to the default framebuffer for canvas output.\n    // TODO: this method should be added to three.js's exported interface.\n    (this.threeRenderer as any).setFramebuffer(null);\n\n    const scene = this[$presentedScene];\n    if (scene != null) {\n      const {model, element} = scene;\n      scene.setCamera(scene.camera);\n      model.remove(this[$placementBox]!);\n\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      model.setShadowScaleAndOffset(1, 0);\n      scene.yaw = this[$turntableRotation]!;\n      scene.setShadowIntensity(this[$oldShadowIntensity]!);\n      scene.background = this[$oldBackground];\n      model.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element[$needsRender]();\n\n      this.renderer.expandTo(scene.width, scene.height);\n    }\n\n    if (this[$placementBox] != null) {\n      this[$placementBox]!.dispose();\n      this[$placementBox] = null;\n    }\n\n    this[$refSpace] = null;\n    this[$presentedScene] = null;\n\n    if (this[$resolveCleanup] != null) {\n      this[$resolveCleanup]!();\n    }\n  }\n\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting(): boolean {\n    return this[$presentedScene] != null;\n  }\n\n  [$updateCamera](view: XRView) {\n    const {camera} = this;\n    const {matrix: cameraMatrix} = camera;\n\n    cameraMatrix.fromArray(view.transform.matrix);\n    camera.updateMatrixWorld(true);\n    // position is not updated when matrix is updated.\n    camera.position.setFromMatrixPosition(cameraMatrix);\n\n    if (this[$initialHitSource] != null) {\n      // Target locked to screen center\n      const {position, model} = this[$presentedScene]!;\n      const radius = model.idealCameraDistance;\n      camera.getWorldDirection(position);\n      position.multiplyScalar(radius);\n      position.add(camera.position);\n    }\n\n    if (!this[$initialized]) {\n      camera.projectionMatrix.fromArray(view.projectionMatrix);\n      // Have to set the inverse manually when setting matrix directly. This is\n      // needed for raycasting.\n      camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n      // Orient model toward camera on first frame.\n      const {x, z} = camera.position;\n      const scene = this[$presentedScene]!;\n      scene.pointTowards(x, z);\n      scene.model.updateMatrixWorld(true);\n      this[$goalYaw] = scene.yaw;\n      this[$initialModelToWorld].copy(scene.model.matrixWorld);\n      this[$initialized] = true;\n    }\n\n    this[$presentedScene]!.model.orientHotspots(\n        Math.atan2(cameraMatrix.elements[1], cameraMatrix.elements[5]));\n  }\n\n  [$placeInitially](frame: XRFrame) {\n    const hitSource = this[$initialHitSource];\n    if (hitSource == null) {\n      return;\n    }\n\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n\n    const hit = hitTestResults[0];\n    const hitMatrix = this[$getHitPoint](hit);\n    if (hitMatrix == null) {\n      return;\n    }\n\n    this.placeModel(hitMatrix);\n\n    hitSource.cancel();\n    this[$initialHitSource] = null;\n\n    const {session} = frame;\n    session.addEventListener('selectstart', this[$selectStartHandler]);\n    session.addEventListener('selectend', this[$selectEndHandler]);\n    session\n        .requestHitTestSourceForTransientInput({profile: 'generic-touchscreen'})\n        .then(hitTestSource => {\n          this[$transientHitTestSource] = hitTestSource;\n        });\n  }\n\n  [$getHitPoint](hitResult: XRHitTestResult): Vector3|null {\n    const pose = hitResult.getPose(this[$refSpace]!);\n    if (pose == null) {\n      return null;\n    }\n\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up.\n    return hitMatrix.elements[5] > 0.75 ?\n        hitPosition.setFromMatrixPosition(hitMatrix) :\n        null;\n  }\n\n  /**\n   * This sets the initial model placement based on the input hit point. The\n   * bottom of the model will be placed on the floor (the shadow will rest on\n   * the input's y-coordinate). The XZ placement is found by first putting the\n   * scene's target at the hit point, drawing a ray from the camera to the\n   * target, and finding the XZ-intersection of this ray with the model's\n   * bounding box. The scene is then translated on the XZ plane to position this\n   * intersection point at the input hit point. If the ray does not intersect,\n   * the target is left at the hit point.\n   *\n   * This ensures the model is placed according to the chosen target, is not\n   * reoriented, and does not intersect the camera even when the model\n   * is large (unless the target is chosen outside of the model's bounding box).\n   */\n  placeModel(hit: Vector3) {\n    const scene = this[$presentedScene]!;\n    const {model} = scene;\n    const {min, max} = model.boundingBox;\n\n    this[$placementBox]!.show = true;\n\n    const goal = this[$goalPosition];\n    goal.copy(hit);\n    const floor = hit.y;\n\n    const origin = this.camera.position.clone();\n    const direction = hit.clone().sub(origin).normalize();\n    // Pull camera back enough to be outside of large models.\n    origin.sub(direction.multiplyScalar(model.idealCameraDistance));\n    const ray = new Ray(origin, direction.normalize());\n\n    const modelToWorld = this[$initialModelToWorld];\n    const modelPosition =\n        new Vector3().setFromMatrixPosition(modelToWorld).add(hit);\n    modelToWorld.setPosition(modelPosition);\n    const world2Model = new Matrix4().getInverse(modelToWorld);\n    ray.applyMatrix4(world2Model);\n\n    // Make the box tall so that we don't intersect the top face.\n    max.y += 10;\n    ray.intersectBox(model.boundingBox, modelPosition);\n    max.y -= 10;\n\n    if (modelPosition != null) {\n      modelPosition.applyMatrix4(modelToWorld);\n      goal.add(hit).sub(modelPosition);\n    }\n\n    // Move the scene's target to the model's floor height.\n    const target = scene.getTarget();\n    scene.setTarget(target.x, min.y, target.z);\n    // Ignore the y-coordinate and set on the floor instead.\n    goal.y = floor;\n\n    this.dispatchEvent({type: 'modelmove'});\n  }\n\n  [$onSelectStart](event: XRInputSourceEvent) {\n    const hitSource = this[$transientHitTestSource];\n    if (hitSource == null) {\n      return;\n    }\n    const fingers = this[$frame]!.getHitTestResultsForTransientInput(hitSource);\n    const scene = this[$presentedScene]!;\n    const box = this[$placementBox]!;\n\n    if (fingers.length === 1) {\n      this[$inputSource] = event.inputSource;\n      const {axes} = event.inputSource.gamepad;\n\n      const hitPosition = box.getHit(this[$presentedScene]!, axes[0], axes[1]);\n      box.show = true;\n\n      if (hitPosition != null) {\n        this[$isTranslating] = true;\n        this[$lastDragPosition].copy(hitPosition);\n      } else {\n        this[$isRotating] = true;\n        this[$lastScalar] = axes[0];\n      }\n    } else if (fingers.length === 2 && scene.canScale) {\n      box.show = true;\n      this[$isScaling] = true;\n      this[$lastScalar] = this[$fingerSeparation](fingers) / scene.scale.x;\n    }\n  }\n\n  [$onSelectEnd](_event: XRInputSourceEvent) {\n    this[$isTranslating] = false;\n    this[$isRotating] = false;\n    this[$isScaling] = false;\n    this[$inputSource] = null;\n    this[$goalPosition].y +=\n        this[$placementBox]!.offsetHeight * this[$presentedScene]!.scale.x;\n    this[$placementBox]!.show = false\n  }\n\n  [$fingerSeparation](fingers: XRTransientInputHitTestResult[]): number {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  }\n\n  [$processInput](frame: XRFrame) {\n    const hitSource = this[$transientHitTestSource];\n    if (hitSource == null) {\n      return;\n    }\n    if (!this[$isTranslating] && !this[$isScaling] && !this[$isRotating]) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this[$presentedScene]!;\n    const scale = scene.scale.x;\n\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this[$isScaling]) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this[$isScaling] = false;\n      } else {\n        const separation = this[$fingerSeparation](fingers);\n        const scale = separation / this[$lastScalar];\n        this[$goalScale] =\n            (scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW) ? 1 : scale;\n      }\n      return;\n    } else if (fingers.length === 2 && scene.canScale) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this[$isTranslating] = false;\n      this[$isRotating] = false;\n      this[$isScaling] = true;\n      this[$lastScalar] = this[$fingerSeparation](fingers) / scale;\n      return;\n    }\n\n    if (this[$isRotating]) {\n      const thisDragX = this[$inputSource]!.gamepad.axes[0];\n      this[$goalYaw] += (thisDragX - this[$lastScalar]) * ROTATION_RATE;\n      this[$lastScalar] = thisDragX;\n    } else if (this[$isTranslating]) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this[$inputSource] ||\n            finger.results.length < 1) {\n          return;\n        }\n\n        const hit = this[$getHitPoint](finger.results[0]);\n        if (hit == null) {\n          return;\n        }\n\n        this[$goalPosition].sub(this[$lastDragPosition]);\n\n        const offset = hit.y - this[$lastDragPosition].y;\n        // When a lower floor is found, keep the model at the same height, but\n        // drop the placement box to the floor. The model falls on select end.\n        if (offset < 0) {\n          this[$placementBox]!.offsetHeight = offset / scale;\n          this[$presentedScene]!.model.setShadowScaleAndOffset(scale, offset);\n          // Interpolate hit ray up to drag plane\n          const cameraPosition = vector3.copy(this.camera.position);\n          const alpha = -offset / (cameraPosition.y - hit.y);\n          cameraPosition.multiplyScalar(alpha);\n          hit.multiplyScalar(1 - alpha).add(cameraPosition);\n        }\n\n        this[$goalPosition].add(hit);\n        this[$lastDragPosition].copy(hit);\n      });\n    }\n  }\n\n  [$moveScene](delta: number) {\n    const scene = this[$presentedScene]!;\n    const {model, position, yaw} = scene;\n    const radius = model.idealCameraDistance;\n    const goal = this[$goalPosition];\n    const oldScale = scene.scale.x;\n    const box = this[$placementBox]!;\n\n    if (this[$initialHitSource] == null &&\n        (!goal.equals(position) || this[$goalScale] !== oldScale)) {\n      let {x, y, z} = position;\n      delta *= this[$damperRate];\n      x = this[$xDamper].update(x, goal.x, delta, radius);\n      y = this[$yDamper].update(y, goal.y, delta, radius);\n      z = this[$zDamper].update(z, goal.z, delta, radius);\n      position.set(x, y, z);\n\n      const newScale =\n          this[$scaleDamper].update(oldScale, this[$goalScale], delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n\n      if (!this[$isTranslating]) {\n        const offset = goal.y - y;\n        if (this[$placementComplete]) {\n          box.offsetHeight = offset / newScale;\n          model.setShadowScaleAndOffset(newScale, offset);\n        } else if (offset === 0) {\n          this[$placementComplete] = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n          this[$damperRate] = 1;\n        }\n      }\n    }\n    box.updateOpacity(delta);\n    scene.updateTarget(delta);\n    // This updates the model's position, which the shadow is based on.\n    scene.updateMatrixWorld(true);\n    // yaw must be updated last, since this also updates the shadow position.\n    scene.yaw = this[$yawDamper].update(yaw, this[$goalYaw], delta, Math.PI);\n  }\n\n  [$tick]() {\n    this[$rafId] = this[$currentSession]!.requestAnimationFrame(\n        (time, frame) => this[$onWebXRFrame](time, frame));\n  }\n\n  [$onWebXRFrame](time: number, frame: XRFrame) {\n    this[$frame] = frame;\n    const pose = frame.getViewerPose(this[$refSpace]!);\n\n    // TODO: Notify external observers of tick\n    this[$tick]();\n\n    const scene = this[$presentedScene];\n    if (pose == null || scene == null) {\n      return;\n    }\n\n    this[$updateCamera](pose.views[0]);\n\n    this[$placeInitially](frame);\n\n    this[$processInput](frame);\n\n    const delta = time - this[$lastTick]!;\n    this[$moveScene](delta);\n    this.renderer.preRender(scene, time, delta);\n    this[$lastTick] = time;\n\n    // NOTE: Clearing depth caused issues on Samsung devices\n    // @see https://github.com/googlecodelabs/ar-with-webxr/issues/8\n    // this.threeRenderer.clearDepth();\n    this.threeRenderer.render(scene, this.camera);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}