{"ast":null,"code":"import _slicedToArray from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { Cache, EventDispatcher, GammaEncoding, NearestFilter, PMREMGenerator, RGBEEncoding, TextureLoader } from 'three';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport EnvironmentScene from './EnvironmentScene.js';\nvar GENERATED_SIGMA = 0.04; // Enable three's loader cache so we don't create redundant\n// Image objects to decode images fetched over the network.\n\nCache.enabled = true;\nvar HDR_FILE_RE = /\\.hdr$/;\nvar ldrLoader = new TextureLoader();\nvar hdrLoader = new RGBELoader();\nvar $environmentMapCache = Symbol('environmentMapCache');\nvar $generatedEnvironmentMap = Symbol('generatedEnvironmentMap');\nvar $PMREMGenerator = Symbol('PMREMGenerator');\nvar $addMetadata = Symbol('addMetadata');\nvar $loadEnvironmentMapFromUrl = Symbol('loadEnvironmentMapFromUrl');\nvar $loadGeneratedEnvironmentMap = Symbol('loadGeneratedEnvironmentMap'); // Attach a `userData` object for arbitrary data on textures that\n// originate from TextureUtils, similar to Object3D's userData,\n// for help debugging, providing metadata for tests, and semantically\n// describe the type of texture within the context of this application.\n\nvar userData = {\n  url: null,\n  // 'Equirectangular', 'CubeUV', 'PMREM'\n  mapping: null\n};\n\nvar TextureUtils = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(TextureUtils, _EventDispatcher);\n\n  var _super = _createSuper(TextureUtils);\n\n  function TextureUtils(threeRenderer) {\n    var _this;\n\n    _classCallCheck(this, TextureUtils);\n\n    _this = _super.call(this);\n    _this[_a] = null;\n    _this[_b] = new Map();\n    _this[$PMREMGenerator] = new PMREMGenerator(threeRenderer);\n    return _this;\n  }\n\n  _createClass(TextureUtils, [{\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n        var progressCallback,\n            isHDR,\n            loader,\n            texture,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                progressCallback = _args.length > 1 && _args[1] !== undefined ? _args[1] : function () {};\n                _context.prev = 1;\n                this[$PMREMGenerator].compileEquirectangularShader();\n                isHDR = HDR_FILE_RE.test(url);\n                loader = isHDR ? hdrLoader : ldrLoader;\n                _context.next = 7;\n                return new Promise(function (resolve, reject) {\n                  return loader.load(url, resolve, function (event) {\n                    progressCallback(event.loaded / event.total * 0.9);\n                  }, reject);\n                });\n\n              case 7:\n                texture = _context.sent;\n                progressCallback(1.0);\n                this[$addMetadata](texture, url, 'Equirectangular');\n\n                if (isHDR) {\n                  texture.encoding = RGBEEncoding;\n                  texture.minFilter = NearestFilter;\n                  texture.magFilter = NearestFilter;\n                  texture.flipY = true;\n                } else {\n                  texture.encoding = GammaEncoding;\n                }\n\n                return _context.abrupt(\"return\", texture);\n\n              case 12:\n                _context.prev = 12;\n\n                if (progressCallback) {\n                  progressCallback(1);\n                }\n\n                return _context.finish(12);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1,, 12, 15]]);\n      }));\n\n      function load(_x) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"loadEquirectAsCubeUV\",\n    value: function () {\n      var _loadEquirectAsCubeUV = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url) {\n        var progressCallback,\n            equirect,\n            cubeUV,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                progressCallback = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : function () {};\n                equirect = null;\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this.load(url, progressCallback);\n\n              case 5:\n                equirect = _context2.sent;\n                cubeUV = this[$PMREMGenerator].fromEquirectangular(equirect);\n                this[$addMetadata](cubeUV.texture, url, 'CubeUV');\n                return _context2.abrupt(\"return\", cubeUV);\n\n              case 9:\n                _context2.prev = 9;\n\n                if (equirect != null) {\n                  equirect.dispose();\n                }\n\n                return _context2.finish(9);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2,, 9, 12]]);\n      }));\n\n      function loadEquirectAsCubeUV(_x2) {\n        return _loadEquirectAsCubeUV.apply(this, arguments);\n      }\n\n      return loadEquirectAsCubeUV;\n    }()\n    /**\n     * Returns a { skybox, environmentMap } object with the targets/textures\n     * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n     * is a Texture from a WebGLRenderCubeTarget.\n     */\n\n  }, {\n    key: \"generateEnvironmentMapAndSkybox\",\n    value: function () {\n      var _generateEnvironmentMapAndSkybox = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var skyboxUrl,\n            environmentMapUrl,\n            options,\n            progressTracker,\n            updateGenerationProgress,\n            skyboxLoads,\n            environmentMapLoads,\n            _yield$Promise$all,\n            _yield$Promise$all2,\n            environmentMap,\n            skybox,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                skyboxUrl = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : null;\n                environmentMapUrl = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;\n                options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n                progressTracker = options.progressTracker;\n                updateGenerationProgress = progressTracker != null ? progressTracker.beginActivity() : function () {};\n                _context3.prev = 5;\n                skyboxLoads = Promise.resolve(null);\n\n                // If we have a skybox URL, attempt to load it as a cubemap\n                if (!!skyboxUrl) {\n                  skyboxLoads = this[$loadEnvironmentMapFromUrl](skyboxUrl, progressTracker);\n                }\n\n                if (!!environmentMapUrl) {\n                  // We have an available environment map URL\n                  environmentMapLoads = this[$loadEnvironmentMapFromUrl](environmentMapUrl, progressTracker);\n                } else if (!!skyboxUrl) {\n                  // Fallback to deriving the environment map from an available skybox\n                  environmentMapLoads = skyboxLoads;\n                } else {\n                  // Fallback to generating the environment map\n                  environmentMapLoads = this[$loadGeneratedEnvironmentMap]();\n                }\n\n                _context3.next = 11;\n                return Promise.all([environmentMapLoads, skyboxLoads]);\n\n              case 11:\n                _yield$Promise$all = _context3.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                environmentMap = _yield$Promise$all2[0];\n                skybox = _yield$Promise$all2[1];\n\n                if (!(environmentMap == null)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                throw new Error('Failed to load environment map.');\n\n              case 17:\n                environmentMap = environmentMap;\n                this[$addMetadata](environmentMap.texture, environmentMapUrl, 'PMREM');\n\n                if (skybox != null) {\n                  this[$addMetadata](skybox.texture, skyboxUrl, 'PMREM');\n                }\n\n                return _context3.abrupt(\"return\", {\n                  environmentMap: environmentMap,\n                  skybox: skybox\n                });\n\n              case 21:\n                _context3.prev = 21;\n                updateGenerationProgress(1.0);\n                return _context3.finish(21);\n\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5,, 21, 24]]);\n      }));\n\n      function generateEnvironmentMapAndSkybox() {\n        return _generateEnvironmentMapAndSkybox.apply(this, arguments);\n      }\n\n      return generateEnvironmentMapAndSkybox;\n    }()\n  }, {\n    key: (_a = $generatedEnvironmentMap, _b = $environmentMapCache, $addMetadata),\n    value: function value(texture, url, mapping) {\n      if (texture == null) {\n        return;\n      }\n\n      texture.userData = Object.assign(Object.assign({}, userData), {\n        url: url,\n        mapping: mapping\n      });\n    }\n    /**\n     * Loads a WebGLRenderTarget from a given URL. The render target in this\n     * case will be assumed to be used as an environment map.\n     */\n\n  }, {\n    key: $loadEnvironmentMapFromUrl,\n    value: function value(url, progressTracker) {\n      if (!this[$environmentMapCache].has(url)) {\n        var progressCallback = progressTracker ? progressTracker.beginActivity() : function () {};\n        var environmentMapLoads = this.loadEquirectAsCubeUV(url, progressCallback);\n        this[$environmentMapCache].set(url, environmentMapLoads);\n      }\n\n      return this[$environmentMapCache].get(url);\n    }\n    /**\n     * Loads a dynamically generated environment map.\n     */\n\n  }, {\n    key: $loadGeneratedEnvironmentMap,\n    value: function value() {\n      if (this[$generatedEnvironmentMap] == null) {\n        var defaultScene = new EnvironmentScene();\n        this[$generatedEnvironmentMap] = this[$PMREMGenerator].fromScene(defaultScene, GENERATED_SIGMA);\n        defaultScene.dispose();\n      }\n\n      return Promise.resolve(this[$generatedEnvironmentMap]);\n    }\n  }, {\n    key: \"dispose\",\n    value: function () {\n      var _dispose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var allTargetsLoad, _i, _allTargetsLoad, targetLoads, target;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                allTargetsLoad = []; // NOTE(cdata): We would use for-of iteration on the maps here, but\n                // IE11 doesn't have the necessary iterator-returning methods. So,\n                // disposal of these render targets is kind of convoluted as a result.\n\n                this[$environmentMapCache].forEach(function (targetLoads) {\n                  allTargetsLoad.push(targetLoads);\n                });\n                this[$environmentMapCache].clear();\n                _i = 0, _allTargetsLoad = allTargetsLoad;\n\n              case 4:\n                if (!(_i < _allTargetsLoad.length)) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                targetLoads = _allTargetsLoad[_i];\n                _context4.prev = 6;\n                _context4.next = 9;\n                return targetLoads;\n\n              case 9:\n                target = _context4.sent;\n                target.dispose();\n                _context4.next = 15;\n                break;\n\n              case 13:\n                _context4.prev = 13;\n                _context4.t0 = _context4[\"catch\"](6);\n\n              case 15:\n                _i++;\n                _context4.next = 4;\n                break;\n\n              case 18:\n                if (this[$generatedEnvironmentMap] != null) {\n                  this[$generatedEnvironmentMap].dispose();\n                  this[$generatedEnvironmentMap] = null;\n                }\n\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[6, 13]]);\n      }));\n\n      function dispose() {\n        return _dispose.apply(this, arguments);\n      }\n\n      return dispose;\n    }()\n  }, {\n    key: \"pmremGenerator\",\n    get: function get() {\n      return this[$PMREMGenerator];\n    }\n  }]);\n\n  return TextureUtils;\n}(EventDispatcher);\n\nexport { TextureUtils as default };","map":{"version":3,"sources":["../../src/three-components/TextureUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Cache, DataTextureLoader, EventDispatcher, GammaEncoding, NearestFilter, PMREMGenerator, RGBEEncoding, Texture, TextureLoader, WebGLRenderer, WebGLRenderTarget} from 'three';\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';\n\nimport {ProgressTracker} from '../utilities/progress-tracker.js';\nimport EnvironmentScene from './EnvironmentScene.js';\n\nexport interface EnvironmentMapAndSkybox {\n  environmentMap: WebGLRenderTarget;\n  skybox: WebGLRenderTarget|null;\n}\n\nexport interface EnvironmentGenerationConfig {\n  progressTracker?: ProgressTracker;\n}\n\nconst GENERATED_SIGMA = 0.04;\n\n// Enable three's loader cache so we don't create redundant\n// Image objects to decode images fetched over the network.\nCache.enabled = true;\n\nconst HDR_FILE_RE = /\\.hdr$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\n\nconst $environmentMapCache = Symbol('environmentMapCache');\nconst $generatedEnvironmentMap = Symbol('generatedEnvironmentMap');\nconst $PMREMGenerator = Symbol('PMREMGenerator');\n\nconst $addMetadata = Symbol('addMetadata');\nconst $loadEnvironmentMapFromUrl = Symbol('loadEnvironmentMapFromUrl');\nconst $loadGeneratedEnvironmentMap = Symbol('loadGeneratedEnvironmentMap');\n\n// Attach a `userData` object for arbitrary data on textures that\n// originate from TextureUtils, similar to Object3D's userData,\n// for help debugging, providing metadata for tests, and semantically\n// describe the type of texture within the context of this application.\nconst userData = {\n  url: null,\n  // 'Equirectangular', 'CubeUV', 'PMREM'\n  mapping: null,\n};\n\nexport default class TextureUtils extends EventDispatcher {\n  get pmremGenerator() {\n    return this[$PMREMGenerator];\n  }\n\n  private[$generatedEnvironmentMap]: WebGLRenderTarget|null = null;\n  private[$PMREMGenerator]: PMREMGenerator;\n\n  private[$environmentMapCache] = new Map<string, Promise<WebGLRenderTarget>>();\n\n  constructor(threeRenderer: WebGLRenderer) {\n    super();\n    this[$PMREMGenerator] = new PMREMGenerator(threeRenderer);\n  }\n\n  async load(\n      url: string, progressCallback: (progress: number) => void = () => {}):\n      Promise<Texture> {\n    try {\n      this[$PMREMGenerator].compileEquirectangularShader();\n      const isHDR: boolean = HDR_FILE_RE.test(url);\n      const loader: DataTextureLoader = isHDR ? hdrLoader : ldrLoader;\n      const texture: Texture = await new Promise<Texture>(\n          (resolve, reject) => loader.load(\n              url, resolve, (event: {loaded: number, total: number}) => {\n                progressCallback(event.loaded / event.total * 0.9);\n              }, reject));\n\n      progressCallback(1.0);\n\n      this[$addMetadata](texture, url, 'Equirectangular');\n\n      if (isHDR) {\n        texture.encoding = RGBEEncoding;\n        texture.minFilter = NearestFilter;\n        texture.magFilter = NearestFilter;\n        texture.flipY = true;\n      } else {\n        texture.encoding = GammaEncoding;\n      }\n\n      return texture;\n\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  async loadEquirectAsCubeUV(\n      url: string, progressCallback: (progress: number) => void = () => {}):\n      Promise<WebGLRenderTarget> {\n    let equirect = null;\n\n    try {\n      equirect = await this.load(url, progressCallback);\n      const cubeUV = this[$PMREMGenerator].fromEquirectangular(equirect);\n      this[$addMetadata](cubeUV.texture, url, 'CubeUV');\n      return cubeUV;\n    } finally {\n      if (equirect != null) {\n        (equirect as any).dispose();\n      }\n    }\n  }\n\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(\n      skyboxUrl: string|null = null, environmentMapUrl: string|null = null,\n      options: EnvironmentGenerationConfig = {}):\n      Promise<EnvironmentMapAndSkybox> {\n    const {progressTracker} = options;\n    const updateGenerationProgress =\n        progressTracker != null ? progressTracker.beginActivity() : () => {};\n\n    try {\n      let skyboxLoads: Promise<WebGLRenderTarget|null> = Promise.resolve(null);\n      let environmentMapLoads: Promise<WebGLRenderTarget>;\n\n      // If we have a skybox URL, attempt to load it as a cubemap\n      if (!!skyboxUrl) {\n        skyboxLoads =\n            this[$loadEnvironmentMapFromUrl](skyboxUrl, progressTracker);\n      }\n\n      if (!!environmentMapUrl) {\n        // We have an available environment map URL\n        environmentMapLoads = this[$loadEnvironmentMapFromUrl](\n            environmentMapUrl, progressTracker);\n      } else if (!!skyboxUrl) {\n        // Fallback to deriving the environment map from an available skybox\n        environmentMapLoads = skyboxLoads as Promise<WebGLRenderTarget>;\n      } else {\n        // Fallback to generating the environment map\n        environmentMapLoads = this[$loadGeneratedEnvironmentMap]();\n      }\n\n      let [environmentMap, skybox] =\n          await Promise.all([environmentMapLoads, skyboxLoads]);\n\n      if (environmentMap == null) {\n        throw new Error('Failed to load environment map.');\n      }\n\n      environmentMap = environmentMap!;\n\n      this[$addMetadata](environmentMap.texture, environmentMapUrl, 'PMREM');\n      if (skybox != null) {\n        this[$addMetadata](skybox.texture, skyboxUrl, 'PMREM');\n      }\n\n\n      return {environmentMap, skybox};\n    } finally {\n      updateGenerationProgress(1.0);\n    }\n  }\n\n  private[$addMetadata](\n      texture: Texture|null, url: string|null, mapping: string) {\n    if (texture == null) {\n      return;\n    }\n    (texture as any).userData = {\n      ...userData,\n      ...({\n        url: url,\n        mapping: mapping,\n      })\n    };\n  }\n\n  /**\n   * Loads a WebGLRenderTarget from a given URL. The render target in this\n   * case will be assumed to be used as an environment map.\n   */\n  private[$loadEnvironmentMapFromUrl](\n      url: string,\n      progressTracker?: ProgressTracker): Promise<WebGLRenderTarget> {\n    if (!this[$environmentMapCache].has(url)) {\n      const progressCallback =\n          progressTracker ? progressTracker.beginActivity() : () => {};\n      const environmentMapLoads =\n          this.loadEquirectAsCubeUV(url, progressCallback);\n\n      this[$environmentMapCache].set(url, environmentMapLoads);\n    }\n\n    return this[$environmentMapCache].get(url)!;\n  }\n\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  private[$loadGeneratedEnvironmentMap](): Promise<WebGLRenderTarget> {\n    if (this[$generatedEnvironmentMap] == null) {\n      const defaultScene = new EnvironmentScene;\n      this[$generatedEnvironmentMap] =\n          this[$PMREMGenerator].fromScene(defaultScene, GENERATED_SIGMA);\n      defaultScene.dispose();\n    }\n\n    return Promise.resolve(this[$generatedEnvironmentMap]!);\n  }\n\n  async dispose() {\n    const allTargetsLoad: Array<Promise<WebGLRenderTarget>> = [];\n\n    // NOTE(cdata): We would use for-of iteration on the maps here, but\n    // IE11 doesn't have the necessary iterator-returning methods. So,\n    // disposal of these render targets is kind of convoluted as a result.\n\n    this[$environmentMapCache].forEach((targetLoads) => {\n      allTargetsLoad.push(targetLoads);\n    });\n\n    this[$environmentMapCache].clear();\n\n    for (const targetLoads of allTargetsLoad) {\n      try {\n        const target = await targetLoads;\n        target.dispose();\n      } catch (e) {\n        // Suppress errors, so that all render targets will be disposed\n      }\n    }\n\n    if (this[$generatedEnvironmentMap] != null) {\n      this[$generatedEnvironmentMap]!.dispose();\n      this[$generatedEnvironmentMap] = null;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}