{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Adapted from https://gist.github.com/gre/1650294\nexport var easeInOutQuad = function easeInOutQuad(t) {\n  return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n};\n/**\n * Creates a TimingFunction that uses a given ease to interpolate between\n * two configured number values.\n */\n\nexport var interpolate = function interpolate(start, end) {\n  var ease = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : easeInOutQuad;\n  return function (time) {\n    return start + (end - start) * ease(time);\n  };\n};\n/**\n * Creates a TimingFunction that interpolates through a weighted list\n * of other TimingFunctions (\"tracks\"). Tracks are interpolated in order, and\n * allocated a percentage of the total time based on their relative weight.\n */\n\nexport var sequence = function sequence(tracks, weights) {\n  var totalWeight = weights.reduce(function (total, weight) {\n    return total + weight;\n  }, 0);\n  var ratios = weights.map(function (weight) {\n    return weight / totalWeight;\n  });\n  return function (time) {\n    var start = 0;\n    var ratio = Infinity;\n\n    var track = function track() {\n      return 0;\n    };\n\n    for (var i = 0; i < ratios.length; ++i) {\n      ratio = ratios[i];\n      track = tracks[i];\n\n      if (time <= start + ratio) {\n        break;\n      }\n\n      start += ratio;\n    }\n\n    return track((time - start) / ratio);\n  };\n};\n/**\n * Creates a \"timeline\" TimingFunction out of an initial value and a series of\n * Keyframes. The timeline function accepts value from 0-1 and returns the\n * current value based on keyframe interpolation across the total number of\n * frames. Frames are only used to indicate the relative length of each keyframe\n * transition, so interpolated values will be computed for fractional frames.\n */\n\nexport var timeline = function timeline(initialValue, keyframes) {\n  var tracks = [];\n  var weights = [];\n  var lastValue = initialValue;\n\n  for (var i = 0; i < keyframes.length; ++i) {\n    var keyframe = keyframes[i];\n    var value = keyframe.value,\n        frames = keyframe.frames;\n    var ease = keyframe.ease || easeInOutQuad;\n    var track = interpolate(lastValue, value, ease);\n    tracks.push(track);\n    weights.push(frames);\n    lastValue = value;\n  }\n\n  return sequence(tracks, weights);\n};","map":{"version":3,"sources":["../../src/utilities/animation.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAeA;AACA,OAAO,IAAM,aAAa,GAAmB,SAAhC,aAAgC,CAAC,CAAD;AAAA,SACzC,CAAC,GAAG,EAAJ,GAAS,IAAI,CAAJ,GAAQ,CAAjB,GAAqB,CAAC,CAAD,GAAK,CAAC,IAAI,IAAI,CAAT,IAAc,CADC;AAAA,CAAtC;AASP;;;;;AAIA,OAAO,IAAM,WAAW,GACpB,SADS,WACT,CAAC,KAAD,EAAgB,GAAhB;AAAA,MAA6B,IAA7B,uEAAoD,aAApD;AAAA,SACsB,UAAC,IAAD;AAAA,WAAkB,KAAK,GAAG,CAAC,GAAG,GAAG,KAAP,IAAgB,IAAI,CAAC,IAAD,CAA9C;AAAA,GADtB;AAAA,CADG;AAIP;;;;;;AAKA,OAAO,IAAM,QAAQ,GACjB,SADS,QACT,CAAC,MAAD,EAAgC,OAAhC,EAA0E;AACxE,MAAM,WAAW,GAAG,OAAO,CAAC,MAAR,CAAe,UAAC,KAAD,EAAQ,MAAR;AAAA,WAAmB,KAAK,GAAG,MAA3B;AAAA,GAAf,EAAkD,CAAlD,CAApB;AACA,MAAM,MAAM,GAAkB,OAAO,CAAC,GAAR,CAAY,UAAA,MAAM;AAAA,WAAI,MAAM,GAAG,WAAb;AAAA,GAAlB,CAA9B;AAEA,SAAO,UAAC,IAAD,EAAiB;AACtB,QAAI,KAAK,GAAW,CAApB;AACA,QAAI,KAAK,GAAW,QAApB;;AACA,QAAI,KAAK,GAAmB;AAAA,aAAM,CAAN;AAAA,KAA5B;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,EAAE,CAArC,EAAwC;AACtC,MAAA,KAAK,GAAG,MAAM,CAAC,CAAD,CAAd;AACA,MAAA,KAAK,GAAG,MAAM,CAAC,CAAD,CAAd;;AAEA,UAAI,IAAI,IAAK,KAAK,GAAG,KAArB,EAA6B;AAC3B;AACD;;AAED,MAAA,KAAK,IAAI,KAAT;AACD;;AAED,WAAO,KAAM,CAAC,CAAC,IAAI,GAAG,KAAR,IAAiB,KAAlB,CAAb;AACD,GAjBD;AAkBD,CAvBE;AAmCP;;;;;;;;AAOA,OAAO,IAAM,QAAQ,GACjB,SADS,QACT,CAAC,YAAD,EAAuB,SAAvB,EAAqE;AACnE,MAAM,MAAM,GAA0B,EAAtC;AACA,MAAM,OAAO,GAAkB,EAA/B;AAEA,MAAI,SAAS,GAAG,YAAhB;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,EAAE,CAAxC,EAA2C;AACzC,QAAM,QAAQ,GAAG,SAAS,CAAC,CAAD,CAA1B;AADyC,QAElC,KAFkC,GAEjB,QAFiB,CAElC,KAFkC;AAAA,QAE3B,MAF2B,GAEjB,QAFiB,CAE3B,MAF2B;AAGzC,QAAM,IAAI,GAAG,QAAQ,CAAC,IAAT,IAAiB,aAA9B;AACA,QAAM,KAAK,GAAG,WAAW,CAAC,SAAD,EAAY,KAAZ,EAAmB,IAAnB,CAAzB;AAEA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACA,IAAA,OAAO,CAAC,IAAR,CAAa,MAAb;AACA,IAAA,SAAS,GAAG,KAAZ;AACD;;AAED,SAAO,QAAQ,CAAC,MAAD,EAAS,OAAT,CAAf;AACD,CAnBE","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Adapted from https://gist.github.com/gre/1650294\nexport const easeInOutQuad: TimingFunction = (t: number) =>\n    t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n\n/**\n * A TimingFunction accepts a value from 0-1 and returns a corresponding\n * interpolated value\n */\nexport type TimingFunction = (time: number) => number;\n\n/**\n * Creates a TimingFunction that uses a given ease to interpolate between\n * two configured number values.\n */\nexport const interpolate =\n    (start: number, end: number, ease: TimingFunction = easeInOutQuad):\n        TimingFunction => (time: number) => start + (end - start) * ease(time);\n\n/**\n * Creates a TimingFunction that interpolates through a weighted list\n * of other TimingFunctions (\"tracks\"). Tracks are interpolated in order, and\n * allocated a percentage of the total time based on their relative weight.\n */\nexport const sequence =\n    (tracks: Array<TimingFunction>, weights: Array<number>): TimingFunction => {\n      const totalWeight = weights.reduce((total, weight) => total + weight, 0);\n      const ratios: Array<number> = weights.map(weight => weight / totalWeight);\n\n      return (time: number) => {\n        let start: number = 0;\n        let ratio: number = Infinity;\n        let track: TimingFunction = () => 0;\n\n        for (let i = 0; i < ratios.length; ++i) {\n          ratio = ratios[i];\n          track = tracks[i];\n\n          if (time <= (start + ratio)) {\n            break;\n          }\n\n          start += ratio;\n        }\n\n        return track!((time - start) / ratio!);\n      }\n    };\n\n/**\n * A Keyframe groups a target value, the number of frames to interpolate towards\n * that value and an optional easing funnction to use for interpolation.\n */\nexport interface Keyframe {\n  value: number;\n  frames: number;\n  ease?: TimingFunction;\n}\n\n/**\n * Creates a \"timeline\" TimingFunction out of an initial value and a series of\n * Keyframes. The timeline function accepts value from 0-1 and returns the\n * current value based on keyframe interpolation across the total number of\n * frames. Frames are only used to indicate the relative length of each keyframe\n * transition, so interpolated values will be computed for fractional frames.\n */\nexport const timeline =\n    (initialValue: number, keyframes: Array<Keyframe>): TimingFunction => {\n      const tracks: Array<TimingFunction> = [];\n      const weights: Array<number> = [];\n\n      let lastValue = initialValue;\n\n      for (let i = 0; i < keyframes.length; ++i) {\n        const keyframe = keyframes[i];\n        const {value, frames} = keyframe;\n        const ease = keyframe.ease || easeInOutQuad;\n        const track = interpolate(lastValue, value, ease);\n\n        tracks.push(track);\n        weights.push(frames);\n        lastValue = value;\n      }\n\n      return sequence(tracks, weights);\n    };\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}