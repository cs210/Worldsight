{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Box3, DirectionalLight, Mesh, PlaneBufferGeometry, ShadowMaterial, Vector3 } from 'three'; // Nothing within Offset of the bottom of the model casts a shadow\n// (this is to avoid having a baked-in shadow plane cast its own shadow).\n\nvar OFFSET = 0.001; // The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\n\nvar LOG_MAX_RESOLUTION = 9;\nvar LOG_MIN_RESOLUTION = 6; // Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimesion multiplied\n// by this scale factor.\n\nvar ANIMATION_SCALING = 2;\n/**\n * The Shadow class creates a shadow that fits a given model and follows a\n * target. This shadow will follow the model without any updates needed so long\n * as the shadow and model are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the model's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\n\nexport var Shadow = /*#__PURE__*/function (_DirectionalLight) {\n  _inherits(Shadow, _DirectionalLight);\n\n  var _super = _createSuper(Shadow);\n\n  function Shadow(model, softness) {\n    var _this;\n\n    _classCallCheck(this, Shadow);\n\n    _this = _super.call(this);\n    _this.shadowMaterial = new ShadowMaterial();\n    _this.boundingBox = new Box3();\n    _this.size = new Vector3();\n    _this.isAnimated = false;\n    _this.needsUpdate = false; // We use the light only to cast a shadow, not to light the scene.\n\n    _this.intensity = 0;\n    _this.castShadow = true;\n    _this.frustumCulled = false;\n    _this.floor = new Mesh(new PlaneBufferGeometry(), _this.shadowMaterial);\n\n    _this.floor.rotateX(-Math.PI / 2);\n\n    _this.floor.receiveShadow = true;\n    _this.floor.castShadow = false;\n    _this.floor.frustumCulled = false;\n\n    _this.add(_this.floor);\n\n    _this.shadow.camera.up.set(0, 0, 1);\n\n    model.add(_assertThisInitialized(_this));\n    _this.target = model;\n\n    _this.setModel(model, softness);\n\n    return _this;\n  }\n  /**\n   * Update the shadow's size and position for a new model. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n\n\n  _createClass(Shadow, [{\n    key: \"setModel\",\n    value: function setModel(model, softness) {\n      this.isAnimated = model.animationNames.length > 0;\n      this.boundingBox.copy(model.boundingBox);\n      this.size.copy(model.size);\n      var boundingBox = this.boundingBox,\n          size = this.size;\n\n      if (this.isAnimated) {\n        var maxDimension = Math.max(size.x, size.y, size.z) * ANIMATION_SCALING;\n        size.y = maxDimension;\n        boundingBox.expandByVector(size.subScalar(maxDimension).multiplyScalar(-0.5));\n        boundingBox.max.y = boundingBox.min.y + maxDimension;\n        size.set(maxDimension, maxDimension, maxDimension);\n      }\n\n      var shadowOffset = size.y * OFFSET;\n      this.position.y = boundingBox.max.y + shadowOffset;\n      boundingBox.getCenter(this.floor.position);\n      this.setSoftness(softness);\n    }\n    /**\n     * Update the shadow's resolution based on softness (between 0 and 1). Should\n     * not be called frequently, as this results in reallocation.\n     */\n\n  }, {\n    key: \"setSoftness\",\n    value: function setSoftness(softness) {\n      var resolution = Math.pow(2, LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n      this.setMapSize(resolution);\n    }\n    /**\n     * Lower-level version of the above function.\n     */\n\n  }, {\n    key: \"setMapSize\",\n    value: function setMapSize(maxMapSize) {\n      var _this$shadow = this.shadow,\n          camera = _this$shadow.camera,\n          mapSize = _this$shadow.mapSize,\n          map = _this$shadow.map;\n      var size = this.size,\n          boundingBox = this.boundingBox;\n\n      if (map != null) {\n        map.dispose();\n        this.shadow.map = null;\n      }\n\n      if (this.isAnimated) {\n        maxMapSize *= ANIMATION_SCALING;\n      }\n\n      var width = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n      var height = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n      mapSize.set(width, height); // These pads account for the softening radius around the shadow.\n\n      var widthPad = 2.5 * size.x / width;\n      var heightPad = 2.5 * size.z / height;\n      camera.left = -boundingBox.max.x - widthPad;\n      camera.right = -boundingBox.min.x + widthPad;\n      camera.bottom = boundingBox.min.z - heightPad;\n      camera.top = boundingBox.max.z + heightPad;\n      this.setScaleAndOffset(camera.zoom, 0);\n      this.shadow.updateMatrices(this);\n      this.floor.scale.set(size.x + 2 * widthPad, size.z + 2 * heightPad, 1);\n      this.needsUpdate = true;\n    }\n    /**\n     * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n     * shadow rendering if zero.\n     */\n\n  }, {\n    key: \"setIntensity\",\n    value: function setIntensity(intensity) {\n      this.shadowMaterial.opacity = intensity;\n\n      if (intensity > 0) {\n        this.visible = true;\n        this.floor.visible = true;\n      } else {\n        this.visible = false;\n        this.floor.visible = false;\n      }\n    }\n  }, {\n    key: \"getIntensity\",\n    value: function getIntensity() {\n      return this.shadowMaterial.opacity;\n    }\n    /**\n     * The shadow does not rotate with its parent transforms, so the rotation must\n     * be manually updated here if it rotates in world space. The input is its\n     * absolute orientation about the Y-axis (other rotations are not supported).\n     */\n\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(radiansY) {\n      this.shadow.camera.up.set(Math.sin(radiansY), 0, Math.cos(radiansY));\n      this.shadow.updateMatrices(this);\n    }\n    /**\n     * The scale is also not inherited from parents, so it must be set here in\n     * accordance with any transforms. An offset can also be specified to move the\n     * shadow vertically relative to the bottom of the model. Positive is up, so\n     * values are generally negative.\n     */\n\n  }, {\n    key: \"setScaleAndOffset\",\n    value: function setScaleAndOffset(scale, offset) {\n      var sizeY = this.size.y;\n      var inverseScale = 1 / scale; // Floor plane is up slightly from the bottom of the bounding box to avoid\n      // Z-fighting with baked-in shadows and to stay inside the shadow camera.\n\n      var shadowOffset = sizeY * OFFSET;\n      this.floor.position.y = 2 * shadowOffset - sizeY + offset * inverseScale;\n      var camera = this.shadow.camera;\n      camera.zoom = scale;\n      camera.near = 0;\n      camera.far = sizeY * scale - offset;\n      camera.projectionMatrix.makeOrthographic(camera.left * scale, camera.right * scale, camera.top * scale, camera.bottom * scale, camera.near, camera.far);\n      camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n    }\n  }]);\n\n  return Shadow;\n}(DirectionalLight);","map":{"version":3,"sources":["../../src/three-components/Shadow.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Box3, DirectionalLight, Mesh, PlaneBufferGeometry, ShadowMaterial, Vector3} from 'three';\n\nimport Model from './Model';\n\n// Nothing within Offset of the bottom of the model casts a shadow\n// (this is to avoid having a baked-in shadow plane cast its own shadow).\nconst OFFSET = 0.001;\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimesion multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n\n/**\n * The Shadow class creates a shadow that fits a given model and follows a\n * target. This shadow will follow the model without any updates needed so long\n * as the shadow and model are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the model's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nexport class Shadow extends DirectionalLight {\n  private shadowMaterial = new ShadowMaterial;\n  private floor: Mesh;\n  private boundingBox = new Box3;\n  private size = new Vector3;\n  private isAnimated = false;\n  public needsUpdate = false;\n\n  constructor(model: Model, softness: number) {\n    super();\n\n    // We use the light only to cast a shadow, not to light the scene.\n    this.intensity = 0;\n    this.castShadow = true;\n    this.frustumCulled = false;\n\n    this.floor = new Mesh(new PlaneBufferGeometry, this.shadowMaterial);\n    this.floor.rotateX(-Math.PI / 2);\n    this.floor.receiveShadow = true;\n    this.floor.castShadow = false;\n    this.floor.frustumCulled = false;\n    this.add(this.floor);\n\n    this.shadow.camera.up.set(0, 0, 1);\n\n    model.add(this);\n    this.target = model;\n\n    this.setModel(model, softness);\n  }\n\n  /**\n   * Update the shadow's size and position for a new model. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n  setModel(model: Model, softness: number) {\n    this.isAnimated = model.animationNames.length > 0;\n    this.boundingBox.copy(model.boundingBox);\n    this.size.copy(model.size);\n    const {boundingBox, size} = this;\n\n    if (this.isAnimated) {\n      const maxDimension = Math.max(size.x, size.y, size.z) * ANIMATION_SCALING;\n      size.y = maxDimension;\n      boundingBox.expandByVector(\n          size.subScalar(maxDimension).multiplyScalar(-0.5));\n      boundingBox.max.y = boundingBox.min.y + maxDimension;\n      size.set(maxDimension, maxDimension, maxDimension);\n    }\n\n    const shadowOffset = size.y * OFFSET;\n    this.position.y = boundingBox.max.y + shadowOffset;\n    boundingBox.getCenter(this.floor.position);\n\n    this.setSoftness(softness);\n  }\n\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n  setSoftness(softness: number) {\n    const resolution = Math.pow(\n        2,\n        LOG_MAX_RESOLUTION -\n            softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n  }\n\n  /**\n   * Lower-level version of the above function.\n   */\n  setMapSize(maxMapSize: number) {\n    const {camera, mapSize, map} = this.shadow;\n    const {size, boundingBox} = this;\n\n    if (map != null) {\n      (map as any).dispose();\n      (this.shadow.map as any) = null;\n    }\n\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n\n    const width =\n        Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const height =\n        Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n\n    mapSize.set(width, height);\n    // These pads account for the softening radius around the shadow.\n    const widthPad = 2.5 * size.x / width;\n    const heightPad = 2.5 * size.z / height;\n\n    camera.left = -boundingBox.max.x - widthPad;\n    camera.right = -boundingBox.min.x + widthPad;\n    camera.bottom = boundingBox.min.z - heightPad;\n    camera.top = boundingBox.max.z + heightPad;\n\n    this.setScaleAndOffset(camera.zoom, 0);\n    this.shadow.updateMatrices(this);\n\n    this.floor.scale.set(size.x + 2 * widthPad, size.z + 2 * heightPad, 1);\n    this.needsUpdate = true;\n  }\n\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n  setIntensity(intensity: number) {\n    this.shadowMaterial.opacity = intensity;\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n\n  getIntensity(): number {\n    return this.shadowMaterial.opacity;\n  }\n\n  /**\n   * The shadow does not rotate with its parent transforms, so the rotation must\n   * be manually updated here if it rotates in world space. The input is its\n   * absolute orientation about the Y-axis (other rotations are not supported).\n   */\n  setRotation(radiansY: number) {\n    this.shadow.camera.up.set(Math.sin(radiansY), 0, Math.cos(radiansY));\n    this.shadow.updateMatrices(this);\n  }\n\n  /**\n   * The scale is also not inherited from parents, so it must be set here in\n   * accordance with any transforms. An offset can also be specified to move the\n   * shadow vertically relative to the bottom of the model. Positive is up, so\n   * values are generally negative.\n   */\n  setScaleAndOffset(scale: number, offset: number) {\n    const sizeY = this.size.y;\n    const inverseScale = 1 / scale;\n    // Floor plane is up slightly from the bottom of the bounding box to avoid\n    // Z-fighting with baked-in shadows and to stay inside the shadow camera.\n    const shadowOffset = sizeY * OFFSET;\n    this.floor.position.y = 2 * shadowOffset - sizeY + offset * inverseScale;\n    const {camera} = this.shadow;\n    camera.zoom = scale;\n    camera.near = 0;\n    camera.far = sizeY * scale - offset;\n\n    camera.projectionMatrix.makeOrthographic(\n        camera.left * scale,\n        camera.right * scale,\n        camera.top * scale,\n        camera.bottom * scale,\n        camera.near,\n        camera.far);\n    camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}