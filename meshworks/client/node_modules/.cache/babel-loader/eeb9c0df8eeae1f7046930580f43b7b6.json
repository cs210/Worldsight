{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nvar $retainerCount = Symbol('retainerCount');\nvar $recentlyUsed = Symbol('recentlyUsed');\nvar $evict = Symbol('evict');\nvar $evictionThreshold = Symbol('evictionThreshold');\nvar $cache = Symbol('cache');\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\n\nexport var CacheEvictionPolicy = /*#__PURE__*/function () {\n  function CacheEvictionPolicy(cache) {\n    var evictionThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n    _classCallCheck(this, CacheEvictionPolicy);\n\n    this[_a] = new Map();\n    this[_b] = [];\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n\n\n  _createClass(CacheEvictionPolicy, [{\n    key: \"retainerCount\",\n\n    /**\n     * Given an item key, returns the number of retainers of that item\n     */\n    value: function retainerCount(key) {\n      return this[$retainerCount].get(key) || 0;\n    }\n    /**\n     * Resets the internal tracking of cache item retainers. Use only in cases\n     * where it is certain that all retained cache items have been accounted for!\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this[$retainerCount].clear();\n      this[$recentlyUsed] = [];\n    }\n    /**\n     * Mark a given cache item as retained, where the item is represented\n     * by its key. An item can have any number of retainers.\n     */\n\n  }, {\n    key: \"retain\",\n    value: function retain(key) {\n      if (!this[$retainerCount].has(key)) {\n        this[$retainerCount].set(key, 0);\n      }\n\n      this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);\n      var recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n\n      if (recentlyUsedIndex !== -1) {\n        this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n      }\n\n      this[$recentlyUsed].unshift(key); // Evict, in case retaining a new item pushed an evictable item beyond the\n      // eviction threshold\n\n      this[$evict]();\n    }\n    /**\n     * Mark a given cache item as released by one of its retainers, where the item\n     * is represented by its key. When all retainers of an item have released it,\n     * the item is considered evictable.\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(key) {\n      if (this[$retainerCount].has(key)) {\n        this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0));\n      }\n\n      this[$evict]();\n    }\n  }, {\n    key: (_a = $retainerCount, _b = $recentlyUsed, $evict),\n    value: function value() {\n      if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n        return;\n      }\n\n      for (var i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i) {\n        var key = this[$recentlyUsed][i];\n        var retainerCount = this[$retainerCount].get(key);\n\n        if (retainerCount === 0) {\n          this[$cache].delete(key);\n          this[$recentlyUsed].splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"evictionThreshold\",\n    set: function set(value) {\n      this[$evictionThreshold] = value;\n      this[$evict]();\n    },\n    get: function get() {\n      return this[$evictionThreshold];\n    }\n    /**\n     * A reference to the cache that operates under this policy\n     */\n\n  }, {\n    key: \"cache\",\n    get: function get() {\n      return this[$cache];\n    }\n  }]);\n\n  return CacheEvictionPolicy;\n}();","map":{"version":3,"sources":["../../src/utilities/cache-eviction-policy.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A mutable cache is any object that has that allows cache\n * items to be deleted imperatively given their key\n */\nexport interface MutableCache<T> {\n  delete(key: T): void;\n}\n\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\nexport class CacheEvictionPolicy<T = string> {\n  private[$retainerCount] = new Map<T, number>();\n  private[$recentlyUsed]: Array<T> = [];\n  private[$evictionThreshold]: number;\n  private[$cache]: MutableCache<T>;\n\n  constructor(cache: MutableCache<T>, evictionThreshold: number = 5) {\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n  set evictionThreshold(value: number) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n\n  get evictionThreshold(): number {\n    return this[$evictionThreshold];\n  }\n\n  /**\n   * A reference to the cache that operates under this policy\n   */\n  get cache(): MutableCache<T> {\n    return this[$cache];\n  }\n\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n  retainerCount(key: T): number {\n    return this[$retainerCount].get(key) || 0;\n  }\n\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n  retain(key: T) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n    this[$retainerCount].set(key, this[$retainerCount].get(key)! + 1);\n\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n\n    this[$recentlyUsed].unshift(key);\n    // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n    this[$evict]();\n  }\n\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n  release(key: T) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(\n          key, Math.max(this[$retainerCount].get(key)! - 1, 0));\n    }\n\n    this[$evict]();\n  }\n\n  [$evict]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold];\n         --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}