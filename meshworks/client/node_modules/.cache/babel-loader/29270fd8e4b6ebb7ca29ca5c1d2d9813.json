{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Matrix4, Vector2 } from 'three';\nimport { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js';\nimport { $needsRender, $onResize, $scene, $tick, toVector3D } from '../model-viewer-base.js';\nimport { Hotspot } from '../three-components/Hotspot.js';\nvar $annotationRenderer = Symbol('annotationRenderer');\nvar $hotspotMap = Symbol('hotspotMap');\nvar $mutationCallback = Symbol('mutationCallback');\nvar $observer = Symbol('observer');\nvar $addHotspot = Symbol('addHotspot');\nvar $removeHotspot = Symbol('removeHotspot'); // Used internally by positionAndNormalFromPoint()\n\nvar pixelPosition = new Vector2();\nvar worldToModel = new Matrix4();\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\n\nexport var AnnotationMixin = function AnnotationMixin(ModelViewerElement) {\n  var _a, _b, _c, _d;\n\n  var AnnotationModelViewerElement = /*#__PURE__*/function (_ModelViewerElement) {\n    _inherits(AnnotationModelViewerElement, _ModelViewerElement);\n\n    var _super = _createSuper(AnnotationModelViewerElement);\n\n    function AnnotationModelViewerElement() {\n      var _this;\n\n      _classCallCheck(this, AnnotationModelViewerElement);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      _this[_a] = new CSS2DRenderer();\n      _this[_b] = new Map();\n\n      _this[_c] = function (mutations) {\n        mutations.forEach(function (mutation) {\n          // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n          // only has addedNodes and removedNodes (and no other details).\n          if (!(mutation instanceof MutationRecord) || mutation.type === 'childList') {\n            mutation.addedNodes.forEach(function (node) {\n              _this[$addHotspot](node);\n            });\n            mutation.removedNodes.forEach(function (node) {\n              _this[$removeHotspot](node);\n            });\n\n            _this[$needsRender]();\n          }\n        });\n      };\n\n      _this[_d] = new MutationObserver(_this[$mutationCallback]);\n      var shadowRoot = _this.shadowRoot;\n      var domElement = _this[$annotationRenderer].domElement;\n      domElement.classList.add('annotation-container');\n      shadowRoot.querySelector('.container').appendChild(domElement);\n      domElement.appendChild(shadowRoot.querySelector('.default'));\n      return _this;\n    }\n\n    _createClass(AnnotationModelViewerElement, [{\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(AnnotationModelViewerElement.prototype), \"connectedCallback\", this).call(this);\n\n        for (var i = 0; i < this.children.length; ++i) {\n          this[$addHotspot](this.children[i]);\n        }\n\n        var _self = self,\n            ShadyDOM = _self.ShadyDOM;\n\n        if (ShadyDOM == null) {\n          this[$observer].observe(this, {\n            childList: true\n          });\n        } else {\n          this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback]);\n        }\n      }\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(AnnotationModelViewerElement.prototype), \"disconnectedCallback\", this).call(this);\n\n        var _self2 = self,\n            ShadyDOM = _self2.ShadyDOM;\n\n        if (ShadyDOM == null) {\n          this[$observer].disconnect();\n        } else {\n          ShadyDOM.unobserveChildren(this[$observer]);\n        }\n      }\n      /**\n       * Since the data-position and data-normal attributes are not observed, use\n       * this method to move a hotspot. Keep in mind that all hotspots with the\n       * same slot name use a single location and the first definition takes\n       * precedence, until updated with this method.\n       */\n\n    }, {\n      key: \"updateHotspot\",\n      value: function updateHotspot(config) {\n        var hotspot = this[$hotspotMap].get(config.name);\n\n        if (hotspot == null) {\n          return;\n        }\n\n        hotspot.updatePosition(config.position);\n        hotspot.updateNormal(config.normal);\n      }\n      /**\n       * This method returns the model position and normal of the point on the\n       * mesh corresponding to the input pixel coordinates given relative to the\n       * model-viewer element. The position and normal are returned as strings in\n       * the format suitable for putting in a hotspot's data-position and\n       * data-normal attributes. If the mesh is not hit, the result is null.\n       */\n\n    }, {\n      key: \"positionAndNormalFromPoint\",\n      value: function positionAndNormalFromPoint(pixelX, pixelY) {\n        var scene = this[$scene];\n        var width = scene.width,\n            height = scene.height,\n            model = scene.model;\n        pixelPosition.set(pixelX / width, pixelY / height).multiplyScalar(2).subScalar(1);\n        pixelPosition.y *= -1;\n        var hit = scene.positionAndNormalFromPoint(pixelPosition);\n\n        if (hit == null) {\n          return null;\n        }\n\n        worldToModel.getInverse(model.matrixWorld);\n        var position = toVector3D(hit.position.applyMatrix4(worldToModel));\n        var normal = toVector3D(hit.normal);\n        return {\n          position: position,\n          normal: normal\n        };\n      }\n    }, {\n      key: (_a = $annotationRenderer, _b = $hotspotMap, _c = $mutationCallback, _d = $observer, $tick),\n      value: function value(time, delta) {\n        _get(_getPrototypeOf(AnnotationModelViewerElement.prototype), $tick, this).call(this, time, delta);\n\n        var scene = this[$scene];\n        var camera = scene.getCamera();\n\n        if (scene.isDirty) {\n          scene.model.updateHotspots(camera.position);\n          this[$annotationRenderer].render(scene, camera);\n        }\n      }\n    }, {\n      key: $onResize,\n      value: function value(e) {\n        _get(_getPrototypeOf(AnnotationModelViewerElement.prototype), $onResize, this).call(this, e);\n\n        this[$annotationRenderer].setSize(e.width, e.height);\n      }\n    }, {\n      key: $addHotspot,\n      value: function value(node) {\n        if (!(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)) {\n          return;\n        }\n\n        var hotspot = this[$hotspotMap].get(node.slot);\n\n        if (hotspot != null) {\n          hotspot.increment();\n        } else {\n          hotspot = new Hotspot({\n            name: node.slot,\n            position: node.dataset.position,\n            normal: node.dataset.normal\n          });\n          this[$hotspotMap].set(node.slot, hotspot);\n          this[$scene].model.addHotspot(hotspot);\n        }\n      }\n    }, {\n      key: $removeHotspot,\n      value: function value(node) {\n        if (!(node instanceof HTMLElement)) {\n          return;\n        }\n\n        var hotspot = this[$hotspotMap].get(node.slot);\n\n        if (!hotspot) {\n          return;\n        }\n\n        if (hotspot.decrement()) {\n          this[$scene].model.removeHotspot(hotspot);\n          this[$hotspotMap].delete(node.slot);\n          hotspot.dispose();\n        }\n      }\n    }]);\n\n    return AnnotationModelViewerElement;\n  }(ModelViewerElement);\n\n  return AnnotationModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/annotation.ts"],"names":[],"mappings":"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","sourcesContent":["\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Matrix4, Vector2} from 'three';\nimport {CSS2DRenderer} from 'three/examples/jsm/renderers/CSS2DRenderer.js';\n\nimport ModelViewerElementBase, {$needsRender, $onResize, $scene, $tick, toVector3D, Vector3D} from '../model-viewer-base.js';\nimport {Hotspot, HotspotConfiguration} from '../three-components/Hotspot.js';\nimport {Constructor} from '../utilities.js';\n\nconst $annotationRenderer = Symbol('annotationRenderer');\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\n\n// Used internally by positionAndNormalFromPoint()\nconst pixelPosition = new Vector2();\nconst worldToModel = new Matrix4();\n\nexport declare interface AnnotationInterface {\n  updateHotspot(config: HotspotConfiguration): void;\n  positionAndNormalFromPoint(pixelX: number, pixelY: number):\n      {position: Vector3D, normal: Vector3D}|null\n}\n\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nexport const AnnotationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnnotationInterface>&T => {\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    private[$annotationRenderer] = new CSS2DRenderer();\n    private[$hotspotMap] = new Map<string, Hotspot>();\n    private[$mutationCallback] = (mutations: Array<unknown>) => {\n      mutations.forEach((mutation) => {\n        // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n        // only has addedNodes and removedNodes (and no other details).\n        if (!(mutation instanceof MutationRecord) ||\n            mutation.type === 'childList') {\n          (mutation as MutationRecord).addedNodes.forEach((node) => {\n            this[$addHotspot](node);\n          });\n          (mutation as MutationRecord).removedNodes.forEach((node) => {\n            this[$removeHotspot](node);\n          });\n          this[$needsRender]();\n        }\n      });\n    };\n    private[$observer] = new MutationObserver(this[$mutationCallback]);\n\n    constructor(...args: Array<any>) {\n      super(...args);\n\n      const shadowRoot = this.shadowRoot!;\n      const {domElement} = this[$annotationRenderer];\n      domElement.classList.add('annotation-container');\n      shadowRoot.querySelector('.container')!.appendChild(domElement);\n      domElement.appendChild(shadowRoot.querySelector('.default')!);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {childList: true});\n      } else {\n        this[$observer] =\n            ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config: HotspotConfiguration) {\n      const hotspot = this[$hotspotMap].get(config.name);\n\n      if (hotspot == null) {\n        return;\n      }\n\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n    }\n\n    /**\n     * This method returns the model position and normal of the point on the\n     * mesh corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The position and normal are returned as strings in\n     * the format suitable for putting in a hotspot's data-position and\n     * data-normal attributes. If the mesh is not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX: number, pixelY: number):\n        {position: Vector3D, normal: Vector3D}|null {\n      const scene = this[$scene];\n      const {width, height, model} = scene;\n      pixelPosition.set(pixelX / width, pixelY / height)\n          .multiplyScalar(2)\n          .subScalar(1);\n      pixelPosition.y *= -1;\n\n      const hit = scene.positionAndNormalFromPoint(pixelPosition);\n      if (hit == null) {\n        return null;\n      }\n\n      worldToModel.getInverse(model.matrixWorld);\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal);\n      return {position: position, normal: normal};\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n\n      if (scene.isDirty) {\n        scene.model.updateHotspots(camera.position);\n        this[$annotationRenderer].render(scene, camera);\n      }\n    }\n\n    [$onResize](e: {width: number, height: number}) {\n      super[$onResize](e);\n      this[$annotationRenderer].setSize(e.width, e.height);\n    }\n\n    private[$addHotspot](node: Node) {\n      if (!(node instanceof HTMLElement &&\n            node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n\n      let hotspot = this[$hotspotMap].get(node.slot);\n\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].model.addHotspot(hotspot);\n      }\n    }\n\n    private[$removeHotspot](node: Node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n\n      const hotspot = this[$hotspotMap].get(node.slot);\n\n      if (!hotspot) {\n        return;\n      }\n\n      if (hotspot.decrement()) {\n        this[$scene].model.removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n        hotspot.dispose();\n      }\n    }\n  }\n\n  return AnnotationModelViewerElement;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}