{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _possibleConstructorReturn from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c;\n\nimport { normalizeUnit } from './conversions';\nimport { numberNode, ZERO } from './parsers';\nvar $evaluate = Symbol('evaluate');\nvar $lastValue = Symbol('lastValue');\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\n\nexport var Evaluator = /*#__PURE__*/function () {\n  function Evaluator() {\n    _classCallCheck(this, Evaluator);\n\n    this[_a] = null;\n  }\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n\n\n  _createClass(Evaluator, [{\n    key: \"evaluate\",\n\n    /**\n     * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n     * the corresponding AST will only be evaluated once, and the result of\n     * evaluating it the first time will be returned on all subsequent\n     * evaluations.\n     */\n    value: function evaluate() {\n      if (!this.isConstant || this[$lastValue] == null) {\n        this[$lastValue] = this[$evaluate]();\n      }\n\n      return this[$lastValue];\n    }\n  }, {\n    key: \"isConstant\",\n\n    /**\n     * If true, the Evaluator will only evaluate its AST one time. If false, the\n     * Evaluator will re-evaluate the AST each time that the public evaluate\n     * method is invoked.\n     */\n    get: function get() {\n      return false;\n    }\n  }], [{\n    key: \"evaluatableFor\",\n    value: function evaluatableFor(node) {\n      var basis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZERO;\n\n      if (node instanceof Evaluator) {\n        return node;\n      }\n\n      if (node.type === 'number') {\n        if (node.unit === '%') {\n          return new PercentageEvaluator(node, basis);\n        }\n\n        return node;\n      }\n\n      switch (node.name.value) {\n        case 'calc':\n          return new CalcEvaluator(node, basis);\n\n        case 'env':\n          return new EnvEvaluator(node);\n      }\n\n      return ZERO;\n    }\n    /**\n     * If the input is an Evaluator, returns the result of evaluating it.\n     * Otherwise, returns the input.\n     *\n     * This is a helper to aide in resolving a NumberNode without conditionally\n     * checking if the Evaluatable is an Evaluator everywhere.\n     */\n\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(evaluatable) {\n      if (evaluatable instanceof Evaluator) {\n        return evaluatable.evaluate();\n      }\n\n      return evaluatable;\n    }\n    /**\n     * If the input is an Evaluator, returns the value of its isConstant property.\n     * Returns true for all other input values.\n     */\n\n  }, {\n    key: \"isConstant\",\n    value: function isConstant(evaluatable) {\n      if (evaluatable instanceof Evaluator) {\n        return evaluatable.isConstant;\n      }\n\n      return true;\n    }\n    /**\n     * This method applies a set of structured intrinsic metadata to an evaluated\n     * result from a parsed CSS-like string of expressions. Intrinsics provide\n     * sufficient metadata (e.g., basis values, analogs for keywords) such that\n     * omitted values in the input string can be backfilled, and keywords can be\n     * converted to concrete numbers.\n     *\n     * The result of applying intrinsics is a tuple of NumberNode values whose\n     * units match the units used by the basis of the intrinsics.\n     *\n     * The following is a high-level description of how intrinsics are applied:\n     *\n     *  1. Determine the value of 'auto' for the current term\n     *  2. If there is no corresponding input value for this term, substitute the\n     *     'auto' value.\n     *  3. If the term is an IdentNode, treat it as a keyword and perform the\n     *     appropriate substitution.\n     *  4. If the term is still null, fallback to the 'auto' value\n     *  5. If the term is a percentage, apply it to the basis and return that\n     *     value\n     *  6. Normalize the unit of the term\n     *  7. If the term's unit does not match the basis unit, return the basis\n     *     value\n     *  8. Return the term as is\n     */\n\n  }, {\n    key: \"applyIntrinsics\",\n    value: function applyIntrinsics(evaluated, intrinsics) {\n      var basis = intrinsics.basis,\n          keywords = intrinsics.keywords;\n      var auto = keywords.auto;\n      return basis.map(function (basisNode, index) {\n        // Use an auto value if we have it, otherwise the auto value is the basis:\n        var autoSubstituteNode = auto[index] == null ? basisNode : auto[index]; // If the evaluated nodes do not have a node at the current\n        // index, fallback to the \"auto\" substitute right away:\n\n        var evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode; // Any ident node is considered a keyword:\n\n        if (evaluatedNode.type === 'ident') {\n          var keyword = evaluatedNode.value; // Substitute any keywords for concrete values first:\n\n          if (keyword in keywords) {\n            evaluatedNode = keywords[keyword][index];\n          }\n        } // If we don't have a NumberNode at this point, fall back to whatever\n        // is specified for auto:\n\n\n        if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n          evaluatedNode = autoSubstituteNode;\n        } // For percentages, we always apply the percentage to the basis value:\n\n\n        if (evaluatedNode.unit === '%') {\n          return numberNode(evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n        } // Otherwise, normalize whatever we have:\n\n\n        evaluatedNode = normalizeUnit(evaluatedNode, basisNode); // If the normalized units do not match, return the basis as a fallback:\n\n        if (evaluatedNode.unit !== basisNode.unit) {\n          return basisNode;\n        } // Finally, return the evaluated node with intrinsics applied:\n\n\n        return evaluatedNode;\n      });\n    }\n  }]);\n\n  return Evaluator;\n}();\n_a = $lastValue;\nvar $percentage = Symbol('percentage');\nvar $basis = Symbol('basis');\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\n\nexport var PercentageEvaluator = /*#__PURE__*/function (_Evaluator) {\n  _inherits(PercentageEvaluator, _Evaluator);\n\n  var _super = _createSuper(PercentageEvaluator);\n\n  function PercentageEvaluator(percentage, basis) {\n    var _this;\n\n    _classCallCheck(this, PercentageEvaluator);\n\n    _this = _super.call(this);\n    _this[$percentage] = percentage;\n    _this[$basis] = basis;\n    return _this;\n  }\n\n  _createClass(PercentageEvaluator, [{\n    key: $evaluate,\n    value: function value() {\n      return numberNode(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit);\n    }\n  }, {\n    key: \"isConstant\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return PercentageEvaluator;\n}(Evaluator);\nvar $identNode = Symbol('identNode');\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\n\nexport var EnvEvaluator = /*#__PURE__*/function (_Evaluator2) {\n  _inherits(EnvEvaluator, _Evaluator2);\n\n  var _super2 = _createSuper(EnvEvaluator);\n\n  function EnvEvaluator(envFunction) {\n    var _this2;\n\n    _classCallCheck(this, EnvEvaluator);\n\n    _this2 = _super2.call(this);\n    _this2[_b] = null;\n    var identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n\n    if (identNode != null && identNode.type === 'ident') {\n      _this2[$identNode] = identNode;\n    }\n\n    return _this2;\n  }\n\n  _createClass(EnvEvaluator, [{\n    key: (_b = $identNode, $evaluate),\n    value: function value() {\n      if (this[$identNode] != null) {\n        switch (this[$identNode].value) {\n          case 'window-scroll-y':\n            var verticalScrollPosition = window.pageYOffset;\n            var verticalScrollMax = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n            var scrollY = verticalScrollPosition / (verticalScrollMax - window.innerHeight) || 0;\n            return {\n              type: 'number',\n              number: scrollY,\n              unit: null\n            };\n        }\n      }\n\n      return ZERO;\n    }\n  }, {\n    key: \"isConstant\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return EnvEvaluator;\n}(Evaluator);\nvar IS_MULTIPLICATION_RE = /[\\*\\/]/;\nvar $evaluator = Symbol('evalutor');\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\n\nexport var CalcEvaluator = /*#__PURE__*/function (_Evaluator3) {\n  _inherits(CalcEvaluator, _Evaluator3);\n\n  var _super3 = _createSuper(CalcEvaluator);\n\n  function CalcEvaluator(calcFunction) {\n    var _this3;\n\n    var basis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZERO;\n\n    _classCallCheck(this, CalcEvaluator);\n\n    _this3 = _super3.call(this);\n    _this3[_c] = null;\n\n    if (calcFunction.arguments.length !== 1) {\n      return _possibleConstructorReturn(_this3);\n    }\n\n    var terms = calcFunction.arguments[0].terms.slice();\n    var secondOrderTerms = [];\n\n    while (terms.length) {\n      var term = terms.shift();\n\n      if (secondOrderTerms.length > 0) {\n        var previousTerm = secondOrderTerms[secondOrderTerms.length - 1];\n\n        if (previousTerm.type === 'operator' && IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          var operator = secondOrderTerms.pop();\n          var leftValue = secondOrderTerms.pop();\n\n          if (leftValue == null) {\n            return _possibleConstructorReturn(_this3);\n          }\n\n          secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n\n      secondOrderTerms.push(term.type === 'operator' ? term : Evaluator.evaluatableFor(term, basis));\n    }\n\n    while (secondOrderTerms.length > 2) {\n      var _secondOrderTerms$spl = secondOrderTerms.splice(0, 3),\n          _secondOrderTerms$spl2 = _slicedToArray(_secondOrderTerms$spl, 3),\n          left = _secondOrderTerms$spl2[0],\n          _operator = _secondOrderTerms$spl2[1],\n          right = _secondOrderTerms$spl2[2];\n\n      if (_operator.type !== 'operator') {\n        return _possibleConstructorReturn(_this3);\n      }\n\n      secondOrderTerms.unshift(new OperatorEvaluator(_operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)));\n    } // There should only be one combined evaluator at this point:\n\n\n    if (secondOrderTerms.length === 1) {\n      _this3[$evaluator] = secondOrderTerms[0];\n    }\n\n    return _this3;\n  }\n\n  _createClass(CalcEvaluator, [{\n    key: (_c = $evaluator, $evaluate),\n    value: function value() {\n      return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]) : ZERO;\n    }\n  }, {\n    key: \"isConstant\",\n    get: function get() {\n      return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);\n    }\n  }]);\n\n  return CalcEvaluator;\n}(Evaluator);\nvar $operator = Symbol('operator');\nvar $left = Symbol('left');\nvar $right = Symbol('right');\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\n\nexport var OperatorEvaluator = /*#__PURE__*/function (_Evaluator4) {\n  _inherits(OperatorEvaluator, _Evaluator4);\n\n  var _super4 = _createSuper(OperatorEvaluator);\n\n  function OperatorEvaluator(operator, left, right) {\n    var _this4;\n\n    _classCallCheck(this, OperatorEvaluator);\n\n    _this4 = _super4.call(this);\n    _this4[$operator] = operator;\n    _this4[$left] = left;\n    _this4[$right] = right;\n    return _this4;\n  }\n\n  _createClass(OperatorEvaluator, [{\n    key: $evaluate,\n    value: function value() {\n      var leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n      var rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n      var leftValue = leftNode.number,\n          leftUnit = leftNode.unit;\n      var rightValue = rightNode.number,\n          rightUnit = rightNode.unit; // Disallow operations for mismatched normalized units e.g., m and rad:\n\n      if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n        return ZERO;\n      } // NOTE(cdata): rules for calc type checking are defined here\n      // https://drafts.csswg.org/css-values-3/#calc-type-checking\n      // This is a simplification and may not hold up once we begin to support\n      // additional unit types:\n\n\n      var unit = leftUnit || rightUnit;\n      var value;\n\n      switch (this[$operator].value) {\n        case '+':\n          value = leftValue + rightValue;\n          break;\n\n        case '-':\n          value = leftValue - rightValue;\n          break;\n\n        case '/':\n          value = leftValue / rightValue;\n          break;\n\n        case '*':\n          value = leftValue * rightValue;\n          break;\n\n        default:\n          return ZERO;\n      }\n\n      return {\n        type: 'number',\n        number: value,\n        unit: unit\n      };\n    }\n  }, {\n    key: \"isConstant\",\n    get: function get() {\n      return Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right]);\n    }\n  }]);\n\n  return OperatorEvaluator;\n}(Evaluator);\nvar $evaluatables = Symbol('evaluatables');\nvar $intrinsics = Symbol('intrinsics');\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\n\nexport var StyleEvaluator = /*#__PURE__*/function (_Evaluator5) {\n  _inherits(StyleEvaluator, _Evaluator5);\n\n  var _super5 = _createSuper(StyleEvaluator);\n\n  function StyleEvaluator(expressions, intrinsics) {\n    var _this5;\n\n    _classCallCheck(this, StyleEvaluator);\n\n    _this5 = _super5.call(this);\n    _this5[$intrinsics] = intrinsics;\n    var firstExpression = expressions[0];\n    var terms = firstExpression != null ? firstExpression.terms : [];\n    _this5[$evaluatables] = intrinsics.basis.map(function (basisNode, index) {\n      var term = terms[index];\n\n      if (term == null) {\n        return {\n          type: 'ident',\n          value: 'auto'\n        };\n      }\n\n      if (term.type === 'ident') {\n        return term;\n      }\n\n      return Evaluator.evaluatableFor(term, basisNode);\n    });\n    return _this5;\n  }\n\n  _createClass(StyleEvaluator, [{\n    key: $evaluate,\n    value: function value() {\n      var evaluated = this[$evaluatables].map(function (evaluatable) {\n        return Evaluator.evaluate(evaluatable);\n      });\n      return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map(function (numberNode) {\n        return numberNode.number;\n      });\n    }\n  }, {\n    key: \"isConstant\",\n    get: function get() {\n      var _iterator = _createForOfIteratorHelper(this[$evaluatables]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var evaluatable = _step.value;\n\n          if (!Evaluator.isConstant(evaluatable)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }]);\n\n  return StyleEvaluator;\n}(Evaluator);","map":{"version":3,"sources":["../../src/styles/evaluators.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {normalizeUnit} from './conversions';\nimport {ExpressionNode, ExpressionTerm, FunctionNode, IdentNode, NumberNode, numberNode, OperatorNode, Percentage, Unit, ZERO} from './parsers';\n\nexport type Evaluatable<T> = Evaluator<T>|T;\n\n/**\n * A NumberNodeSequence is a vector of NumberNodes with a specified\n * sequence of units.\n */\nexport type NumberNodeSequence<T extends Array<Unit>, U = never> = {\n  [I in keyof T]:\n      NumberNode&{\n        unit: T[I]|U;\n      };\n};\n\nexport type Sparse<T> = {\n  [I in keyof T]: null|T[I];\n};\n\n/**\n * Intrinsics describe the metadata required to do four things for any given\n * type of number-based CSS expression:\n *\n *  1. Establish the expected units of a final, evaluated result\n *  2. Provide a foundational value that percentages should scale against\n *  3. Describe the analog number values that correspond to various keywords\n *  4. Have an available concrete value to fallback to when needed\n *\n * Intrinsics must always specify a basis and the substitute values for the\n * keyword 'auto'.\n *\n * Intrinsics may optionally specify the substitute values for any additional\n * number of keywords.\n */\nexport interface Intrinsics<T extends Array<Unit> = []> {\n  basis: NumberNodeSequence<T>;\n  keywords: {\n    auto: Sparse<NumberNodeSequence<T, Percentage>>;\n    [index: string]: Sparse<NumberNodeSequence<T, Percentage>>;\n  };\n}\n\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\nexport abstract class Evaluator<T> {\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n  static evaluatableFor(\n      node: ExpressionTerm|Evaluator<NumberNode>,\n      basis: NumberNode = ZERO): Evaluatable<NumberNode> {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node as NumberNode<'%'>, basis);\n      }\n      return node;\n    }\n\n    switch ((node as FunctionNode).name.value) {\n      case 'calc':\n        return new CalcEvaluator(node as FunctionNode, basis);\n      case 'env':\n        return new EnvEvaluator(node as FunctionNode);\n    }\n\n    return ZERO;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n  static evaluate<T extends NumberNode|IdentNode>(evaluatable: Evaluatable<T>):\n      T {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n\n    return evaluatable;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n  static isConstant<T>(evaluatable: Evaluatable<T>): boolean {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n    return true;\n  }\n\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n  static applyIntrinsics<T extends Array<Unit>>(\n      evaluated: Array<any>, intrinsics: Intrinsics<T>): NumberNodeSequence<T> {\n    const {basis, keywords} = intrinsics;\n    const {auto} = keywords;\n\n    return basis.map<NumberNode>((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];\n\n      // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n      let evaluatedNode =\n          evaluated[index] ? evaluated[index] : autoSubstituteNode;\n\n      // Any ident node is considered a keyword:\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value;\n        // Substitute any keywords for concrete values first:\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      }\n\n      // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      }\n\n      // For percentages, we always apply the percentage to the basis value:\n      if (evaluatedNode.unit === '%') {\n        return numberNode(\n            evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      }\n\n      // Otherwise, normalize whatever we have:\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode);\n\n      // If the normalized units do not match, return the basis as a fallback:\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      }\n\n      // Finally, return the evaluated node with intrinsics applied:\n      return evaluatedNode;\n    }) as NumberNodeSequence<T>;\n  }\n\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n  get isConstant(): boolean {\n    return false;\n  }\n\n  protected[$lastValue]: T|null = null;\n\n  /**\n   * This method must be implemented by subclasses. Its implementation should be\n   * the actual steps to evaluate the AST, and should return the evaluated\n   * result.\n   */\n  protected abstract[$evaluate](): T;\n\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n  evaluate(): T {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n    return this[$lastValue]!;\n  }\n}\n\n\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n\n\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\nexport class PercentageEvaluator extends Evaluator<NumberNode> {\n  protected[$percentage]: NumberNode<'%'>;\n  protected[$basis]: NumberNode;\n\n  constructor(percentage: NumberNode<'%'>, basis: NumberNode) {\n    super();\n\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n\n  get isConstant() {\n    return true;\n  }\n\n  [$evaluate]() {\n    return numberNode(\n        this[$percentage].number / 100 * this[$basis].number,\n        this[$basis].unit);\n  }\n}\n\n\nconst $identNode = Symbol('identNode');\n\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\nexport class EnvEvaluator extends Evaluator<NumberNode> {\n  protected[$identNode]: IdentNode|null = null;\n\n  constructor(envFunction: FunctionNode) {\n    super();\n\n    const identNode =\n        envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n\n  get isConstant(): boolean {\n    return false;\n  };\n\n  [$evaluate](): NumberNode {\n    if (this[$identNode] != null) {\n      switch (this[$identNode]!.value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(\n              document.body.scrollHeight,\n              document.body.offsetHeight,\n              document.documentElement.clientHeight,\n              document.documentElement.scrollHeight,\n              document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition /\n                  (verticalScrollMax - window.innerHeight) ||\n              0;\n\n          return {type: 'number', number: scrollY, unit: null};\n      }\n    }\n\n    return ZERO;\n  }\n}\n\n\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evalutor');\n\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class CalcEvaluator extends Evaluator<NumberNode> {\n  protected[$evaluator]: Evaluator<NumberNode>|null = null;\n\n  constructor(calcFunction: FunctionNode, basis: NumberNode = ZERO) {\n    super();\n\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n\n    const terms: Array<ExpressionTerm> =\n        calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms: Array<ExpressionTerm|Evaluator<NumberNode>> = [];\n\n    while (terms.length) {\n      const term: ExpressionTerm = terms.shift()!;\n\n      if (secondOrderTerms.length > 0) {\n        const previousTerm =\n            secondOrderTerms[secondOrderTerms.length - 1] as ExpressionTerm;\n        if (previousTerm.type === 'operator' &&\n            IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop() as OperatorNode;\n          const leftValue = secondOrderTerms.pop();\n\n          if (leftValue == null) {\n            return;\n          }\n\n          secondOrderTerms.push(new OperatorEvaluator(\n              operator,\n              Evaluator.evaluatableFor(leftValue, basis),\n              Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n\n      secondOrderTerms.push(\n          term.type === 'operator' ? term :\n                                     Evaluator.evaluatableFor(term, basis));\n    }\n\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n      if ((operator as ExpressionTerm).type !== 'operator') {\n        return;\n      }\n\n      secondOrderTerms.unshift(new OperatorEvaluator(\n          operator as OperatorNode,\n          Evaluator.evaluatableFor(left, basis),\n          Evaluator.evaluatableFor(right, basis)));\n    }\n\n    // There should only be one combined evaluator at this point:\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0] as Evaluator<NumberNode>;\n    }\n  }\n\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]!);\n  }\n\n  [$evaluate]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]!) :\n                                      ZERO;\n  }\n}\n\n\n\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class OperatorEvaluator extends Evaluator<NumberNode> {\n  protected[$operator]: OperatorNode;\n  protected[$left]: Evaluatable<NumberNode>;\n  protected[$right]: Evaluatable<NumberNode>;\n\n  constructor(\n      operator: OperatorNode, left: Evaluatable<NumberNode>,\n      right: Evaluatable<NumberNode>) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) &&\n        Evaluator.isConstant(this[$right]);\n  }\n\n  [$evaluate](): NumberNode {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const {number: leftValue, unit: leftUnit} = leftNode;\n    const {number: rightValue, unit: rightUnit} = rightNode;\n\n    // Disallow operations for mismatched normalized units e.g., m and rad:\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    }\n\n    // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n    const unit = leftUnit || rightUnit;\n    let value;\n\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      default:\n        return ZERO;\n    }\n\n    return {type: 'number', number: value, unit};\n  }\n}\n\n\nexport type EvaluatedStyle<T extends Intrinsics<Array<Unit>>> = {\n  [I in keyof T['basis']]: number;\n}&Array<never>;\n\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\nexport class StyleEvaluator<T extends Intrinsics<Array<any>>> extends\n    Evaluator<EvaluatedStyle<T>> {\n  protected[$intrinsics]: T;\n  protected[$evaluatables]: Array<Evaluatable<NumberNode|IdentNode>>;\n\n  constructor(expressions: Array<ExpressionNode>, intrinsics: T) {\n    super();\n\n    this[$intrinsics] = intrinsics;\n\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n\n    this[$evaluatables] =\n        intrinsics.basis.map<Evaluatable<NumberNode|IdentNode>>(\n            (basisNode, index) => {\n              const term = terms[index];\n              if (term == null) {\n                return {type: 'ident', value: 'auto'};\n              }\n\n              if (term.type === 'ident') {\n                return term;\n              }\n\n              return Evaluator.evaluatableFor(term, basisNode);\n            });\n  }\n\n  get isConstant(): boolean {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map<NumberNode|IdentNode>(\n        evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics])\n               .map<number>(numberNode => numberNode.number) as\n        EvaluatedStyle<T>;\n  }\n}\n\n// SphericalIntrinsics are Intrinsics that expect two angle terms\n// and one length term\nexport type SphericalIntrinsics = Intrinsics<['rad', 'rad', 'm']>;\n// Vector3Intrinsics expect three length terms\nexport type Vector3Intrinsics = Intrinsics<['m', 'm', 'm']>;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}