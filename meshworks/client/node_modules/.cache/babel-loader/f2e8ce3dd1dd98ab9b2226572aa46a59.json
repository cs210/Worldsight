{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nimport { BackSide, DoubleSide, FrontSide, Mesh } from 'three';\nimport { RoughnessMipmapper } from 'three/examples/jsm/utils/RoughnessMipmapper.js';\nimport { $clone, $prepare, GLTFInstance } from '../GLTFInstance.js';\nimport { Renderer } from '../Renderer.js';\nimport { alphaChunk } from '../shader-chunk/alphatest_fragment.glsl.js';\nvar $roughnessMipmapper = Symbol('roughnessMipmapper');\nvar $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\n\nexport var ModelViewerGLTFInstance = /*#__PURE__*/function (_GLTFInstance) {\n  _inherits(ModelViewerGLTFInstance, _GLTFInstance);\n\n  var _super = _createSuper(ModelViewerGLTFInstance);\n\n  function ModelViewerGLTFInstance() {\n    _classCallCheck(this, ModelViewerGLTFInstance);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ModelViewerGLTFInstance, [{\n    key: $clone,\n\n    /**\n     * @override\n     */\n    value: function value() {\n      var _this = this;\n\n      var clone = _get(_getPrototypeOf(ModelViewerGLTFInstance.prototype), $clone, this).call(this);\n\n      var sourceUUIDToClonedMaterial = new Map();\n      clone.scene.traverse(function (node) {\n        // Materials aren't cloned when cloning meshes; geometry\n        // and materials are copied by reference. This is necessary\n        // for the same model to be used twice with different\n        // environment maps.\n        if (node.isMesh) {\n          var mesh = node;\n\n          if (Array.isArray(mesh.material)) {\n            mesh.material = mesh.material.map(function (material) {\n              return _this[$cloneAndPatchMaterial](material, sourceUUIDToClonedMaterial);\n            });\n          } else if (mesh.material != null) {\n            mesh.material = _this[$cloneAndPatchMaterial](mesh.material, sourceUUIDToClonedMaterial);\n          }\n        }\n      });\n      return clone;\n    }\n    /**\n     * Creates a clone of the given material, and applies a patch to the\n     * shader program.\n     */\n\n  }, {\n    key: $cloneAndPatchMaterial,\n    value: function value(material, sourceUUIDToClonedMaterial) {\n      // If we already cloned this material (determined by tracking the UUID of\n      // source materials that have been cloned), then return that previously\n      // cloned instance:\n      if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n        return sourceUUIDToClonedMaterial.get(material.uuid);\n      }\n\n      var clone = material.clone(); // This allows us to patch three's materials, on top of patches already\n      // made, for instance GLTFLoader patches SpecularGlossiness materials.\n      // Unfortunately, three's program cache differentiates SpecGloss materials\n      // via onBeforeCompile.toString(), so these two functions do the same\n      // thing but look different in order to force a proper recompile.\n\n      var oldOnBeforeCompile = material.onBeforeCompile;\n      clone.onBeforeCompile = material.isGLTFSpecularGlossinessMaterial ? function (shader) {\n        oldOnBeforeCompile(shader, undefined);\n        shader.fragmentShader = shader.fragmentShader.replace('#include <alphatest_fragment>', alphaChunk);\n      } : function (shader) {\n        shader.fragmentShader = shader.fragmentShader.replace('#include <alphatest_fragment>', alphaChunk);\n        oldOnBeforeCompile(shader, undefined);\n      }; // This makes shadows better for non-manifold meshes\n\n      clone.shadowSide = FrontSide; // This improves transparent rendering and can be removed whenever\n      // https://github.com/mrdoob/three.js/pull/18235 finally lands.\n\n      if (clone.transparent) {\n        clone.depthWrite = false;\n      } // This little hack ignores alpha for opaque materials, in order to comply\n      // with the glTF spec.\n\n\n      if (!clone.alphaTest && !clone.transparent) {\n        clone.alphaTest = -0.5;\n      }\n\n      sourceUUIDToClonedMaterial.set(material.uuid, clone);\n      return clone;\n    }\n  }], [{\n    key: (_a = $roughnessMipmapper, $prepare),\n\n    /**\n     * @override\n     */\n    value: function value(source) {\n      var _this2 = this;\n\n      var prepared = _get(_getPrototypeOf(ModelViewerGLTFInstance), $prepare, this).call(this, source);\n\n      var scene = prepared.scene;\n      var meshesToDuplicate = [];\n      scene.traverse(function (node) {\n        // Set a high renderOrder while we're here to ensure the model\n        // always renders on top of the skysphere\n        node.renderOrder = 1000; // Three.js seems to cull some animated models incorrectly. Since we\n        // expect to view our whole scene anyway, we turn off the frustum\n        // culling optimization here.\n\n        node.frustumCulled = false; // Animations for objects without names target their UUID instead. When\n        // objects are cloned, they get new UUIDs which the animation can't\n        // find. To fix this, we assign their UUID as their name.\n\n        if (!node.name) {\n          node.name = node.uuid;\n        }\n\n        if (!node.isMesh) {\n          return;\n        }\n\n        node.castShadow = true;\n        var mesh = node;\n        var transparent = false;\n        var materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(function (material) {\n          if (material.isMeshStandardMaterial) {\n            if (material.transparent && material.side === DoubleSide) {\n              transparent = true;\n              material.side = FrontSide;\n            }\n\n            _this2[$roughnessMipmapper].generateMipmaps(material);\n          }\n        });\n\n        if (transparent) {\n          meshesToDuplicate.push(mesh);\n        }\n      }); // We duplicate transparent, double-sided meshes and render the back face\n      // before the front face. This creates perfect triangle sorting for all\n      // convex meshes. Sorting artifacts can still appear when you can see\n      // through more than two layers of a given mesh, but this can usually be\n      // mitigated by the author splitting the mesh into mostly convex regions.\n      // The performance cost is not too great as the same shader is reused and\n      // the same number of fragments are processed; only the vertex shader is run\n      // twice. @see https://threejs.org/examples/webgl_materials_physical_transparency.html\n\n      for (var _i = 0, _meshesToDuplicate = meshesToDuplicate; _i < _meshesToDuplicate.length; _i++) {\n        var mesh = _meshesToDuplicate[_i];\n        var materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        var duplicateMaterials = materials.map(function (material) {\n          var backMaterial = material.clone();\n          backMaterial.side = BackSide;\n          return backMaterial;\n        });\n        var duplicateMaterial = Array.isArray(mesh.material) ? duplicateMaterials : duplicateMaterials[0];\n        var meshBack = new Mesh(mesh.geometry, duplicateMaterial);\n        meshBack.renderOrder = -1;\n        mesh.add(meshBack);\n      }\n\n      return prepared;\n    }\n  }]);\n\n  return ModelViewerGLTFInstance;\n}(GLTFInstance);\nModelViewerGLTFInstance[_a] = new RoughnessMipmapper(Renderer.singleton.threeRenderer);","map":{"version":3,"sources":["../../../src/three-components/gltf-instance/ModelViewerGLTFInstance.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BackSide, DoubleSide, FrontSide, Material, Mesh, MeshStandardMaterial, Object3D, Shader} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport {RoughnessMipmapper} from 'three/examples/jsm/utils/RoughnessMipmapper.js';\n\nimport {$clone, $prepare, GLTFInstance, PreparedGLTF} from '../GLTFInstance.js';\nimport {Renderer} from '../Renderer.js';\nimport {alphaChunk} from '../shader-chunk/alphatest_fragment.glsl.js';\n\n\nconst $roughnessMipmapper = Symbol('roughnessMipmapper');\nconst $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\n\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  protected static[$roughnessMipmapper]: RoughnessMipmapper =\n      new RoughnessMipmapper(Renderer.singleton.threeRenderer);\n\n  /**\n   * @override\n   */\n  protected static[$prepare](source: GLTF) {\n    const prepared = super[$prepare](source);\n    const {scene} = prepared;\n\n    const meshesToDuplicate: Mesh[] = [];\n\n    scene.traverse((node: Object3D) => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the skysphere\n      node.renderOrder = 1000;\n\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      if (!(node as Mesh).isMesh) {\n        return;\n      }\n      node.castShadow = true;\n      const mesh = node as Mesh;\n      let transparent = false;\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      materials.forEach(material => {\n        if ((material as any).isMeshStandardMaterial) {\n          if (material.transparent && material.side === DoubleSide) {\n            transparent = true;\n            material.side = FrontSide;\n          }\n          this[$roughnessMipmapper].generateMipmaps(\n              material as MeshStandardMaterial);\n        }\n      });\n\n      if (transparent) {\n        meshesToDuplicate.push(mesh);\n      }\n    });\n\n    // We duplicate transparent, double-sided meshes and render the back face\n    // before the front face. This creates perfect triangle sorting for all\n    // convex meshes. Sorting artifacts can still appear when you can see\n    // through more than two layers of a given mesh, but this can usually be\n    // mitigated by the author splitting the mesh into mostly convex regions.\n    // The performance cost is not too great as the same shader is reused and\n    // the same number of fragments are processed; only the vertex shader is run\n    // twice. @see https://threejs.org/examples/webgl_materials_physical_transparency.html\n    for (const mesh of meshesToDuplicate) {\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      const duplicateMaterials = materials.map((material) => {\n        const backMaterial = material.clone();\n        backMaterial.side = BackSide;\n        return backMaterial;\n      });\n      const duplicateMaterial = Array.isArray(mesh.material) ?\n          duplicateMaterials :\n          duplicateMaterials[0];\n      const meshBack = new Mesh(mesh.geometry, duplicateMaterial);\n      meshBack.renderOrder = -1;\n      mesh.add(meshBack);\n    }\n\n    return prepared;\n  }\n\n  /**\n   * @override\n   */\n  [$clone](): PreparedGLTF {\n    const clone = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map<string, Material>();\n\n    clone.scene.traverse((node: any) => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // environment maps.\n      if ((node as Mesh).isMesh) {\n        const mesh = node as Mesh;\n        if (Array.isArray(mesh.material)) {\n          mesh.material = mesh.material.map(\n              (material) => this[$cloneAndPatchMaterial](\n                  material, sourceUUIDToClonedMaterial));\n        } else if (mesh.material != null) {\n          mesh.material = this[$cloneAndPatchMaterial](\n              mesh.material, sourceUUIDToClonedMaterial);\n        }\n      }\n    });\n\n    return clone;\n  }\n\n  /**\n   * Creates a clone of the given material, and applies a patch to the\n   * shader program.\n   */\n  [$cloneAndPatchMaterial](\n      material: Material, sourceUUIDToClonedMaterial: Map<string, Material>) {\n    // If we already cloned this material (determined by tracking the UUID of\n    // source materials that have been cloned), then return that previously\n    // cloned instance:\n    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n      return sourceUUIDToClonedMaterial.get(material.uuid)!;\n    }\n\n    const clone = material.clone();\n\n    // This allows us to patch three's materials, on top of patches already\n    // made, for instance GLTFLoader patches SpecularGlossiness materials.\n    // Unfortunately, three's program cache differentiates SpecGloss materials\n    // via onBeforeCompile.toString(), so these two functions do the same\n    // thing but look different in order to force a proper recompile.\n    const oldOnBeforeCompile = material.onBeforeCompile;\n    clone.onBeforeCompile = (material as any).isGLTFSpecularGlossinessMaterial ?\n        (shader: Shader) => {\n          oldOnBeforeCompile(shader, undefined as any);\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n        } :\n        (shader: Shader) => {\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n          oldOnBeforeCompile(shader, undefined as any);\n        };\n    // This makes shadows better for non-manifold meshes\n    clone.shadowSide = FrontSide;\n    // This improves transparent rendering and can be removed whenever\n    // https://github.com/mrdoob/three.js/pull/18235 finally lands.\n    if (clone.transparent) {\n      clone.depthWrite = false;\n    }\n    // This little hack ignores alpha for opaque materials, in order to comply\n    // with the glTF spec.\n    if (!clone.alphaTest && !clone.transparent) {\n      clone.alphaTest = -0.5;\n    }\n\n    sourceUUIDToClonedMaterial.set(material.uuid, clone);\n\n    return clone;\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}