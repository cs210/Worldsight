{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { $needsRender, $onModelLoad, $renderer, $scene, $tick, $updateSource } from '../model-viewer-base.js';\nvar MILLISECONDS_PER_SECOND = 1000.0;\nvar $changeAnimation = Symbol('changeAnimation');\nvar $paused = Symbol('paused');\nexport var AnimationMixin = function AnimationMixin(ModelViewerElement) {\n  var _a;\n\n  var AnimationModelViewerElement = /*#__PURE__*/function (_ModelViewerElement) {\n    _inherits(AnimationModelViewerElement, _ModelViewerElement);\n\n    var _super = _createSuper(AnimationModelViewerElement);\n\n    function AnimationModelViewerElement() {\n      var _this;\n\n      _classCallCheck(this, AnimationModelViewerElement);\n\n      _this = _super.apply(this, arguments);\n      _this.autoplay = false;\n      _this.animationName = undefined;\n      _this.animationCrossfadeDuration = 300;\n      _this[_a] = true;\n      return _this;\n    }\n    /**\n     * Returns an array\n     */\n\n\n    _createClass(AnimationModelViewerElement, [{\n      key: \"pause\",\n      value: function pause() {\n        if (this[$paused]) {\n          return;\n        }\n\n        this[$paused] = true;\n        this[$renderer].threeRenderer.shadowMap.autoUpdate = false;\n        this.dispatchEvent(new CustomEvent('pause'));\n      }\n    }, {\n      key: \"play\",\n      value: function play() {\n        if (this[$paused] && this.availableAnimations.length > 0) {\n          this[$paused] = false;\n          this[$renderer].threeRenderer.shadowMap.autoUpdate = true;\n\n          if (!this[$scene].model.hasActiveAnimation) {\n            this[$changeAnimation]();\n          }\n\n          this.dispatchEvent(new CustomEvent('play'));\n        }\n      }\n    }, {\n      key: (_a = $paused, $onModelLoad),\n      value: function value() {\n        this[$paused] = true;\n\n        if (this.autoplay) {\n          this[$changeAnimation]();\n          this.play();\n        }\n      }\n    }, {\n      key: $tick,\n      value: function value(_time, delta) {\n        _get(_getPrototypeOf(AnimationModelViewerElement.prototype), $tick, this).call(this, _time, delta);\n\n        if (this[$paused]) {\n          return;\n        }\n\n        var model = this[$scene].model;\n        model.updateAnimation(delta / MILLISECONDS_PER_SECOND);\n        this[$needsRender]();\n      }\n    }, {\n      key: \"updated\",\n      value: function updated(changedProperties) {\n        _get(_getPrototypeOf(AnimationModelViewerElement.prototype), \"updated\", this).call(this, changedProperties);\n\n        if (changedProperties.has('autoplay') && this.autoplay) {\n          this.play();\n        }\n\n        if (changedProperties.has('animationName')) {\n          this[$changeAnimation]();\n        }\n      }\n    }, {\n      key: $updateSource,\n      value: function () {\n        var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  // If we are loading a new model, we need to stop the animation of\n                  // the current one (if any is playing). Otherwise, we might lose\n                  // the reference to the scene root and running actions start to\n                  // throw exceptions and/or behave in unexpected ways:\n                  this[$scene].model.stopAnimation();\n                  return _context.abrupt(\"return\", _get(_getPrototypeOf(AnimationModelViewerElement.prototype), $updateSource, this).call(this));\n\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function value() {\n          return _value.apply(this, arguments);\n        }\n\n        return value;\n      }()\n    }, {\n      key: $changeAnimation,\n      value: function value() {\n        var model = this[$scene].model;\n        model.playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND); // If we are currently paused, we need to force a render so that\n        // the model updates to the first frame of the new animation\n\n        if (this[$paused]) {\n          model.updateAnimation(0);\n          this[$needsRender]();\n        }\n      }\n    }, {\n      key: \"availableAnimations\",\n      get: function get() {\n        if (this.loaded) {\n          return this[$scene].model.animationNames;\n        }\n\n        return [];\n      }\n    }, {\n      key: \"paused\",\n      get: function get() {\n        return this[$paused];\n      }\n    }, {\n      key: \"currentTime\",\n      get: function get() {\n        return this[$scene].model.animationTime;\n      },\n      set: function set(value) {\n        this[$scene].model.animationTime = value;\n        this[$renderer].threeRenderer.shadowMap.needsUpdate = true;\n        this[$needsRender]();\n      }\n    }]);\n\n    return AnimationModelViewerElement;\n  }(ModelViewerElement);\n\n  __decorate([property({\n    type: Boolean\n  })], AnimationModelViewerElement.prototype, \"autoplay\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'animation-name'\n  })], AnimationModelViewerElement.prototype, \"animationName\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'animation-crossfade-duration'\n  })], AnimationModelViewerElement.prototype, \"animationCrossfadeDuration\", void 0);\n\n  return AnimationModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/animation.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit-element';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $renderer, $scene, $tick, $updateSource} from '../model-viewer-base.js';\nimport {Constructor} from '../utilities.js';\n\nconst MILLISECONDS_PER_SECOND = 1000.0\n\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\n\nexport declare interface AnimationInterface {\n  autoplay: boolean;\n  animationName: string|void;\n  animationCrossfadeDuration: number;\n  readonly availableAnimations: Array<string>;\n  readonly paused: boolean;\n  currentTime: number;\n  pause(): void;\n  play(): void;\n}\n\nexport const AnimationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnimationInterface>&T => {\n  class AnimationModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean}) autoplay: boolean = false;\n    @property({type: String, attribute: 'animation-name'})\n    animationName: string|undefined = undefined;\n    @property({type: Number, attribute: 'animation-crossfade-duration'})\n    animationCrossfadeDuration: number = 300;\n\n    protected[$paused]: boolean = true;\n\n    /**\n     * Returns an array\n     */\n    get availableAnimations(): Array<string> {\n      if (this.loaded) {\n        return this[$scene].model.animationNames;\n      }\n\n      return [];\n    }\n\n    get paused(): boolean {\n      return this[$paused];\n    }\n\n    get currentTime(): number {\n      return this[$scene].model.animationTime;\n    }\n\n    set currentTime(value: number) {\n      this[$scene].model.animationTime = value;\n      this[$renderer].threeRenderer.shadowMap.needsUpdate = true;\n      this[$needsRender]();\n    }\n\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n\n      this[$paused] = true;\n      this[$renderer].threeRenderer.shadowMap.autoUpdate = false;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n\n    play() {\n      if (this[$paused] && this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$renderer].threeRenderer.shadowMap.autoUpdate = true;\n\n        if (!this[$scene].model.hasActiveAnimation) {\n          this[$changeAnimation]();\n        }\n\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n\n    [$onModelLoad]() {\n      this[$paused] = true;\n\n      if (this.autoplay) {\n        this[$changeAnimation]();\n        this.play();\n      }\n    }\n\n    [$tick](_time: number, delta: number) {\n      super[$tick](_time, delta);\n\n      if (this[$paused]) {\n        return;\n      }\n\n      const {model} = this[$scene];\n      model.updateAnimation(delta / MILLISECONDS_PER_SECOND);\n\n      this[$needsRender]();\n    }\n\n    updated(changedProperties: Map<string, any>) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n\n    async[$updateSource]() {\n      // If we are loading a new model, we need to stop the animation of\n      // the current one (if any is playing). Otherwise, we might lose\n      // the reference to the scene root and running actions start to\n      // throw exceptions and/or behave in unexpected ways:\n      this[$scene].model.stopAnimation();\n\n      return super[$updateSource]();\n    }\n\n    [$changeAnimation]() {\n      const {model} = this[$scene];\n\n      model.playAnimation(\n          this.animationName,\n          this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND);\n\n      // If we are currently paused, we need to force a render so that\n      // the model updates to the first frame of the new animation\n      if (this[$paused]) {\n        model.updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n  }\n\n  return AnimationModelViewerElement;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}