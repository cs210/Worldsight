{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\nimport { Euler, EventDispatcher, Spherical } from 'three';\nimport { clamp } from '../utilities.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nexport var DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  eventHandlingBehavior: 'prevent-all',\n  interactionPolicy: 'always-allow'\n}); // Internal orbital position state\n\nvar $spherical = Symbol('spherical');\nvar $goalSpherical = Symbol('goalSpherical');\nvar $thetaDamper = Symbol('thetaDamper');\nvar $phiDamper = Symbol('phiDamper');\nvar $radiusDamper = Symbol('radiusDamper');\nvar $logFov = Symbol('fov');\nvar $goalLogFov = Symbol('goalLogFov');\nvar $fovDamper = Symbol('fovDamper');\nvar $options = Symbol('options');\nvar $touchMode = Symbol('touchMode');\nvar $canInteract = Symbol('canInteract');\nvar $interactionEnabled = Symbol('interactionEnabled');\nvar $userAdjustOrbit = Symbol('userAdjustOrbit');\nvar $isUserChange = Symbol('isUserChange');\nvar $isStationary = Symbol('isMoving');\nvar $moveCamera = Symbol('moveCamera');\nvar $isUserPointing = Symbol('isUserPointing'); // Pointer state\n\nvar $pointerIsDown = Symbol('pointerIsDown');\nvar $lastPointerPosition = Symbol('lastPointerPosition');\nvar $lastTouches = Symbol('lastTouches'); // Value conversion methods\n\nvar $pixelLengthToSphericalAngle = Symbol('pixelLengthToSphericalAngle');\nvar $twoTouchDistance = Symbol('twoTouchDistance');\nvar $wrapAngle = Symbol('wrapAngle'); // Event handlers\n\nvar $onMouseMove = Symbol('onMouseMove');\nvar $onMouseDown = Symbol('onMouseDown');\nvar $onMouseUp = Symbol('onMouseUp');\nvar $onTouchStart = Symbol('onTouchStart');\nvar $onTouchEnd = Symbol('onTouchEnd');\nvar $onTouchMove = Symbol('onTouchMove');\nvar $onWheel = Symbol('onWheel');\nvar $onKeyDown = Symbol('onKeyDown');\nvar $handlePointerMove = Symbol('handlePointerMove');\nvar $handleSinglePointerMove = Symbol('handleSinglePointerMove');\nvar $handlePointerDown = Symbol('handlePointerDown');\nvar $handleSinglePointerDown = Symbol('handleSinglePointerDown');\nvar $handlePointerUp = Symbol('handlePointerUp');\nvar $handleWheel = Symbol('handleWheel');\nvar $handleKey = Symbol('handleKey'); // Constants\n\nvar TOUCH_EVENT_RE = /^touch(start|end|move)$/;\nvar KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nvar ZOOM_SENSITIVITY = 0.04;\nexport var KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nexport var ChangeSource = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none'\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\n\nexport var SmoothControls = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(SmoothControls, _EventDispatcher);\n\n  var _super = _createSuper(SmoothControls);\n\n  function SmoothControls(camera, element) {\n    var _this;\n\n    _classCallCheck(this, SmoothControls);\n\n    _this = _super.call(this);\n    _this.camera = camera;\n    _this.element = element;\n    _this[_a] = false;\n    _this[_b] = false;\n    _this[_c] = false;\n    _this[_d] = new Spherical();\n    _this[_e] = new Spherical();\n    _this[_f] = new Damper();\n    _this[_g] = new Damper();\n    _this[_h] = new Damper();\n    _this[_j] = new Damper();\n    _this[_k] = false;\n    _this[_l] = {\n      clientX: 0,\n      clientY: 0\n    };\n\n    _this[$onMouseMove] = function (event) {\n      return _this[$handlePointerMove](event);\n    };\n\n    _this[$onMouseDown] = function (event) {\n      return _this[$handlePointerDown](event);\n    };\n\n    _this[$onMouseUp] = function (event) {\n      return _this[$handlePointerUp](event);\n    };\n\n    _this[$onWheel] = function (event) {\n      return _this[$handleWheel](event);\n    };\n\n    _this[$onKeyDown] = function (event) {\n      return _this[$handleKey](event);\n    };\n\n    _this[$onTouchStart] = function (event) {\n      return _this[$handlePointerDown](event);\n    };\n\n    _this[$onTouchEnd] = function (event) {\n      return _this[$handlePointerUp](event);\n    };\n\n    _this[$onTouchMove] = function (event) {\n      return _this[$handlePointerMove](event);\n    };\n\n    _this[$options] = Object.assign({}, DEFAULT_OPTIONS);\n\n    _this.setOrbit(0, Math.PI / 2, 1);\n\n    _this.setFieldOfView(100);\n\n    _this.jumpToGoal();\n\n    return _this;\n  }\n\n  _createClass(SmoothControls, [{\n    key: \"enableInteraction\",\n    value: function enableInteraction() {\n      if (this[$interactionEnabled] === false) {\n        var element = this.element;\n        element.addEventListener('mousemove', this[$onMouseMove]);\n        element.addEventListener('mousedown', this[$onMouseDown]);\n        element.addEventListener('wheel', this[$onWheel]);\n        element.addEventListener('keydown', this[$onKeyDown]);\n        element.addEventListener('touchstart', this[$onTouchStart]);\n        element.addEventListener('touchmove', this[$onTouchMove]);\n        self.addEventListener('mouseup', this[$onMouseUp]);\n        self.addEventListener('touchend', this[$onTouchEnd]);\n        this.element.style.cursor = 'grab';\n        this[$interactionEnabled] = true;\n      }\n    }\n  }, {\n    key: \"disableInteraction\",\n    value: function disableInteraction() {\n      if (this[$interactionEnabled] === true) {\n        var element = this.element;\n        element.removeEventListener('mousemove', this[$onMouseMove]);\n        element.removeEventListener('mousedown', this[$onMouseDown]);\n        element.removeEventListener('wheel', this[$onWheel]);\n        element.removeEventListener('keydown', this[$onKeyDown]);\n        element.removeEventListener('touchstart', this[$onTouchStart]);\n        element.removeEventListener('touchmove', this[$onTouchMove]);\n        self.removeEventListener('mouseup', this[$onMouseUp]);\n        self.removeEventListener('touchend', this[$onTouchEnd]);\n        element.style.cursor = '';\n        this[$interactionEnabled] = false;\n      }\n    }\n    /**\n     * The options that are currently configured for the controls instance.\n     */\n\n  }, {\n    key: \"getCameraSpherical\",\n\n    /**\n     * Copy the spherical values that represent the current camera orbital\n     * position relative to the configured target into a provided Spherical\n     * instance. If no Spherical is provided, a new Spherical will be allocated\n     * to copy the values into. The Spherical that values are copied into is\n     * returned.\n     */\n    value: function getCameraSpherical() {\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Spherical();\n      return target.copy(this[$spherical]);\n    }\n    /**\n     * Returns the camera's current vertical field of view in degrees.\n     */\n\n  }, {\n    key: \"getFieldOfView\",\n    value: function getFieldOfView() {\n      return this.camera.fov;\n    }\n    /**\n     * Configure the options of the controls. Configured options will be\n     * merged with whatever options have already been configured for this\n     * controls instance.\n     */\n\n  }, {\n    key: \"applyOptions\",\n    value: function applyOptions(options) {\n      Object.assign(this[$options], options); // Re-evaluates clamping based on potentially new values for min/max\n      // polar, azimuth and radius:\n\n      this.setOrbit();\n      this.setFieldOfView(Math.exp(this[$goalLogFov]));\n    }\n    /**\n     * Sets the near and far planes of the camera.\n     */\n\n  }, {\n    key: \"updateNearFar\",\n    value: function updateNearFar(nearPlane, farPlane) {\n      this.camera.near = Math.max(nearPlane, farPlane / 1000);\n      this.camera.far = farPlane;\n      this.camera.updateProjectionMatrix();\n    }\n    /**\n     * Sets the aspect ratio of the camera\n     */\n\n  }, {\n    key: \"updateAspect\",\n    value: function updateAspect(aspect) {\n      this.camera.aspect = aspect;\n      this.camera.updateProjectionMatrix();\n    }\n    /**\n     * Set the absolute orbital goal of the camera. The change will be\n     * applied over a number of frames depending on configured acceleration and\n     * dampening options.\n     *\n     * Returns true if invoking the method will result in the camera changing\n     * position and/or rotation, otherwise false.\n     */\n\n  }, {\n    key: \"setOrbit\",\n    value: function setOrbit() {\n      var goalTheta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[$goalSpherical].theta;\n      var goalPhi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[$goalSpherical].phi;\n      var goalRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this[$goalSpherical].radius;\n      var _this$$options = this[$options],\n          minimumAzimuthalAngle = _this$$options.minimumAzimuthalAngle,\n          maximumAzimuthalAngle = _this$$options.maximumAzimuthalAngle,\n          minimumPolarAngle = _this$$options.minimumPolarAngle,\n          maximumPolarAngle = _this$$options.maximumPolarAngle,\n          minimumRadius = _this$$options.minimumRadius,\n          maximumRadius = _this$$options.maximumRadius;\n      var _this$$goalSpherical = this[$goalSpherical],\n          theta = _this$$goalSpherical.theta,\n          phi = _this$$goalSpherical.phi,\n          radius = _this$$goalSpherical.radius;\n      var nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n\n      if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {\n        this[$spherical].theta = this[$wrapAngle](this[$spherical].theta - nextTheta) + nextTheta;\n      }\n\n      var nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n      var nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n\n      if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n        return false;\n      }\n\n      this[$goalSpherical].theta = nextTheta;\n      this[$goalSpherical].phi = nextPhi;\n      this[$goalSpherical].radius = nextRadius;\n      this[$goalSpherical].makeSafe();\n      this[$isUserChange] = false;\n      return true;\n    }\n    /**\n     * Subset of setOrbit() above, which only sets the camera's radius.\n     */\n\n  }, {\n    key: \"setRadius\",\n    value: function setRadius(radius) {\n      this[$goalSpherical].radius = radius;\n      this.setOrbit();\n    }\n    /**\n     * Sets the goal field of view for the camera\n     */\n\n  }, {\n    key: \"setFieldOfView\",\n    value: function setFieldOfView(fov) {\n      var _this$$options2 = this[$options],\n          minimumFieldOfView = _this$$options2.minimumFieldOfView,\n          maximumFieldOfView = _this$$options2.maximumFieldOfView;\n      fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n      this[$goalLogFov] = Math.log(fov);\n    }\n    /**\n     * Adjust the orbital position of the camera relative to its current orbital\n     * position. Does not let the theta goal get more than pi ahead of the current\n     * theta, which ensures interpolation continues in the direction of the delta.\n     * The deltaZoom parameter adjusts both the field of view and the orbit radius\n     * such that they progress across their allowed ranges in sync.\n     */\n\n  }, {\n    key: \"adjustOrbit\",\n    value: function adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n      var _this$$goalSpherical2 = this[$goalSpherical],\n          theta = _this$$goalSpherical2.theta,\n          phi = _this$$goalSpherical2.phi,\n          radius = _this$$goalSpherical2.radius;\n      var _this$$options3 = this[$options],\n          minimumRadius = _this$$options3.minimumRadius,\n          maximumRadius = _this$$options3.maximumRadius,\n          minimumFieldOfView = _this$$options3.minimumFieldOfView,\n          maximumFieldOfView = _this$$options3.maximumFieldOfView;\n      var dTheta = this[$spherical].theta - theta;\n      var dThetaLimit = Math.PI - 0.001;\n      var goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n      var goalPhi = phi - deltaPhi;\n      var deltaRatio = deltaZoom === 0 ? 0 : deltaZoom > 0 ? (maximumRadius - radius) / (Math.log(maximumFieldOfView) - this[$goalLogFov]) : (radius - minimumRadius) / (this[$goalLogFov] - Math.log(minimumFieldOfView));\n      var goalRadius = radius + deltaZoom * Math.min(isFinite(deltaRatio) ? deltaRatio : Infinity, maximumRadius - minimumRadius);\n      var handled = this.setOrbit(goalTheta, goalPhi, goalRadius);\n\n      if (deltaZoom !== 0) {\n        var goalLogFov = this[$goalLogFov] + deltaZoom;\n        this.setFieldOfView(Math.exp(goalLogFov));\n        handled = true;\n      }\n\n      return handled;\n    }\n    /**\n     * Move the camera instantly instead of accelerating toward the goal\n     * parameters.\n     */\n\n  }, {\n    key: \"jumpToGoal\",\n    value: function jumpToGoal() {\n      this.update(0, SETTLING_TIME);\n    }\n    /**\n     * Update controls. In most cases, this will result in the camera\n     * interpolating its position and rotation until it lines up with the\n     * designated goal orbital position.\n     *\n     * Time and delta are measured in milliseconds.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(_time, delta) {\n      if (this[$isStationary]()) {\n        return;\n      }\n\n      var _this$$options4 = this[$options],\n          maximumPolarAngle = _this$$options4.maximumPolarAngle,\n          maximumRadius = _this$$options4.maximumRadius;\n      var dTheta = this[$spherical].theta - this[$goalSpherical].theta;\n\n      if (Math.abs(dTheta) > Math.PI && !isFinite(this[$options].minimumAzimuthalAngle) && !isFinite(this[$options].maximumAzimuthalAngle)) {\n        this[$spherical].theta -= Math.sign(dTheta) * 2 * Math.PI;\n      }\n\n      this[$spherical].theta = this[$thetaDamper].update(this[$spherical].theta, this[$goalSpherical].theta, delta, Math.PI);\n      this[$spherical].phi = this[$phiDamper].update(this[$spherical].phi, this[$goalSpherical].phi, delta, maximumPolarAngle);\n      this[$spherical].radius = this[$radiusDamper].update(this[$spherical].radius, this[$goalSpherical].radius, delta, maximumRadius);\n      this[$logFov] = this[$fovDamper].update(this[$logFov], this[$goalLogFov], delta, 1);\n      this[$moveCamera]();\n    }\n  }, {\n    key: (_a = $interactionEnabled, _b = $isUserChange, _c = $isUserPointing, _d = $spherical, _e = $goalSpherical, _f = $thetaDamper, _g = $phiDamper, _h = $radiusDamper, _j = $fovDamper, _k = $pointerIsDown, _l = $lastPointerPosition, $isStationary),\n    value: function value() {\n      return this[$goalSpherical].theta === this[$spherical].theta && this[$goalSpherical].phi === this[$spherical].phi && this[$goalSpherical].radius === this[$spherical].radius && this[$goalLogFov] === this[$logFov];\n    }\n  }, {\n    key: $moveCamera,\n    value: function value() {\n      // Derive the new camera position from the updated spherical:\n      this[$spherical].makeSafe();\n      this.camera.position.setFromSpherical(this[$spherical]);\n      this.camera.setRotationFromEuler(new Euler(this[$spherical].phi - Math.PI / 2, this[$spherical].theta, 0, 'YXZ'));\n\n      if (this.camera.fov !== Math.exp(this[$logFov])) {\n        this.camera.fov = Math.exp(this[$logFov]);\n        this.camera.updateProjectionMatrix();\n      }\n\n      var source = this[$isUserChange] ? ChangeSource.USER_INTERACTION : ChangeSource.NONE;\n      this.dispatchEvent({\n        type: 'change',\n        source: source\n      });\n    }\n  }, {\n    key: $userAdjustOrbit,\n    value: function value(deltaTheta, deltaPhi, deltaZoom) {\n      var handled = this.adjustOrbit(deltaTheta, deltaPhi, deltaZoom);\n      this[$isUserChange] = true; // Always make sure that an initial event is triggered in case there is\n      // contention between user interaction and imperative changes. This initial\n      // event will give external observers that chance to observe that\n      // interaction occurred at all:\n\n      this.dispatchEvent({\n        type: 'change',\n        source: ChangeSource.USER_INTERACTION\n      });\n      return handled;\n    } // Wraps to bewteen -pi and pi\n\n  }, {\n    key: $wrapAngle,\n    value: function value(radians) {\n      var normalized = (radians + Math.PI) / (2 * Math.PI);\n      var wrapped = normalized - Math.floor(normalized);\n      return wrapped * 2 * Math.PI - Math.PI;\n    }\n  }, {\n    key: $pixelLengthToSphericalAngle,\n    value: function value(pixelLength) {\n      return 2 * Math.PI * pixelLength / this.element.clientHeight;\n    }\n  }, {\n    key: $twoTouchDistance,\n    value: function value(touchOne, touchTwo) {\n      var xOne = touchOne.clientX,\n          yOne = touchOne.clientY;\n      var xTwo = touchTwo.clientX,\n          yTwo = touchTwo.clientY;\n      var xDelta = xTwo - xOne;\n      var yDelta = yTwo - yOne;\n      return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n    }\n  }, {\n    key: $handlePointerMove,\n    value: function value(event) {\n      if (!this[$pointerIsDown] || !this[$canInteract]) {\n        return;\n      }\n\n      var handled = false; // NOTE(cdata): We test event.type as some browsers do not have a global\n      // TouchEvent contructor.\n\n      if (TOUCH_EVENT_RE.test(event.type)) {\n        var touches = event.touches;\n\n        switch (this[$touchMode]) {\n          case 'zoom':\n            if (this[$lastTouches].length > 1 && touches.length > 1) {\n              var lastTouchDistance = this[$twoTouchDistance](this[$lastTouches][0], this[$lastTouches][1]);\n              var touchDistance = this[$twoTouchDistance](touches[0], touches[1]);\n              var deltaZoom = ZOOM_SENSITIVITY * (lastTouchDistance - touchDistance) / 10.0;\n              handled = this[$userAdjustOrbit](0, 0, deltaZoom);\n            }\n\n            break;\n\n          case 'rotate':\n            handled = this[$handleSinglePointerMove](touches[0]);\n            break;\n        }\n\n        this[$lastTouches] = touches;\n      } else {\n        handled = this[$handleSinglePointerMove](event);\n      }\n\n      if ((handled || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n        event.preventDefault();\n      }\n\n      ;\n    }\n  }, {\n    key: $handleSinglePointerMove,\n    value: function value(pointer) {\n      var clientX = pointer.clientX,\n          clientY = pointer.clientY;\n      var deltaTheta = this[$pixelLengthToSphericalAngle](clientX - this[$lastPointerPosition].clientX);\n      var deltaPhi = this[$pixelLengthToSphericalAngle](clientY - this[$lastPointerPosition].clientY);\n      this[$lastPointerPosition].clientX = clientX;\n      this[$lastPointerPosition].clientY = clientY;\n\n      if (this[$isUserPointing] === false) {\n        this[$isUserPointing] = true;\n        this.dispatchEvent({\n          type: 'pointer-change-start',\n          pointer: Object.assign({}, pointer)\n        });\n      }\n\n      return this[$userAdjustOrbit](deltaTheta, deltaPhi, 0);\n    }\n  }, {\n    key: $handlePointerDown,\n    value: function value(event) {\n      this[$pointerIsDown] = true;\n      this[$isUserPointing] = false;\n\n      if (TOUCH_EVENT_RE.test(event.type)) {\n        var touches = event.touches;\n\n        switch (touches.length) {\n          default:\n          case 1:\n            this[$touchMode] = 'rotate';\n            this[$handleSinglePointerDown](touches[0]);\n            break;\n\n          case 2:\n            this[$touchMode] = 'zoom';\n            break;\n        }\n\n        this[$lastTouches] = touches;\n      } else {\n        this[$handleSinglePointerDown](event);\n      }\n    }\n  }, {\n    key: $handleSinglePointerDown,\n    value: function value(pointer) {\n      this[$lastPointerPosition].clientX = pointer.clientX;\n      this[$lastPointerPosition].clientY = pointer.clientY;\n      this.element.style.cursor = 'grabbing';\n    }\n  }, {\n    key: $handlePointerUp,\n    value: function value(_event) {\n      this.element.style.cursor = 'grab';\n      this[$pointerIsDown] = false;\n\n      if (this[$isUserPointing]) {\n        this.dispatchEvent({\n          type: 'pointer-change-end',\n          pointer: Object.assign({}, this[$lastPointerPosition])\n        });\n      }\n    }\n  }, {\n    key: $handleWheel,\n    value: function value(event) {\n      if (!this[$canInteract]) {\n        return;\n      }\n\n      var deltaZoom = event.deltaY * ZOOM_SENSITIVITY / 30;\n\n      if ((this[$userAdjustOrbit](0, 0, deltaZoom) || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: $handleKey,\n    value: function value(event) {\n      // We track if the key is actually one we respond to, so as not to\n      // accidentally clober unrelated key inputs when the <model-viewer> has\n      // focus and eventHandlingBehavior is set to 'prevent-all'.\n      var relevantKey = false;\n      var handled = false;\n\n      switch (event.keyCode) {\n        case KeyCode.PAGE_UP:\n          relevantKey = true;\n          handled = this[$userAdjustOrbit](0, 0, ZOOM_SENSITIVITY);\n          break;\n\n        case KeyCode.PAGE_DOWN:\n          relevantKey = true;\n          handled = this[$userAdjustOrbit](0, 0, -1 * ZOOM_SENSITIVITY);\n          break;\n\n        case KeyCode.UP:\n          relevantKey = true;\n          handled = this[$userAdjustOrbit](0, -KEYBOARD_ORBIT_INCREMENT, 0);\n          break;\n\n        case KeyCode.DOWN:\n          relevantKey = true;\n          handled = this[$userAdjustOrbit](0, KEYBOARD_ORBIT_INCREMENT, 0);\n          break;\n\n        case KeyCode.LEFT:\n          relevantKey = true;\n          handled = this[$userAdjustOrbit](-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n          break;\n\n        case KeyCode.RIGHT:\n          relevantKey = true;\n          handled = this[$userAdjustOrbit](KEYBOARD_ORBIT_INCREMENT, 0, 0);\n          break;\n      }\n\n      if (relevantKey && (handled || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"interactionEnabled\",\n    get: function get() {\n      return this[$interactionEnabled];\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this[$options];\n    }\n  }, {\n    key: $canInteract,\n    get: function get() {\n      if (this[$options].interactionPolicy == 'allow-when-focused') {\n        var rootNode = this.element.getRootNode();\n        return rootNode.activeElement === this.element;\n      }\n\n      return this[$options].interactionPolicy === 'always-allow';\n    }\n  }]);\n\n  return SmoothControls;\n}(EventDispatcher);","map":{"version":3,"sources":["../../src/three-components/SmoothControls.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Euler, Event as ThreeEvent, EventDispatcher, PerspectiveCamera, Spherical} from 'three';\n\nimport {clamp} from '../utilities.js';\nimport {Damper, SETTLING_TIME} from './Damper.js';\n\nexport type EventHandlingBehavior = 'prevent-all'|'prevent-handled';\nexport type InteractionPolicy = 'always-allow'|'allow-when-focused';\nexport type TouchMode = 'rotate'|'zoom';\n\nexport interface Pointer {\n  clientX: number, clientY: number,\n}\n\nexport interface SmoothControlsOptions {\n  // The closest the camera can be to the target\n  minimumRadius?: number;\n  // The farthest the camera can be from the target\n  maximumRadius?: number;\n  // The minimum angle between model-up and the camera polar position\n  minimumPolarAngle?: number;\n  // The maximum angle between model-up and the camera polar position\n  maximumPolarAngle?: number;\n  // The minimum angle between model-forward and the camera azimuthal position\n  minimumAzimuthalAngle?: number;\n  // The maximum angle between model-forward and the camera azimuthal position\n  maximumAzimuthalAngle?: number;\n  // The minimum camera field of view in degrees\n  minimumFieldOfView?: number;\n  // The maximum camera field of view in degrees\n  maximumFieldOfView?: number;\n  // Controls when events will be cancelled (always, or only when handled)\n  eventHandlingBehavior?: EventHandlingBehavior;\n  // Controls when interaction is allowed (always, or only when focused)\n  interactionPolicy?: InteractionPolicy;\n}\n\nexport const DEFAULT_OPTIONS = Object.freeze<SmoothControlsOptions>({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  eventHandlingBehavior: 'prevent-all',\n  interactionPolicy: 'always-allow'\n});\n\n// Internal orbital position state\nconst $spherical = Symbol('spherical');\nconst $goalSpherical = Symbol('goalSpherical');\nconst $thetaDamper = Symbol('thetaDamper');\nconst $phiDamper = Symbol('phiDamper');\nconst $radiusDamper = Symbol('radiusDamper');\nconst $logFov = Symbol('fov');\nconst $goalLogFov = Symbol('goalLogFov');\nconst $fovDamper = Symbol('fovDamper');\n\nconst $options = Symbol('options');\nconst $touchMode = Symbol('touchMode');\nconst $canInteract = Symbol('canInteract');\nconst $interactionEnabled = Symbol('interactionEnabled');\nconst $userAdjustOrbit = Symbol('userAdjustOrbit');\nconst $isUserChange = Symbol('isUserChange');\nconst $isStationary = Symbol('isMoving');\nconst $moveCamera = Symbol('moveCamera');\nconst $isUserPointing = Symbol('isUserPointing');\n\n// Pointer state\nconst $pointerIsDown = Symbol('pointerIsDown');\nconst $lastPointerPosition = Symbol('lastPointerPosition');\nconst $lastTouches = Symbol('lastTouches');\n\n// Value conversion methods\nconst $pixelLengthToSphericalAngle = Symbol('pixelLengthToSphericalAngle');\nconst $twoTouchDistance = Symbol('twoTouchDistance');\nconst $wrapAngle = Symbol('wrapAngle');\n\n// Event handlers\nconst $onMouseMove = Symbol('onMouseMove');\nconst $onMouseDown = Symbol('onMouseDown');\nconst $onMouseUp = Symbol('onMouseUp');\nconst $onTouchStart = Symbol('onTouchStart');\nconst $onTouchEnd = Symbol('onTouchEnd');\nconst $onTouchMove = Symbol('onTouchMove');\nconst $onWheel = Symbol('onWheel');\nconst $onKeyDown = Symbol('onKeyDown');\nconst $handlePointerMove = Symbol('handlePointerMove');\nconst $handleSinglePointerMove = Symbol('handleSinglePointerMove');\nconst $handlePointerDown = Symbol('handlePointerDown');\nconst $handleSinglePointerDown = Symbol('handleSinglePointerDown');\nconst $handlePointerUp = Symbol('handlePointerUp');\nconst $handleWheel = Symbol('handleWheel');\nconst $handleKey = Symbol('handleKey');\n\n// Constants\nconst TOUCH_EVENT_RE = /^touch(start|end|move)$/;\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\n\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\n\nexport type ChangeSource = 'user-interaction'|'none';\n\nexport const ChangeSource: {[index: string]: ChangeSource} = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none'\n};\n\n/**\n * ChangEvents are dispatched whenever the camera position or orientation has\n * changed\n */\nexport interface ChangeEvent extends ThreeEvent {\n  /**\n   * determines what was the originating reason for the change event eg user or\n   * none\n   */\n  source: ChangeSource,\n}\n\nexport interface PointerChangeEvent extends ThreeEvent {\n  type: 'pointer-change-start'|'pointer-change-end';\n  pointer: Pointer;\n}\n\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nexport class SmoothControls extends EventDispatcher {\n  private[$interactionEnabled]: boolean = false;\n\n  private[$options]: SmoothControlsOptions;\n  private[$isUserChange] = false;\n  private[$isUserPointing] = false;\n\n  private[$spherical] = new Spherical();\n  private[$goalSpherical] = new Spherical();\n  private[$thetaDamper] = new Damper();\n  private[$phiDamper] = new Damper();\n  private[$radiusDamper] = new Damper();\n  private[$logFov]: number;\n  private[$goalLogFov]: number;\n  private[$fovDamper] = new Damper();\n\n  private[$pointerIsDown] = false;\n  private[$lastPointerPosition]: Pointer = {\n    clientX: 0,\n    clientY: 0,\n  };\n  private[$lastTouches]: TouchList;\n  private[$touchMode]: TouchMode;\n\n  private[$onMouseMove]: (event: Event) => void;\n  private[$onMouseDown]: (event: Event) => void;\n  private[$onMouseUp]: (event: Event) => void;\n  private[$onWheel]: (event: Event) => void;\n  private[$onKeyDown]: (event: Event) => void;\n\n  private[$onTouchStart]: (event: Event) => void;\n  private[$onTouchEnd]: (event: Event) => void;\n  private[$onTouchMove]: (event: Event) => void;\n\n  constructor(\n      readonly camera: PerspectiveCamera, readonly element: HTMLElement) {\n    super();\n\n    this[$onMouseMove] = (event: Event) =>\n        this[$handlePointerMove](event as MouseEvent);\n    this[$onMouseDown] = (event: Event) =>\n        this[$handlePointerDown](event as MouseEvent);\n    this[$onMouseUp] = (event: Event) =>\n        this[$handlePointerUp](event as MouseEvent);\n    this[$onWheel] = (event: Event) => this[$handleWheel](event as WheelEvent);\n    this[$onKeyDown] = (event: Event) =>\n        this[$handleKey](event as KeyboardEvent);\n    this[$onTouchStart] = (event: Event) =>\n        this[$handlePointerDown](event as TouchEvent);\n    this[$onTouchEnd] = (event: Event) =>\n        this[$handlePointerUp](event as TouchEvent);\n    this[$onTouchMove] = (event: Event) =>\n        this[$handlePointerMove](event as TouchEvent);\n\n    this[$options] = Object.assign({}, DEFAULT_OPTIONS);\n\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n\n  get interactionEnabled(): boolean {\n    return this[$interactionEnabled];\n  }\n\n  enableInteraction() {\n    if (this[$interactionEnabled] === false) {\n      const {element} = this;\n      element.addEventListener('mousemove', this[$onMouseMove]);\n      element.addEventListener('mousedown', this[$onMouseDown]);\n      element.addEventListener('wheel', this[$onWheel]);\n      element.addEventListener('keydown', this[$onKeyDown]);\n      element.addEventListener('touchstart', this[$onTouchStart]);\n      element.addEventListener('touchmove', this[$onTouchMove]);\n\n      self.addEventListener('mouseup', this[$onMouseUp]);\n      self.addEventListener('touchend', this[$onTouchEnd]);\n\n      this.element.style.cursor = 'grab';\n      this[$interactionEnabled] = true;\n    }\n  }\n\n  disableInteraction() {\n    if (this[$interactionEnabled] === true) {\n      const {element} = this;\n\n      element.removeEventListener('mousemove', this[$onMouseMove]);\n      element.removeEventListener('mousedown', this[$onMouseDown]);\n      element.removeEventListener('wheel', this[$onWheel]);\n      element.removeEventListener('keydown', this[$onKeyDown]);\n      element.removeEventListener('touchstart', this[$onTouchStart]);\n      element.removeEventListener('touchmove', this[$onTouchMove]);\n\n      self.removeEventListener('mouseup', this[$onMouseUp]);\n      self.removeEventListener('touchend', this[$onTouchEnd]);\n\n      element.style.cursor = '';\n      this[$interactionEnabled] = false;\n    }\n  }\n\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n  get options() {\n    return this[$options];\n  }\n\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n  getCameraSpherical(target: Spherical = new Spherical()) {\n    return target.copy(this[$spherical]);\n  }\n\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n  getFieldOfView(): number {\n    return this.camera.fov;\n  }\n\n  /**\n   * Configure the options of the controls. Configured options will be\n   * merged with whatever options have already been configured for this\n   * controls instance.\n   */\n  applyOptions(options: SmoothControlsOptions) {\n    Object.assign(this[$options], options);\n    // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this[$goalLogFov]));\n  }\n\n  /**\n   * Sets the near and far planes of the camera.\n   */\n  updateNearFar(nearPlane: number, farPlane: number) {\n    this.camera.near = Math.max(nearPlane, farPlane / 1000);\n    this.camera.far = farPlane;\n    this.camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Sets the aspect ratio of the camera\n   */\n  updateAspect(aspect: number) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n  setOrbit(\n      goalTheta: number = this[$goalSpherical].theta,\n      goalPhi: number = this[$goalSpherical].phi,\n      goalRadius: number = this[$goalSpherical].radius): boolean {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius\n    } = this[$options];\n\n    const {theta, phi, radius} = this[$goalSpherical];\n\n    const nextTheta =\n        clamp(goalTheta, minimumAzimuthalAngle!, maximumAzimuthalAngle!);\n    if (!isFinite(minimumAzimuthalAngle!) &&\n        !isFinite(maximumAzimuthalAngle!)) {\n      this[$spherical].theta =\n          this[$wrapAngle](this[$spherical].theta - nextTheta) + nextTheta;\n    }\n\n    const nextPhi = clamp(goalPhi, minimumPolarAngle!, maximumPolarAngle!);\n    const nextRadius = clamp(goalRadius, minimumRadius!, maximumRadius!);\n\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n\n    this[$goalSpherical].theta = nextTheta;\n    this[$goalSpherical].phi = nextPhi;\n    this[$goalSpherical].radius = nextRadius;\n    this[$goalSpherical].makeSafe();\n\n    this[$isUserChange] = false;\n\n    return true;\n  }\n\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n  setRadius(radius: number) {\n    this[$goalSpherical].radius = radius;\n    this.setOrbit();\n  }\n\n  /**\n   * Sets the goal field of view for the camera\n   */\n  setFieldOfView(fov: number) {\n    const {minimumFieldOfView, maximumFieldOfView} = this[$options];\n    fov = clamp(fov, minimumFieldOfView!, maximumFieldOfView!);\n    this[$goalLogFov] = Math.log(fov);\n  }\n\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n  adjustOrbit(deltaTheta: number, deltaPhi: number, deltaZoom: number):\n      boolean {\n    const {theta, phi, radius} = this[$goalSpherical];\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this[$options];\n\n    const dTheta = this[$spherical].theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta =\n        theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n\n    const deltaRatio = deltaZoom === 0 ?\n        0 :\n        deltaZoom > 0 ? (maximumRadius! - radius) /\n                (Math.log(maximumFieldOfView!) - this[$goalLogFov]) :\n                        (radius - minimumRadius!) /\n                (this[$goalLogFov] - Math.log(minimumFieldOfView!));\n\n    const goalRadius = radius +\n        deltaZoom *\n            Math.min(\n                isFinite(deltaRatio) ? deltaRatio : Infinity,\n                maximumRadius! - minimumRadius!);\n    let handled = this.setOrbit(goalTheta, goalPhi, goalRadius);\n\n    if (deltaZoom !== 0) {\n      const goalLogFov = this[$goalLogFov] + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n      handled = true;\n    }\n\n    return handled;\n  }\n\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n  update(_time: number, delta: number) {\n    if (this[$isStationary]()) {\n      return;\n    }\n    const {maximumPolarAngle, maximumRadius} = this[$options];\n\n    const dTheta = this[$spherical].theta - this[$goalSpherical].theta;\n    if (Math.abs(dTheta) > Math.PI &&\n        !isFinite(this[$options].minimumAzimuthalAngle!) &&\n        !isFinite(this[$options].maximumAzimuthalAngle!)) {\n      this[$spherical].theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n\n    this[$spherical].theta = this[$thetaDamper].update(\n        this[$spherical].theta, this[$goalSpherical].theta, delta, Math.PI);\n\n    this[$spherical].phi = this[$phiDamper].update(\n        this[$spherical].phi,\n        this[$goalSpherical].phi,\n        delta,\n        maximumPolarAngle!);\n\n    this[$spherical].radius = this[$radiusDamper].update(\n        this[$spherical].radius,\n        this[$goalSpherical].radius,\n        delta,\n        maximumRadius!);\n\n    this[$logFov] =\n        this[$fovDamper].update(this[$logFov], this[$goalLogFov], delta, 1);\n\n    this[$moveCamera]();\n  }\n\n  private[$isStationary](): boolean {\n    return this[$goalSpherical].theta === this[$spherical].theta &&\n        this[$goalSpherical].phi === this[$spherical].phi &&\n        this[$goalSpherical].radius === this[$spherical].radius &&\n        this[$goalLogFov] === this[$logFov];\n  }\n\n  private[$moveCamera]() {\n    // Derive the new camera position from the updated spherical:\n    this[$spherical].makeSafe();\n    this.camera.position.setFromSpherical(this[$spherical]);\n    this.camera.setRotationFromEuler(new Euler(\n        this[$spherical].phi - Math.PI / 2, this[$spherical].theta, 0, 'YXZ'));\n\n    if (this.camera.fov !== Math.exp(this[$logFov])) {\n      this.camera.fov = Math.exp(this[$logFov]);\n      this.camera.updateProjectionMatrix();\n    }\n\n    const source =\n        this[$isUserChange] ? ChangeSource.USER_INTERACTION : ChangeSource.NONE;\n\n    this.dispatchEvent({type: 'change', source});\n  }\n\n  private get[$canInteract](): boolean {\n    if (this[$options].interactionPolicy == 'allow-when-focused') {\n      const rootNode = this.element.getRootNode() as Document | ShadowRoot;\n      return rootNode.activeElement === this.element;\n    }\n\n    return this[$options].interactionPolicy === 'always-allow';\n  }\n\n  private[$userAdjustOrbit](\n      deltaTheta: number, deltaPhi: number, deltaZoom: number): boolean {\n    const handled = this.adjustOrbit(deltaTheta, deltaPhi, deltaZoom);\n\n    this[$isUserChange] = true;\n    // Always make sure that an initial event is triggered in case there is\n    // contention between user interaction and imperative changes. This initial\n    // event will give external observers that chance to observe that\n    // interaction occurred at all:\n    this.dispatchEvent({type: 'change', source: ChangeSource.USER_INTERACTION});\n\n    return handled;\n  }\n\n  // Wraps to bewteen -pi and pi\n  private[$wrapAngle](radians: number): number {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n\n  private[$pixelLengthToSphericalAngle](pixelLength: number): number {\n    return 2 * Math.PI * pixelLength / this.element.clientHeight;\n  }\n\n  private[$twoTouchDistance](touchOne: Touch, touchTwo: Touch): number {\n    const {clientX: xOne, clientY: yOne} = touchOne;\n    const {clientX: xTwo, clientY: yTwo} = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n\n  private[$handlePointerMove](event: MouseEvent|TouchEvent) {\n    if (!this[$pointerIsDown] || !this[$canInteract]) {\n      return;\n    }\n\n    let handled = false;\n\n    // NOTE(cdata): We test event.type as some browsers do not have a global\n    // TouchEvent contructor.\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const {touches} = event as TouchEvent;\n\n      switch (this[$touchMode]) {\n        case 'zoom':\n          if (this[$lastTouches].length > 1 && touches.length > 1) {\n            const lastTouchDistance = this[$twoTouchDistance](\n                this[$lastTouches][0], this[$lastTouches][1]);\n            const touchDistance =\n                this[$twoTouchDistance](touches[0], touches[1]);\n            const deltaZoom =\n                ZOOM_SENSITIVITY * (lastTouchDistance - touchDistance) / 10.0;\n\n            handled = this[$userAdjustOrbit](0, 0, deltaZoom);\n          }\n\n          break;\n        case 'rotate':\n          handled = this[$handleSinglePointerMove](touches[0]);\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      handled = this[$handleSinglePointerMove](event as MouseEvent);\n    }\n\n    if ((handled || this[$options].eventHandlingBehavior === 'prevent-all') &&\n        event.cancelable) {\n      event.preventDefault();\n    };\n  }\n\n  private[$handleSinglePointerMove](pointer: Pointer): boolean {\n    const {clientX, clientY} = pointer;\n    const deltaTheta = this[$pixelLengthToSphericalAngle](\n        clientX - this[$lastPointerPosition].clientX);\n    const deltaPhi = this[$pixelLengthToSphericalAngle](\n        clientY - this[$lastPointerPosition].clientY);\n\n    this[$lastPointerPosition].clientX = clientX;\n    this[$lastPointerPosition].clientY = clientY;\n\n    if (this[$isUserPointing] === false) {\n      this[$isUserPointing] = true;\n      this.dispatchEvent({type: 'pointer-change-start', pointer: {...pointer}});\n    }\n\n    return this[$userAdjustOrbit](deltaTheta, deltaPhi, 0);\n  }\n\n  private[$handlePointerDown](event: MouseEvent|TouchEvent) {\n    this[$pointerIsDown] = true;\n    this[$isUserPointing] = false;\n\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const {touches} = event as TouchEvent;\n\n      switch (touches.length) {\n        default:\n        case 1:\n          this[$touchMode] = 'rotate';\n          this[$handleSinglePointerDown](touches[0]);\n          break;\n        case 2:\n          this[$touchMode] = 'zoom';\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      this[$handleSinglePointerDown](event as MouseEvent);\n    }\n  }\n\n  private[$handleSinglePointerDown](pointer: Pointer) {\n    this[$lastPointerPosition].clientX = pointer.clientX;\n    this[$lastPointerPosition].clientY = pointer.clientY;\n    this.element.style.cursor = 'grabbing';\n  }\n\n  private[$handlePointerUp](_event: MouseEvent|TouchEvent) {\n    this.element.style.cursor = 'grab';\n    this[$pointerIsDown] = false;\n\n    if (this[$isUserPointing]) {\n      this.dispatchEvent({\n        type: 'pointer-change-end',\n        pointer: {...this[$lastPointerPosition]}\n      });\n    }\n  }\n\n  private[$handleWheel](event: Event) {\n    if (!this[$canInteract]) {\n      return;\n    }\n\n    const deltaZoom = (event as WheelEvent).deltaY * ZOOM_SENSITIVITY / 30;\n\n    if ((this[$userAdjustOrbit](0, 0, deltaZoom) ||\n         this[$options].eventHandlingBehavior === 'prevent-all') &&\n        event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  private[$handleKey](event: KeyboardEvent) {\n    // We track if the key is actually one we respond to, so as not to\n    // accidentally clober unrelated key inputs when the <model-viewer> has\n    // focus and eventHandlingBehavior is set to 'prevent-all'.\n    let relevantKey = false;\n    let handled = false;\n\n    switch (event.keyCode) {\n      case KeyCode.PAGE_UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, ZOOM_SENSITIVITY);\n        break;\n      case KeyCode.PAGE_DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, -1 * ZOOM_SENSITIVITY);\n        break;\n      case KeyCode.UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case KeyCode.DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case KeyCode.LEFT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      case KeyCode.RIGHT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n    }\n\n    if (relevantKey &&\n        (handled || this[$options].eventHandlingBehavior === 'prevent-all') &&\n        event.cancelable) {\n      event.preventDefault();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}