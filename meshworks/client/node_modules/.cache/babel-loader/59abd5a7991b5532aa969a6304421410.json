{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nimport { PerspectiveCamera, Raycaster, Scene, Vector3 } from 'three';\nimport { USE_OFFSCREEN_CANVAS } from '../constants.js';\nimport { $renderer } from '../model-viewer-base.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nimport Model, { DEFAULT_FOV_DEG } from './Model.js';\nexport var IlluminationRole = {\n  Primary: 'primary',\n  Secondary: 'secondary'\n};\nvar DEFAULT_TAN_FOV = Math.tan(DEFAULT_FOV_DEG / 2 * Math.PI / 180);\nvar raycaster = new Raycaster();\nvar vector3 = new Vector3();\nvar $paused = Symbol('paused');\n/**\n * A THREE.Scene object that takes a Model and CanvasHTMLElement and\n * constructs a framed scene based off of the canvas dimensions.\n * Provides lights and cameras to be used in a renderer.\n */\n\nexport var ModelScene = /*#__PURE__*/function (_Scene) {\n  _inherits(ModelScene, _Scene);\n\n  var _super = _createSuper(ModelScene);\n\n  function ModelScene(_ref) {\n    var _this;\n\n    var canvas = _ref.canvas,\n        element = _ref.element,\n        width = _ref.width,\n        height = _ref.height;\n\n    _classCallCheck(this, ModelScene);\n\n    _this = _super.call(this);\n    _this[_a] = false;\n    _this.aspect = 1;\n    _this.shadowIntensity = 0;\n    _this.shadowSoftness = 1;\n    _this.width = 1;\n    _this.height = 1;\n    _this.isDirty = false;\n    _this.context = null;\n    _this.exposure = 1;\n    _this.canScale = true;\n    _this.framedFieldOfView = DEFAULT_FOV_DEG; // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n\n    _this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    _this.goalTarget = new Vector3();\n    _this.targetDamperX = new Damper();\n    _this.targetDamperY = new Damper();\n    _this.targetDamperZ = new Damper();\n    _this.name = 'ModelScene';\n    _this.element = element;\n    _this.canvas = canvas;\n    _this.model = new Model(); // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n\n    _this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    _this.camera.name = 'MainCamera';\n    _this.activeCamera = _this.camera;\n\n    _this.add(_this.model);\n\n    _this.setSize(width, height);\n\n    _this.model.addEventListener('model-load', function (event) {\n      return _this.onModelLoad(event);\n    });\n\n    return _this;\n  }\n\n  _createClass(ModelScene, [{\n    key: \"pause\",\n    value: function pause() {\n      this[$paused] = true;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this[$paused] = false;\n    }\n    /**\n     * Function to create the context lazily, as when there is only one\n     * <model-viewer> element, the renderer's 3D context can be displayed\n     * directly. This extra context is necessary to copy the renderings into when\n     * there are more than one.\n     */\n\n  }, {\n    key: \"createContext\",\n    value: function createContext() {\n      if (USE_OFFSCREEN_CANVAS) {\n        this.context = this.canvas.getContext('bitmaprenderer');\n      } else {\n        this.context = this.canvas.getContext('2d');\n      }\n    }\n    /**\n     * Sets the model via URL.\n     */\n\n  }, {\n    key: \"setModelSource\",\n    value: function () {\n      var _setModelSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, progressCallback) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this.model.setSource(source, progressCallback);\n\n              case 3:\n                _context.next = 8;\n                break;\n\n              case 5:\n                _context.prev = 5;\n                _context.t0 = _context[\"catch\"](0);\n                throw new Error(\"Could not set model source to '\".concat(source, \"': \").concat(_context.t0.message));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n\n      function setModelSource(_x, _x2) {\n        return _setModelSource.apply(this, arguments);\n      }\n\n      return setModelSource;\n    }()\n    /**\n     * Receives the size of the 2D canvas element to make according\n     * adjustments in the scene.\n     */\n\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      if (width !== this.width || height !== this.height) {\n        this.width = Math.max(width, 1);\n        this.height = Math.max(height, 1);\n        this.aspect = this.width / this.height;\n        this.frameModel();\n        var renderer = this.element[$renderer];\n        renderer.expandTo(this.width, this.height);\n        this.canvas.width = renderer.width;\n        this.canvas.height = renderer.height; // Immediately queue a render to happen at microtask timing. This is\n        // necessary because setting the width and height of the canvas has the\n        // side-effect of clearing it, and also if we wait for the next rAF to\n        // render again we might get hit with yet-another-resize, or worse we\n        // may not actually be marked as dirty and so render will just not\n        // happen. Queuing a render to happen here means we will render twice on\n        // a resize frame, but it avoids most of the visual artifacts associated\n        // with other potential mitigations for this problem. See discussion in\n        // https://github.com/GoogleWebComponents/model-viewer/pull/619 for\n        // additional considerations.\n\n        Promise.resolve().then(function () {\n          renderer.render(performance.now());\n        });\n      }\n    }\n    /**\n     * Set's the framedFieldOfView based on the aspect ratio of the window in\n     * order to keep the model fully visible at any camera orientation.\n     */\n\n  }, {\n    key: \"frameModel\",\n    value: function frameModel() {\n      var vertical = DEFAULT_TAN_FOV * Math.max(1, this.model.fieldOfViewAspect / this.aspect);\n      this.framedFieldOfView = 2 * Math.atan(vertical) * 180 / Math.PI;\n    }\n    /**\n     * Returns the size of the corresponding canvas element.\n     */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n    /**\n     * Returns the current camera.\n     */\n\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.activeCamera;\n    }\n    /**\n     * Sets the passed in camera to be used for rendering.\n     */\n\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.activeCamera = camera;\n    }\n    /**\n     * Called when the model's contents have loaded, or changed.\n     */\n\n  }, {\n    key: \"onModelLoad\",\n    value: function onModelLoad(event) {\n      this.frameModel();\n      this.setShadowIntensity(this.shadowIntensity);\n      this.isDirty = true;\n      this.dispatchEvent({\n        type: 'model-load',\n        url: event.url\n      });\n    }\n    /**\n     * Sets the point in model coordinates the model should orbit/pivot around.\n     */\n\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(modelX, modelY, modelZ) {\n      this.goalTarget.set(-modelX, -modelY, -modelZ);\n    }\n    /**\n     * Gets the point in model coordinates the model should orbit/pivot around.\n     */\n\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return vector3.copy(this.goalTarget).multiplyScalar(-1);\n    }\n    /**\n     * Shifts the model to the target point immediately instead of easing in.\n     */\n\n  }, {\n    key: \"jumpToGoal\",\n    value: function jumpToGoal() {\n      this.updateTarget(SETTLING_TIME);\n    }\n    /**\n     * This should be called every frame with the frame delta to cause the target\n     * to transition to its set point.\n     */\n\n  }, {\n    key: \"updateTarget\",\n    value: function updateTarget(delta) {\n      var goal = this.goalTarget;\n      var target = this.model.position;\n\n      if (!goal.equals(target)) {\n        var radius = this.model.idealCameraDistance;\n        var x = target.x,\n            y = target.y,\n            z = target.z;\n        x = this.targetDamperX.update(x, goal.x, delta, radius);\n        y = this.targetDamperY.update(y, goal.y, delta, radius);\n        z = this.targetDamperZ.update(z, goal.z, delta, radius);\n        this.model.position.set(x, y, z);\n        this.isDirty = true;\n      }\n    }\n    /**\n     * Yaw the +z (front) of the model toward the indicated world coordinates.\n     */\n\n  }, {\n    key: \"pointTowards\",\n    value: function pointTowards(worldX, worldZ) {\n      var _this$position = this.position,\n          x = _this$position.x,\n          z = _this$position.z;\n      this.yaw = Math.atan2(worldX - x, worldZ - z);\n    }\n    /**\n     * Yaw is the scene's orientation about the y-axis, around the rotation\n     * center.\n     */\n\n  }, {\n    key: \"setShadowIntensity\",\n\n    /**\n     * Sets the shadow's intensity, lazily creating the shadow as necessary.\n     */\n    value: function setShadowIntensity(shadowIntensity) {\n      shadowIntensity = Math.max(shadowIntensity, 0);\n      this.shadowIntensity = shadowIntensity;\n\n      if (this.model.hasModel()) {\n        this.model.setShadowIntensity(shadowIntensity, this.shadowSoftness);\n      }\n    }\n    /**\n     * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n     * shadow's resolution. This involves reallocation, so it should not be\n     * changed frequently. Softer shadows are cheaper to render.\n     */\n\n  }, {\n    key: \"setShadowSoftness\",\n    value: function setShadowSoftness(softness) {\n      this.shadowSoftness = softness;\n      this.model.setShadowSoftness(softness);\n    }\n    /**\n     * This method returns the world position and model-space normal of the point\n     * on the mesh corresponding to the input pixel coordinates given relative to\n     * the model-viewer element. If the mesh is not hit, the result is null.\n     */\n\n  }, {\n    key: \"positionAndNormalFromPoint\",\n    value: function positionAndNormalFromPoint(pixelPosition) {\n      var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n      raycaster.setFromCamera(pixelPosition, this.getCamera());\n      var hits = raycaster.intersectObject(object, true);\n\n      if (hits.length === 0) {\n        return null;\n      }\n\n      var hit = hits[0];\n\n      if (hit.face == null) {\n        return null;\n      }\n\n      return {\n        position: hit.point,\n        normal: hit.face.normal\n      };\n    }\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this[$paused];\n    }\n  }, {\n    key: \"yaw\",\n    set: function set(radiansY) {\n      this.rotation.y = radiansY;\n      this.model.setShadowRotation(radiansY);\n      this.isDirty = true;\n    },\n    get: function get() {\n      return this.rotation.y;\n    }\n  }]);\n\n  return ModelScene;\n}(Scene);\n_a = $paused;","map":{"version":3,"sources":["../../src/three-components/ModelScene.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Camera, Event as ThreeEvent, Object3D, PerspectiveCamera, Raycaster, Scene, Vector2, Vector3} from 'three';\n\nimport {USE_OFFSCREEN_CANVAS} from '../constants.js';\nimport ModelViewerElementBase, {$renderer} from '../model-viewer-base.js';\n\nimport {Damper, SETTLING_TIME} from './Damper.js';\nimport Model, {DEFAULT_FOV_DEG} from './Model.js';\n\nexport interface ModelLoadEvent extends ThreeEvent {\n  url: string\n}\n\nexport interface ModelSceneConfig {\n  element: ModelViewerElementBase;\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n}\n\nexport type IlluminationRole = 'primary'|'secondary'\n\nexport const IlluminationRole: {[index: string]: IlluminationRole} = {\n  Primary: 'primary',\n  Secondary: 'secondary'\n};\n\nconst DEFAULT_TAN_FOV = Math.tan((DEFAULT_FOV_DEG / 2) * Math.PI / 180);\n\nconst raycaster = new Raycaster();\nconst vector3 = new Vector3();\n\nconst $paused = Symbol('paused');\n\n/**\n * A THREE.Scene object that takes a Model and CanvasHTMLElement and\n * constructs a framed scene based off of the canvas dimensions.\n * Provides lights and cameras to be used in a renderer.\n */\nexport class ModelScene extends Scene {\n  private[$paused]: boolean = false;\n\n  public aspect = 1;\n  public canvas: HTMLCanvasElement;\n  public shadowIntensity = 0;\n  public shadowSoftness = 1;\n  public width = 1;\n  public height = 1;\n  public isDirty: boolean = false;\n  public element: ModelViewerElementBase;\n  public context: CanvasRenderingContext2D|ImageBitmapRenderingContext|null =\n      null;\n  public exposure = 1;\n  public model: Model;\n  public canScale = true;\n  public framedFieldOfView = DEFAULT_FOV_DEG;\n  public activeCamera: Camera;\n  // These default camera values are never used, as they are reset once the\n  // model is loaded and framing is computed.\n  public camera = new PerspectiveCamera(45, 1, 0.1, 100);\n\n  private goalTarget = new Vector3();\n  private targetDamperX = new Damper();\n  private targetDamperY = new Damper();\n  private targetDamperZ = new Damper();\n\n  constructor({canvas, element, width, height}: ModelSceneConfig) {\n    super();\n\n    this.name = 'ModelScene';\n\n    this.element = element;\n    this.canvas = canvas;\n    this.model = new Model();\n\n    // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.camera.name = 'MainCamera';\n\n    this.activeCamera = this.camera;\n\n    this.add(this.model);\n\n    this.setSize(width, height);\n\n    this.model.addEventListener(\n        'model-load', (event: any) => this.onModelLoad(event));\n  }\n\n  get paused() {\n    return this[$paused];\n  }\n\n  pause() {\n    this[$paused] = true;\n  }\n\n  resume() {\n    this[$paused] = false;\n  }\n\n  /**\n   * Function to create the context lazily, as when there is only one\n   * <model-viewer> element, the renderer's 3D context can be displayed\n   * directly. This extra context is necessary to copy the renderings into when\n   * there are more than one.\n   */\n  createContext() {\n    if (USE_OFFSCREEN_CANVAS) {\n      this.context = this.canvas.getContext('bitmaprenderer')!;\n    } else {\n      this.context = this.canvas.getContext('2d')!;\n    }\n  }\n\n  /**\n   * Sets the model via URL.\n   */\n  async setModelSource(\n      source: string|null, progressCallback?: (progress: number) => void) {\n    try {\n      await this.model.setSource(source, progressCallback);\n    } catch (e) {\n      throw new Error(\n          `Could not set model source to '${source}': ${e.message}`);\n    }\n  }\n\n  /**\n   * Receives the size of the 2D canvas element to make according\n   * adjustments in the scene.\n   */\n  setSize(width: number, height: number) {\n    if (width !== this.width || height !== this.height) {\n      this.width = Math.max(width, 1);\n      this.height = Math.max(height, 1);\n\n      this.aspect = this.width / this.height;\n      this.frameModel();\n\n      const renderer = this.element[$renderer];\n      renderer.expandTo(this.width, this.height);\n      this.canvas.width = renderer.width;\n      this.canvas.height = renderer.height;\n\n      // Immediately queue a render to happen at microtask timing. This is\n      // necessary because setting the width and height of the canvas has the\n      // side-effect of clearing it, and also if we wait for the next rAF to\n      // render again we might get hit with yet-another-resize, or worse we\n      // may not actually be marked as dirty and so render will just not\n      // happen. Queuing a render to happen here means we will render twice on\n      // a resize frame, but it avoids most of the visual artifacts associated\n      // with other potential mitigations for this problem. See discussion in\n      // https://github.com/GoogleWebComponents/model-viewer/pull/619 for\n      // additional considerations.\n      Promise.resolve().then(() => {\n        renderer.render(performance.now());\n      });\n    }\n  }\n\n  /**\n   * Set's the framedFieldOfView based on the aspect ratio of the window in\n   * order to keep the model fully visible at any camera orientation.\n   */\n  frameModel() {\n    const vertical = DEFAULT_TAN_FOV *\n        Math.max(1, this.model.fieldOfViewAspect / this.aspect);\n    this.framedFieldOfView = 2 * Math.atan(vertical) * 180 / Math.PI;\n  }\n\n  /**\n   * Returns the size of the corresponding canvas element.\n   */\n  getSize(): {width: number, height: number} {\n    return {width: this.width, height: this.height};\n  }\n\n  /**\n   * Returns the current camera.\n   */\n  getCamera(): Camera {\n    return this.activeCamera;\n  }\n\n  /**\n   * Sets the passed in camera to be used for rendering.\n   */\n  setCamera(camera: Camera) {\n    this.activeCamera = camera;\n  }\n\n  /**\n   * Called when the model's contents have loaded, or changed.\n   */\n  onModelLoad(event: {url: string}) {\n    this.frameModel();\n    this.setShadowIntensity(this.shadowIntensity);\n    this.isDirty = true;\n    this.dispatchEvent({type: 'model-load', url: event.url});\n  }\n\n  /**\n   * Sets the point in model coordinates the model should orbit/pivot around.\n   */\n  setTarget(modelX: number, modelY: number, modelZ: number) {\n    this.goalTarget.set(-modelX, -modelY, -modelZ);\n  }\n\n  /**\n   * Gets the point in model coordinates the model should orbit/pivot around.\n   */\n  getTarget(): Vector3 {\n    return vector3.copy(this.goalTarget).multiplyScalar(-1);\n  }\n\n  /**\n   * Shifts the model to the target point immediately instead of easing in.\n   */\n  jumpToGoal() {\n    this.updateTarget(SETTLING_TIME);\n  }\n\n  /**\n   * This should be called every frame with the frame delta to cause the target\n   * to transition to its set point.\n   */\n  updateTarget(delta: number) {\n    const goal = this.goalTarget;\n    const target = this.model.position;\n    if (!goal.equals(target)) {\n      const radius = this.model.idealCameraDistance;\n      let {x, y, z} = target;\n      x = this.targetDamperX.update(x, goal.x, delta, radius);\n      y = this.targetDamperY.update(y, goal.y, delta, radius);\n      z = this.targetDamperZ.update(z, goal.z, delta, radius);\n      this.model.position.set(x, y, z);\n      this.isDirty = true;\n    }\n  }\n\n  /**\n   * Yaw the +z (front) of the model toward the indicated world coordinates.\n   */\n  pointTowards(worldX: number, worldZ: number) {\n    const {x, z} = this.position;\n    this.yaw = Math.atan2(worldX - x, worldZ - z);\n  }\n\n  /**\n   * Yaw is the scene's orientation about the y-axis, around the rotation\n   * center.\n   */\n  set yaw(radiansY: number) {\n    this.rotation.y = radiansY;\n    this.model.setShadowRotation(radiansY);\n    this.isDirty = true;\n  }\n\n  get yaw(): number {\n    return this.rotation.y;\n  }\n\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n  setShadowIntensity(shadowIntensity: number) {\n    shadowIntensity = Math.max(shadowIntensity, 0);\n    this.shadowIntensity = shadowIntensity;\n    if (this.model.hasModel()) {\n      this.model.setShadowIntensity(shadowIntensity, this.shadowSoftness);\n    }\n  }\n\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n  setShadowSoftness(softness: number) {\n    this.shadowSoftness = softness;\n    this.model.setShadowSoftness(softness);\n  }\n\n  /**\n   * This method returns the world position and model-space normal of the point\n   * on the mesh corresponding to the input pixel coordinates given relative to\n   * the model-viewer element. If the mesh is not hit, the result is null.\n   */\n  positionAndNormalFromPoint(pixelPosition: Vector2, object: Object3D = this):\n      {position: Vector3, normal: Vector3}|null {\n    raycaster.setFromCamera(pixelPosition, this.getCamera());\n    const hits = raycaster.intersectObject(object, true);\n\n    if (hits.length === 0) {\n      return null;\n    }\n\n    const hit = hits[0];\n    if (hit.face == null) {\n      return null;\n    }\n\n    return {position: hit.point, normal: hit.face.normal};\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}