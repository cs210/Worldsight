{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BufferGeometry, DoubleSide, Float32BufferAttribute, Mesh, PlaneBufferGeometry, Vector2 } from 'three';\nimport { Damper } from './Damper.js';\nvar RADIUS = 0.2;\nvar LINE_WIDTH = 0.03;\nvar MAX_OPACITY = 0.75;\nvar SEGMENTS = 12;\nvar DELTA_PHI = Math.PI / (2 * SEGMENTS);\nvar vector2 = new Vector2();\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\n\nvar addCorner = function addCorner(vertices, cornerX, cornerY) {\n  var phi = cornerX > 0 ? cornerY > 0 ? 0 : -Math.PI / 2 : cornerY > 0 ? Math.PI / 2 : Math.PI;\n\n  for (var i = 0; i <= SEGMENTS; ++i) {\n    vertices.push(cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi), cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi), 0, cornerX + RADIUS * Math.cos(phi), cornerY + RADIUS * Math.sin(phi), 0);\n    phi += DELTA_PHI;\n  }\n};\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a model. It is purposely larger than the model's bounding box by RADIUS on\n * all sides so that small models are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\n\n\nexport var PlacementBox = /*#__PURE__*/function (_Mesh) {\n  _inherits(PlacementBox, _Mesh);\n\n  var _super = _createSuper(PlacementBox);\n\n  function PlacementBox(model) {\n    var _this;\n\n    _classCallCheck(this, PlacementBox);\n\n    var geometry = new BufferGeometry();\n    var triangles = [];\n    var vertices = [];\n    var size = model.size,\n        boundingBox = model.boundingBox;\n    var x = size.x / 2;\n    var y = size.z / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n    var numVertices = vertices.length / 3;\n\n    for (var _i = 0; _i < numVertices - 2; _i += 2) {\n      triangles.push(_i, _i + 1, _i + 3, _i, _i + 3, _i + 2);\n    }\n\n    var i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n    _this = _super.call(this, geometry);\n    var material = _this.material;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    _this.goalOpacity = 0;\n    _this.opacityDamper = new Damper();\n    _this.hitPlane = new Mesh(new PlaneBufferGeometry(size.x + 2 * RADIUS, size.z + 2 * RADIUS));\n    _this.hitPlane.visible = false;\n\n    _this.add(_this.hitPlane);\n\n    _this.rotateX(-Math.PI / 2);\n\n    boundingBox.getCenter(_this.position);\n    _this.shadowHeight = boundingBox.min.y;\n    _this.position.y = _this.shadowHeight;\n    model.add(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n\n\n  _createClass(PlacementBox, [{\n    key: \"getHit\",\n    value: function getHit(scene, screenX, screenY) {\n      vector2.set(screenX, -screenY);\n      this.hitPlane.visible = true;\n      var hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n      this.hitPlane.visible = false;\n      return hitResult == null ? null : hitResult.position;\n    }\n    /**\n     * Offset the height of the box relative to the bottom of the model. Positive\n     * is up, so generally only negative values are used.\n     */\n\n  }, {\n    key: \"updateOpacity\",\n\n    /**\n     * Call on each frame with the frame delta to fade the box.\n     */\n    value: function updateOpacity(delta) {\n      var material = this.material;\n      material.opacity = this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n      this.visible = material.opacity > 0;\n    }\n    /**\n     * Call this to clean up Three's cache when you remove the box.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this$hitPlane = this.hitPlane,\n          geometry = _this$hitPlane.geometry,\n          material = _this$hitPlane.material;\n      geometry.dispose();\n      material.dispose();\n      this.geometry.dispose();\n      this.material.dispose();\n    }\n  }, {\n    key: \"offsetHeight\",\n    set: function set(offset) {\n      this.position.y = this.shadowHeight + offset;\n    },\n    get: function get() {\n      return this.position.y - this.shadowHeight;\n    }\n    /**\n     * Set the box's visibility; it will fade in and out.\n     */\n\n  }, {\n    key: \"show\",\n    set: function set(visible) {\n      this.goalOpacity = visible ? MAX_OPACITY : 0;\n    }\n  }]);\n\n  return PlacementBox;\n}(Mesh);","map":{"version":3,"sources":["../../src/three-components/PlacementBox.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BufferGeometry, DoubleSide, Float32BufferAttribute, Material, Mesh, MeshBasicMaterial, PlaneBufferGeometry, Vector2, Vector3} from 'three';\n\nimport {Damper} from './Damper.js';\nimport Model from './Model.js';\nimport {ModelScene} from './ModelScene.js';\n\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\n\nconst vector2 = new Vector2();\n\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\nconst addCorner =\n    (vertices: Array<number>, cornerX: number, cornerY: number) => {\n      let phi = cornerX > 0 ? (cornerY > 0 ? 0 : -Math.PI / 2) :\n                              (cornerY > 0 ? Math.PI / 2 : Math.PI);\n      for (let i = 0; i <= SEGMENTS; ++i) {\n        vertices.push(\n            cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi),\n            cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi),\n            0,\n            cornerX + RADIUS * Math.cos(phi),\n            cornerY + RADIUS * Math.sin(phi),\n            0);\n        phi += DELTA_PHI;\n      }\n    };\n\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a model. It is purposely larger than the model's bounding box by RADIUS on\n * all sides so that small models are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\nexport class PlacementBox extends Mesh {\n  private hitPlane: Mesh;\n  private shadowHeight: number;\n  private goalOpacity: number;\n  private opacityDamper: Damper;\n\n  constructor(model: Model) {\n    const geometry = new BufferGeometry();\n    const triangles: Array<number> = [];\n    const vertices: Array<number> = [];\n    const {size, boundingBox} = model;\n\n    const x = size.x / 2;\n    const y = size.z / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n\n    const numVertices = vertices.length / 3;\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n\n    super(geometry);\n\n    const material = this.material as MeshBasicMaterial;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n\n    this.hitPlane = new Mesh(\n        new PlaneBufferGeometry(size.x + 2 * RADIUS, size.z + 2 * RADIUS));\n    this.hitPlane.visible = false;\n    this.add(this.hitPlane);\n\n    this.rotateX(-Math.PI / 2);\n    boundingBox.getCenter(this.position);\n    this.shadowHeight = boundingBox.min.y;\n    this.position.y = this.shadowHeight;\n\n    model.add(this);\n  }\n\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n  getHit(scene: ModelScene, screenX: number, screenY: number): Vector3|null {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n\n  /**\n   * Offset the height of the box relative to the bottom of the model. Positive\n   * is up, so generally only negative values are used.\n   */\n  set offsetHeight(offset: number) {\n    this.position.y = this.shadowHeight + offset;\n  }\n\n  get offsetHeight(): number {\n    return this.position.y - this.shadowHeight;\n  }\n\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n  set show(visible: boolean) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n  updateOpacity(delta: number) {\n    const material = this.material as MeshBasicMaterial;\n    material.opacity =\n        this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n    this.visible = material.opacity > 0;\n  }\n\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n  dispose() {\n    const {geometry, material} = this.hitPlane;\n    geometry.dispose();\n    (material as Material).dispose();\n    this.geometry.dispose();\n    (this.material as Material).dispose();\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}