{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * This mixin function is designed to be applied to a class that inherits\n * from HTMLElement. It makes it easy for a custom element to coordinate with\n * the :focus-visible polyfill.\n *\n * NOTE(cdata): The code here was adapted from an example proposed with the\n * introduction of ShadowDOM support in the :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196\n * @param {Function} SuperClass The base class implementation to decorate with\n * implementation that coordinates with the :focus-visible polyfill\n */\nexport var FocusVisiblePolyfillMixin = function FocusVisiblePolyfillMixin(SuperClass) {\n  var _a;\n\n  var coordinateWithPolyfill = function coordinateWithPolyfill(instance) {\n    // If there is no shadow root, there is no need to coordinate with\n    // the polyfill. If we already coordinated with the polyfill, we can\n    // skip subsequent invokcations:\n    if (instance.shadowRoot == null || instance.hasAttribute('data-js-focus-visible')) {\n      return function () {};\n    } // The polyfill might already be loaded. If so, we can apply it to\n    // the shadow root immediately:\n\n\n    if (self.applyFocusVisiblePolyfill) {\n      self.applyFocusVisiblePolyfill(instance.shadowRoot);\n    } else {\n      var coordinationHandler = function coordinationHandler() {\n        self.applyFocusVisiblePolyfill(instance.shadowRoot);\n      }; // Otherwise, wait for the polyfill to be loaded lazily. It might\n      // never be loaded, but if it is then we can apply it to the\n      // shadow root at the appropriate time by waiting for the ready\n      // event:\n\n\n      self.addEventListener('focus-visible-polyfill-ready', coordinationHandler, {\n        once: true\n      });\n      return function () {\n        self.removeEventListener('focus-visible-polyfill-ready', coordinationHandler);\n      };\n    }\n\n    return function () {};\n  };\n\n  var $endPolyfillCoordination = Symbol('endPolyfillCoordination'); // IE11 doesn't natively support custom elements or JavaScript class\n  // syntax The mixin implementation assumes that the user will take the\n  // appropriate steps to support both:\n\n  var FocusVisibleCoordinator = /*#__PURE__*/function (_SuperClass) {\n    _inherits(FocusVisibleCoordinator, _SuperClass);\n\n    var _super = _createSuper(FocusVisibleCoordinator);\n\n    function FocusVisibleCoordinator() {\n      var _this;\n\n      _classCallCheck(this, FocusVisibleCoordinator);\n\n      _this = _super.apply(this, arguments);\n      _this[_a] = null;\n      return _this;\n    } // Attempt to coordinate with the polyfill when connected to the\n    // document:\n\n\n    _createClass(FocusVisibleCoordinator, [{\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(FocusVisibleCoordinator.prototype), \"connectedCallback\", this) && _get(_getPrototypeOf(FocusVisibleCoordinator.prototype), \"connectedCallback\", this).call(this);\n\n        if (this[$endPolyfillCoordination] == null) {\n          this[$endPolyfillCoordination] = coordinateWithPolyfill(this);\n        }\n      }\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(FocusVisibleCoordinator.prototype), \"disconnectedCallback\", this) && _get(_getPrototypeOf(FocusVisibleCoordinator.prototype), \"disconnectedCallback\", this).call(this); // It's important to remove the polyfill event listener when we\n        // disconnect, otherwise we will leak the whole element via window:\n\n        if (this[$endPolyfillCoordination] != null) {\n          this[$endPolyfillCoordination]();\n          this[$endPolyfillCoordination] = null;\n        }\n      }\n    }]);\n\n    return FocusVisibleCoordinator;\n  }(SuperClass);\n\n  _a = $endPolyfillCoordination;\n  ;\n  return FocusVisibleCoordinator;\n};","map":{"version":3,"sources":["../../src/utilities/focus-visible.ts"],"names":[],"mappings":";;;;;;;AAyBA;;;;;;;;;;;;AAYA,OAAO,IAAM,yBAAyB,GAClC,SADS,yBACT,CAA0C,UAA1C,EAA8D;;;AAC5D,MAAM,sBAAsB,GACxB,SADE,sBACF,CAAC,QAAD,EAAgE;AAC9D;AACA;AACA;AACA,QAAI,QAAQ,CAAC,UAAT,IAAuB,IAAvB,IACA,QAAQ,CAAC,YAAT,CAAsB,uBAAtB,CADJ,EACoD;AAClD,aAAO,YAAK,CAAG,CAAf;AACD,KAP6D,CAS9D;AACA;;;AACA,QAAK,IAAY,CAAC,yBAAlB,EAA6C;AAC1C,MAAA,IAAY,CAAC,yBAAb,CAAuC,QAAQ,CAAC,UAAhD;AACF,KAFD,MAEO;AACL,UAAM,mBAAmB,GAAG,SAAtB,mBAAsB,GAAK;AAC9B,QAAA,IAAY,CAAC,yBAAb,CAAuC,QAAQ,CAAC,UAAhD;AACF,OAFD,CADK,CAIL;AACA;AACA;AACA;;;AACA,MAAA,IAAI,CAAC,gBAAL,CACI,8BADJ,EAEI,mBAFJ,EAGI;AAAC,QAAA,IAAI,EAAE;AAAP,OAHJ;AAKA,aAAO,YAAK;AACV,QAAA,IAAI,CAAC,mBAAL,CACI,8BADJ,EACoC,mBADpC;AAED,OAHD;AAID;;AAED,WAAO,YAAK,CAAG,CAAf;AACD,GAlCL;;AAoCA,MAAM,wBAAwB,GAAG,MAAM,CAAC,yBAAD,CAAvC,CArC4D,CAuC5D;AACA;AACA;;AAzC4D,MA0CtD,uBA1CsD;AAAA;;AAAA;;AA0C5D,uCAAA;AAAA;;AAAA;;;AACS,YAAA,EAAA,IACI,IADJ;AADT;AAqBC,KA/D2D,CA6C1D;AACA;;;AA9C0D;AAAA;AAAA,0CA+CzC;AACf;;AACA,YAAI,KAAK,wBAAL,KAAkC,IAAtC,EAA4C;AAC1C,eAAK,wBAAL,IAAiC,sBAAsB,CAAC,IAAD,CAAvD;AACD;AACF;AApDyD;AAAA;AAAA,6CAsDtC;AAClB,oMADkB,CAElB;AACA;;AACA,YAAI,KAAK,wBAAL,KAAkC,IAAtC,EAA4C;AAC1C,eAAK,wBAAL;AACA,eAAK,wBAAL,IAAiC,IAAjC;AACD;AACF;AA9DyD;;AAAA;AAAA,IA0CtB,UA1CsB;;OA2ClD,wB;AAoBT;AAED,SAAO,uBAAP;AACD,CAnEE","sourcesContent":["/* @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Constructor} from '../utilities.js';\n\nexport interface OptionalLifecycleCallbacks {\n  connectedCallback?(): void;\n  disconnectedCallback?(): void;\n}\n\nexport type MixableBaseClass = HTMLElement&OptionalLifecycleCallbacks;\n\ntype EndPolyfillCoordinationCallback = () => void;\n\n/**\n * This mixin function is designed to be applied to a class that inherits\n * from HTMLElement. It makes it easy for a custom element to coordinate with\n * the :focus-visible polyfill.\n *\n * NOTE(cdata): The code here was adapted from an example proposed with the\n * introduction of ShadowDOM support in the :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196\n * @param {Function} SuperClass The base class implementation to decorate with\n * implementation that coordinates with the :focus-visible polyfill\n */\nexport const FocusVisiblePolyfillMixin =\n    <T extends Constructor<MixableBaseClass>>(SuperClass: T): T => {\n      const coordinateWithPolyfill =\n          (instance: MixableBaseClass): EndPolyfillCoordinationCallback => {\n            // If there is no shadow root, there is no need to coordinate with\n            // the polyfill. If we already coordinated with the polyfill, we can\n            // skip subsequent invokcations:\n            if (instance.shadowRoot == null ||\n                instance.hasAttribute('data-js-focus-visible')) {\n              return () => {};\n            }\n\n            // The polyfill might already be loaded. If so, we can apply it to\n            // the shadow root immediately:\n            if ((self as any).applyFocusVisiblePolyfill) {\n              (self as any).applyFocusVisiblePolyfill(instance.shadowRoot);\n            } else {\n              const coordinationHandler = () => {\n                (self as any).applyFocusVisiblePolyfill(instance.shadowRoot);\n              };\n              // Otherwise, wait for the polyfill to be loaded lazily. It might\n              // never be loaded, but if it is then we can apply it to the\n              // shadow root at the appropriate time by waiting for the ready\n              // event:\n              self.addEventListener(\n                  'focus-visible-polyfill-ready',\n                  coordinationHandler,\n                  {once: true});\n\n              return () => {\n                self.removeEventListener(\n                    'focus-visible-polyfill-ready', coordinationHandler);\n              };\n            }\n\n            return () => {};\n          };\n\n      const $endPolyfillCoordination = Symbol('endPolyfillCoordination');\n\n      // IE11 doesn't natively support custom elements or JavaScript class\n      // syntax The mixin implementation assumes that the user will take the\n      // appropriate steps to support both:\n      class FocusVisibleCoordinator extends SuperClass {\n        private[$endPolyfillCoordination]: EndPolyfillCoordinationCallback|\n            null = null;\n        // Attempt to coordinate with the polyfill when connected to the\n        // document:\n        connectedCallback() {\n          super.connectedCallback && super.connectedCallback();\n          if (this[$endPolyfillCoordination] == null) {\n            this[$endPolyfillCoordination] = coordinateWithPolyfill(this);\n          }\n        }\n\n        disconnectedCallback() {\n          super.disconnectedCallback && super.disconnectedCallback();\n          // It's important to remove the polyfill event listener when we\n          // disconnect, otherwise we will leak the whole element via window:\n          if (this[$endPolyfillCoordination] != null) {\n            this[$endPolyfillCoordination]!();\n            this[$endPolyfillCoordination] = null;\n          }\n        }\n      };\n\n      return FocusVisibleCoordinator;\n    };"],"sourceRoot":""},"metadata":{},"sourceType":"module"}