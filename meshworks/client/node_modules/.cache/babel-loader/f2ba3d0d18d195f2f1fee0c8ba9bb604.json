{"ast":null,"code":"import _toConsumableArray from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport var numberNode = function numberNode(value, unit) {\n  return {\n    type: 'number',\n    number: value,\n    unit: unit\n  };\n};\n/**\n * Given a string representing a comma-separated set of CSS-like expressions,\n * parses and returns an array of ASTs that correspond to those expressions.\n *\n * Currently supported syntax includes:\n *\n *  - functions (top-level and nested)\n *  - calc() arithmetic operators\n *  - numbers with units\n *  - hexidecimal-encoded colors in 3, 6 or 8 digit form\n *  - idents\n *\n * All syntax is intended to match the parsing rules and semantics of the actual\n * CSS spec as closely as possible.\n *\n * @see https://www.w3.org/TR/CSS2/\n * @see https://www.w3.org/TR/css-values-3/\n */\n\nexport var parseExpressions = function () {\n  var cache = {};\n  var MAX_PARSE_ITERATIONS = 1000; // Arbitrarily large\n\n  return function (inputString) {\n    var cacheKey = inputString;\n\n    if (cacheKey in cache) {\n      return cache[cacheKey];\n    }\n\n    var expressions = [];\n    var parseIterations = 0;\n\n    while (inputString) {\n      if (++parseIterations > MAX_PARSE_ITERATIONS) {\n        // Avoid a potentially infinite loop due to typos:\n        inputString = '';\n        break;\n      }\n\n      var expressionParseResult = parseExpression(inputString);\n      var expression = expressionParseResult.nodes[0];\n\n      if (expression == null || expression.terms.length === 0) {\n        break;\n      }\n\n      expressions.push(expression);\n      inputString = expressionParseResult.remainingInput;\n    }\n\n    return cache[cacheKey] = expressions;\n  };\n}();\n/**\n * Parse a single expression. For the purposes of our supported syntax, an\n * expression is the set of semantically meaningful terms that appear before the\n * next comma, or between the parens of a function invokation.\n */\n\nvar parseExpression = function () {\n  var IS_IDENT_RE = /^(\\-\\-|[a-z\\u0240-\\uffff])/i;\n  var IS_OPERATOR_RE = /^([\\*\\+\\/]|[\\-]\\s)/i;\n  var IS_EXPRESSION_END_RE = /^[\\),]/;\n  var FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';\n  var HEX_FIRST_TOKEN = '#';\n  return function (inputString) {\n    var terms = [];\n\n    while (inputString.length) {\n      inputString = inputString.trim();\n\n      if (IS_EXPRESSION_END_RE.test(inputString)) {\n        break;\n      } else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n        var _parseFunctionArgumen = parseFunctionArguments(inputString),\n            nodes = _parseFunctionArgumen.nodes,\n            remainingInput = _parseFunctionArgumen.remainingInput;\n\n        inputString = remainingInput;\n        terms.push({\n          type: 'function',\n          name: {\n            type: 'ident',\n            value: 'calc'\n          },\n          arguments: nodes\n        });\n      } else if (IS_IDENT_RE.test(inputString)) {\n        var identParseResult = parseIdent(inputString);\n        var identNode = identParseResult.nodes[0];\n        inputString = identParseResult.remainingInput;\n\n        if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n          var _parseFunctionArgumen2 = parseFunctionArguments(inputString),\n              _nodes = _parseFunctionArgumen2.nodes,\n              _remainingInput = _parseFunctionArgumen2.remainingInput;\n\n          terms.push({\n            type: 'function',\n            name: identNode,\n            arguments: _nodes\n          });\n          inputString = _remainingInput;\n        } else {\n          terms.push(identNode);\n        }\n      } else if (IS_OPERATOR_RE.test(inputString)) {\n        // Operators are always a single character, so just pluck them out:\n        terms.push({\n          type: 'operator',\n          value: inputString[0]\n        });\n        inputString = inputString.slice(1);\n      } else {\n        var _ref = inputString[0] === HEX_FIRST_TOKEN ? parseHex(inputString) : parseNumber(inputString),\n            _nodes2 = _ref.nodes,\n            _remainingInput2 = _ref.remainingInput; // The remaining string may not have had any meaningful content. Exit\n        // early if this is the case:\n\n\n        if (_nodes2.length === 0) {\n          break;\n        }\n\n        terms.push(_nodes2[0]);\n        inputString = _remainingInput2;\n      }\n    }\n\n    return {\n      nodes: [{\n        type: 'expression',\n        terms: terms\n      }],\n      remainingInput: inputString\n    };\n  };\n}();\n/**\n * An ident is something like a function name or the keyword \"auto\".\n */\n\n\nvar parseIdent = function () {\n  var NOT_IDENT_RE = /[^a-z^0-9^_^\\-^\\u0240-\\uffff]/i;\n  return function (inputString) {\n    var match = inputString.match(NOT_IDENT_RE);\n    var ident = match == null ? inputString : inputString.substr(0, match.index);\n    var remainingInput = match == null ? '' : inputString.substr(match.index);\n    return {\n      nodes: [{\n        type: 'ident',\n        value: ident\n      }],\n      remainingInput: remainingInput\n    };\n  };\n}();\n/**\n * Parses a number. A number value can be expressed with an integer or\n * non-integer syntax, and usually includes a unit (but does not strictly\n * require one for our purposes).\n */\n\n\nvar parseNumber = function () {\n  // @see https://www.w3.org/TR/css-syntax/#number-token-diagram\n  var VALUE_RE = /[\\+\\-]?(\\d+[\\.]\\d+|\\d+|[\\.]\\d+)([eE][\\+\\-]?\\d+)?/;\n  var UNIT_RE = /^[a-z%]+/i;\n  var ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;\n  return function (inputString) {\n    var valueMatch = inputString.match(VALUE_RE);\n    var value = valueMatch == null ? '0' : valueMatch[0];\n    inputString = value == null ? inputString : inputString.slice(value.length);\n    var unitMatch = inputString.match(UNIT_RE);\n    var unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;\n    var remainingInput = unitMatch == null ? inputString : inputString.slice(unit.length);\n\n    if (unit != null && !ALLOWED_UNITS.test(unit)) {\n      unit = null;\n    }\n\n    return {\n      nodes: [{\n        type: 'number',\n        number: parseFloat(value) || 0,\n        unit: unit\n      }],\n      remainingInput: remainingInput\n    };\n  };\n}();\n/**\n * Parses a hexidecimal-encoded color in 3, 6 or 8 digit form.\n */\n\n\nvar parseHex = function () {\n  // TODO(cdata): right now we don't actually enforce the number of digits\n  var HEX_RE = /^[a-f0-9]*/i;\n  return function (inputString) {\n    inputString = inputString.slice(1).trim();\n    var hexMatch = inputString.match(HEX_RE);\n    var nodes = hexMatch == null ? [] : [{\n      type: 'hex',\n      value: hexMatch[0]\n    }];\n    return {\n      nodes: nodes,\n      remainingInput: hexMatch == null ? inputString : inputString.slice(hexMatch[0].length)\n    };\n  };\n}();\n/**\n * Parses arguments passed to a function invokation (e.g., the expressions\n * within a matched set of parens).\n */\n\n\nvar parseFunctionArguments = function parseFunctionArguments(inputString) {\n  var expressionNodes = []; // Consume the opening paren\n\n  inputString = inputString.slice(1).trim();\n\n  while (inputString.length) {\n    var expressionParseResult = parseExpression(inputString);\n    expressionNodes.push(expressionParseResult.nodes[0]);\n    inputString = expressionParseResult.remainingInput.trim();\n\n    if (inputString[0] === ',') {\n      inputString = inputString.slice(1).trim();\n    } else if (inputString[0] === ')') {\n      // Consume the closing paren and stop parsing\n      inputString = inputString.slice(1);\n      break;\n    }\n  }\n\n  return {\n    nodes: expressionNodes,\n    remainingInput: inputString\n  };\n};\n\nvar $visitedTypes = Symbol('visitedTypes');\n/**\n * An ASTWalker walks an array of ASTs such as the type produced by\n * parseExpressions and invokes a callback for a configured set of nodes that\n * the user wishes to \"visit\" during the walk.\n */\n\nexport var ASTWalker = /*#__PURE__*/function () {\n  function ASTWalker(visitedTypes) {\n    _classCallCheck(this, ASTWalker);\n\n    this[$visitedTypes] = visitedTypes;\n  }\n  /**\n   * Walk the given set of ASTs, and invoke the provided callback for nodes that\n   * match the filtered set that the ASTWalker was constructed with.\n   */\n\n\n  _createClass(ASTWalker, [{\n    key: \"walk\",\n    value: function walk(ast, callback) {\n      var remaining = ast.slice();\n\n      while (remaining.length) {\n        var next = remaining.shift();\n\n        if (this[$visitedTypes].indexOf(next.type) > -1) {\n          callback(next);\n        }\n\n        switch (next.type) {\n          case 'expression':\n            remaining.unshift.apply(remaining, _toConsumableArray(next.terms));\n            break;\n\n          case 'function':\n            remaining.unshift.apply(remaining, [next.name].concat(_toConsumableArray(next.arguments)));\n            break;\n        }\n      }\n    }\n  }]);\n\n  return ASTWalker;\n}();\nexport var ZERO = Object.freeze({\n  type: 'number',\n  number: 0,\n  unit: null\n});","map":{"version":3,"sources":["../../src/styles/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// The operators that are available in CSS calc() functions\n// include symbols for addition, subtraction, multiplication and division\n// @see https://www.w3.org/TR/css-values-3/#calc-syntax\nexport type Operator = '+'|'-'|'*'|'/';\n\n// We only support units for length in meters, radians and degrees for angles\n// and percentage values\nexport type Unit = 'm'|'cm'|'mm'|'rad'|'deg';\nexport type Percentage = '%';\n\n// Any node that might appear in a parsed expression is referred to as an\n// ExpressionTerm\nexport type ExpressionTerm =\n    IdentNode|HexNode|NumberNode|OperatorNode|FunctionNode;\n\nexport interface IdentNode {\n  type: 'ident';\n  value: string;\n}\n\nexport interface HexNode {\n  type: 'hex';\n  value: string;\n}\n\nexport interface NumberNode<U = Unit | Percentage | null> {\n  type: 'number';\n  number: number;\n  unit: U;\n}\n\nexport const numberNode =\n    <T extends Unit|Percentage|null>(value: number, unit: T): NumberNode<T> =>\n        ({type: 'number', number: value, unit});\n\nexport interface OperatorNode {\n  type: 'operator';\n  value: Operator;\n}\n\nexport interface FunctionNode {\n  type: 'function';\n  name: IdentNode;\n  arguments: Array<ExpressionNode>;\n}\n\nexport interface ExpressionNode {\n  type: 'expression';\n  terms: Array<ExpressionTerm>;\n}\n\nexport type ASTNode =\n    IdentNode|HexNode|NumberNode|OperatorNode|FunctionNode|ExpressionNode;\n\n// As an internal detail of this module, non-exported parsers return both a\n// set of nodes and the remaining string input to be parsed. This saves us a bit\n// of book keeping work and allows our internal parser implementations to remain\n// essentially stateless.\ninterface ParseResult<T extends ASTNode> {\n  nodes: Array<T>;\n  remainingInput: string;\n}\n\n/**\n * Given a string representing a comma-separated set of CSS-like expressions,\n * parses and returns an array of ASTs that correspond to those expressions.\n *\n * Currently supported syntax includes:\n *\n *  - functions (top-level and nested)\n *  - calc() arithmetic operators\n *  - numbers with units\n *  - hexidecimal-encoded colors in 3, 6 or 8 digit form\n *  - idents\n *\n * All syntax is intended to match the parsing rules and semantics of the actual\n * CSS spec as closely as possible.\n *\n * @see https://www.w3.org/TR/CSS2/\n * @see https://www.w3.org/TR/css-values-3/\n */\nexport const parseExpressions = (() => {\n  const cache: {[index: string]: Array<ExpressionNode>} = {};\n  const MAX_PARSE_ITERATIONS = 1000;  // Arbitrarily large\n\n  return (inputString: string): Array<ExpressionNode> => {\n    const cacheKey = inputString;\n\n    if (cacheKey in cache) {\n      return cache[cacheKey];\n    }\n\n    const expressions: Array<ExpressionNode> = [];\n    let parseIterations = 0;\n\n    while (inputString) {\n      if (++parseIterations > MAX_PARSE_ITERATIONS) {\n        // Avoid a potentially infinite loop due to typos:\n        inputString = '';\n        break;\n      }\n\n      const expressionParseResult = parseExpression(inputString);\n      const expression = expressionParseResult.nodes[0];\n\n      if (expression == null || expression.terms.length === 0) {\n        break;\n      }\n\n      expressions.push(expression);\n      inputString = expressionParseResult.remainingInput;\n    }\n\n    return cache[cacheKey] = expressions;\n  };\n})();\n\n\n/**\n * Parse a single expression. For the purposes of our supported syntax, an\n * expression is the set of semantically meaningful terms that appear before the\n * next comma, or between the parens of a function invokation.\n */\nconst parseExpression = (() => {\n  const IS_IDENT_RE = /^(\\-\\-|[a-z\\u0240-\\uffff])/i;\n  const IS_OPERATOR_RE = /^([\\*\\+\\/]|[\\-]\\s)/i;\n  const IS_EXPRESSION_END_RE = /^[\\),]/;\n  const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';\n  const HEX_FIRST_TOKEN = '#';\n\n  return (inputString: string): ParseResult<ExpressionNode> => {\n    const terms: Array<ExpressionTerm> = [];\n\n    while (inputString.length) {\n      inputString = inputString.trim();\n\n      if (IS_EXPRESSION_END_RE.test(inputString)) {\n        break;\n      } else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n        const {nodes, remainingInput} = parseFunctionArguments(inputString);\n\n        inputString = remainingInput;\n\n        terms.push({\n          type: 'function',\n          name: {type: 'ident', value: 'calc'},\n          arguments: nodes\n        });\n      } else if (IS_IDENT_RE.test(inputString)) {\n        const identParseResult = parseIdent(inputString);\n        const identNode = identParseResult.nodes[0];\n\n        inputString = identParseResult.remainingInput;\n\n        if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n          const {nodes, remainingInput} = parseFunctionArguments(inputString);\n          terms.push({type: 'function', name: identNode, arguments: nodes});\n          inputString = remainingInput;\n        } else {\n          terms.push(identNode);\n        }\n      } else if (IS_OPERATOR_RE.test(inputString)) {\n        // Operators are always a single character, so just pluck them out:\n        terms.push({type: 'operator', value: inputString[0] as Operator});\n        inputString = inputString.slice(1);\n      } else {\n        const {nodes, remainingInput} = inputString[0] === HEX_FIRST_TOKEN ?\n            parseHex(inputString) :\n            parseNumber(inputString);\n\n        // The remaining string may not have had any meaningful content. Exit\n        // early if this is the case:\n        if (nodes.length === 0) {\n          break;\n        }\n\n        terms.push(nodes[0]);\n        inputString = remainingInput;\n      }\n    }\n\n    return {nodes: [{type: 'expression', terms}], remainingInput: inputString};\n  };\n})();\n\n\n/**\n * An ident is something like a function name or the keyword \"auto\".\n */\nconst parseIdent = (() => {\n  const NOT_IDENT_RE = /[^a-z^0-9^_^\\-^\\u0240-\\uffff]/i;\n\n  return (inputString: string): ParseResult<IdentNode> => {\n    const match = inputString.match(NOT_IDENT_RE);\n    const ident =\n        match == null ? inputString : inputString.substr(0, match.index);\n    const remainingInput =\n        match == null ? '' : inputString.substr(match.index!);\n\n    return {nodes: [{type: 'ident', value: ident}], remainingInput};\n  };\n})();\n\n\n/**\n * Parses a number. A number value can be expressed with an integer or\n * non-integer syntax, and usually includes a unit (but does not strictly\n * require one for our purposes).\n */\nconst parseNumber = (() => {\n  // @see https://www.w3.org/TR/css-syntax/#number-token-diagram\n  const VALUE_RE = /[\\+\\-]?(\\d+[\\.]\\d+|\\d+|[\\.]\\d+)([eE][\\+\\-]?\\d+)?/;\n  const UNIT_RE = /^[a-z%]+/i;\n  const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;\n\n  return (inputString: string): ParseResult<NumberNode> => {\n    const valueMatch = inputString.match(VALUE_RE);\n    const value = valueMatch == null ? '0' : valueMatch[0];\n    inputString = value == null ? inputString : inputString.slice(value.length);\n\n    const unitMatch = inputString.match(UNIT_RE);\n    let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;\n    const remainingInput =\n        unitMatch == null ? inputString : inputString.slice(unit!.length);\n\n    if (unit != null && !ALLOWED_UNITS.test(unit)) {\n      unit = null;\n    }\n\n    return {\n      nodes: [{\n        type: 'number',\n        number: parseFloat(value) || 0,\n        unit: unit as Unit | Percentage | null\n      }],\n      remainingInput\n    };\n  };\n})();\n\n\n/**\n * Parses a hexidecimal-encoded color in 3, 6 or 8 digit form.\n */\nconst parseHex = (() => {\n  // TODO(cdata): right now we don't actually enforce the number of digits\n  const HEX_RE = /^[a-f0-9]*/i;\n\n  return (inputString: string): ParseResult<HexNode> => {\n    inputString = inputString.slice(1).trim();\n    const hexMatch = inputString.match(HEX_RE);\n    const nodes: Array<HexNode> =\n        hexMatch == null ? [] : [{type: 'hex', value: hexMatch[0]}];\n\n    return {\n      nodes,\n      remainingInput: hexMatch == null ? inputString :\n                                         inputString.slice(hexMatch[0].length)\n    };\n  };\n})();\n\n\n/**\n * Parses arguments passed to a function invokation (e.g., the expressions\n * within a matched set of parens).\n */\nconst parseFunctionArguments =\n    (inputString: string): ParseResult<ExpressionNode> => {\n      const expressionNodes: Array<ExpressionNode> = [];\n\n      // Consume the opening paren\n      inputString = inputString.slice(1).trim();\n\n      while (inputString.length) {\n        const expressionParseResult = parseExpression(inputString);\n        expressionNodes.push(expressionParseResult.nodes[0]);\n        inputString = expressionParseResult.remainingInput.trim();\n\n        if (inputString[0] === ',') {\n          inputString = inputString.slice(1).trim();\n        } else if (inputString[0] === ')') {\n          // Consume the closing paren and stop parsing\n          inputString = inputString.slice(1);\n          break;\n        }\n      }\n\n      return {nodes: expressionNodes, remainingInput: inputString};\n    };\n\n\nexport type ASTWalkerCallback<T> = (node: T) => void;\n\nconst $visitedTypes = Symbol('visitedTypes');\n\n/**\n * An ASTWalker walks an array of ASTs such as the type produced by\n * parseExpressions and invokes a callback for a configured set of nodes that\n * the user wishes to \"visit\" during the walk.\n */\nexport class ASTWalker<T extends ASTNode> {\n  protected[$visitedTypes]: Array<string>;\n  constructor(visitedTypes: Array<string>) {\n    this[$visitedTypes] = visitedTypes;\n  }\n\n  /**\n   * Walk the given set of ASTs, and invoke the provided callback for nodes that\n   * match the filtered set that the ASTWalker was constructed with.\n   */\n  walk(ast: Array<ExpressionNode>, callback: ASTWalkerCallback<T>) {\n    const remaining: Array<ASTNode> = ast.slice();\n\n    while (remaining.length) {\n      const next = remaining.shift()!;\n\n      if (this[$visitedTypes].indexOf(next.type) > -1) {\n        callback(next as T);\n      }\n\n      switch (next.type) {\n        case 'expression':\n          remaining.unshift(...next.terms);\n          break;\n        case 'function':\n          remaining.unshift(next.name, ...next.arguments);\n          break;\n      }\n    }\n  }\n}\n\nexport const ZERO: NumberNode =\n    Object.freeze({type: 'number', number: 0, unit: null});"],"sourceRoot":""},"metadata":{},"sourceType":"module"}