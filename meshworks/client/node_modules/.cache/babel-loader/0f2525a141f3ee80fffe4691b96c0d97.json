{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ThreeDOMMessageType } from '../protocol.js';\n/**\n * A constructor factory for a ModelKernel class. The ModelKernel is defined\n * based on a provided implementation for all specified 3DOM scene graph\n * element types.\n *\n * The sole reason for using this factory pattern is to enable sound type\n * checking while also providing for the ability to stringify the factory so\n * that it can be part of a runtime-generated Worker script.\n */\n\nexport function defineModelKernel(Model, Material, PBRMetallicRoughness) {\n  var _a, _b, _c, _d, _e, _f;\n\n  var constructorsByType = {\n    'model': Model,\n    'material': Material,\n    'pbr-metallic-roughness': PBRMetallicRoughness\n  };\n  var $onMessageEvent = Symbol('onMessageEvent');\n  var $messageEventHandler = Symbol('messageEventHandler');\n  var $port = Symbol('port');\n  var $model = Symbol('model');\n  var $elementsByLocalId = Symbol('elementsByLocalId');\n  var $localIdsByElement = Symbol('localIdsByElement');\n  var $elementsByType = Symbol('elementsByType');\n  var $pendingMutations = Symbol('pendingMutations');\n  var $nextMutationId = Symbol('nextMutationId');\n  /**\n   * A ModelKernel is the core business logic implementation for a distinct\n   * Model that has been exposed to a script execution context. The ModelKernel\n   * is an internal detail, and should never be explicitly exposed to users of\n   * a Model.\n   *\n   * The ModelKernel primarily handles deserializing scene graph elements, and\n   * communicating mutations from the 3DOM execution context to the host\n   * execution context where the backing scene graph lives.\n   *\n   * A ModelKernel also maintains a comprehensive map of elements by type to\n   * assist scene graph elements in querying for their contemporaries.\n   */\n\n  var ModelKernel = /*#__PURE__*/function () {\n    function ModelKernel(port, serialized) {\n      var _this = this;\n\n      _classCallCheck(this, ModelKernel);\n\n      this[_a] = new Map();\n      this[_b] = new Map();\n      this[_c] = new Map();\n\n      this[_d] = function (event) {\n        return _this[$onMessageEvent](event);\n      };\n\n      this[_e] = new Map();\n      this[_f] = 0;\n      var types = Object.keys(constructorsByType);\n\n      for (var _i = 0, _types = types; _i < _types.length; _i++) {\n        var type = _types[_i];\n        this[$elementsByType].set(type, new Set());\n      }\n\n      this[$port] = port;\n      this[$port].addEventListener('message', this[$messageEventHandler]);\n      this[$port].start();\n      this[$model] = this.deserialize('model', serialized);\n    }\n    /**\n     * The root scene graph element, a Model, that is the entrypoint for the\n     * entire scene graph that is backed by this kernel.\n     */\n\n\n    _createClass(ModelKernel, [{\n      key: \"mutate\",\n\n      /**\n       * Mutate a property of a property of a given scene graph element. All\n       * direct mutations of the scene graph are considered asynchronous. This\n       * method returns a Promise that resolves when the mutation has been\n       * successfully applied to the backing scene graph, and rejects if the\n       * mutation failed or is otherwise not allowed.\n       *\n       * TODO(#1006): How to validate values?\n       */\n      value: function () {\n        var _mutate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(element, property, value) {\n          var _this2 = this;\n\n          var id;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (this[$localIdsByElement].has(element)) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  throw new Error('Cannot mutate unknown element');\n\n                case 2:\n                  id = this[$localIdsByElement].get(element);\n                  return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                    var mutationId = _this2[$nextMutationId]++; // TODO(#1006): Validate mutations before sending to host context:\n\n                    _this2[$port].postMessage({\n                      type: ThreeDOMMessageType.MUTATE,\n                      id: id,\n                      property: property,\n                      value: value,\n                      mutationId: mutationId\n                    }); // TODO(#1011): Add timeout to reject this mutation:\n\n\n                    _this2[$pendingMutations].set(mutationId, {\n                      resolve: resolve,\n                      reject: reject\n                    });\n                  }));\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function mutate(_x, _x2, _x3) {\n          return _mutate.apply(this, arguments);\n        }\n\n        return mutate;\n      }()\n      /**\n       * Deserializes a JSON representation of a scene graph element into a live\n       * element that is backed by this ModelKernel.\n       */\n\n    }, {\n      key: \"deserialize\",\n      value: function deserialize(type, serialized) {\n        if (!(type in constructorsByType)) {\n          throw new Error(\"Cannot deserialize unknown type: \".concat(type));\n        }\n\n        var id = serialized.id;\n        var ElementConstructor = constructorsByType[type]; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        var element = new ElementConstructor(this, serialized);\n        this[$elementsByLocalId].set(id, element);\n        this[$localIdsByElement].set(element, id); // We know that the all accepted types have been pre-populated in the\n        // [$elementsByType] map:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        this[$elementsByType].get(type).add(element);\n        return element;\n      }\n      /**\n       * Look up all scene graph elements given a type string. Type strings\n       * are lower-cased, hyphenated versions of the constructor names of their\n       * corresponding classes. For example, a query for 'pbr-metallic-roughness'\n       * element types will yield the list of PBRMetallicRoughness elements in\n       * sparse tree order.\n       */\n\n    }, {\n      key: \"getElementsByType\",\n      value: function getElementsByType(type) {\n        if (!this[$elementsByType].has(type)) {\n          return [];\n        } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n        return Array.from(this[$elementsByType].get(type));\n      }\n      /**\n       * Deactivate the ModelKernel. This has the effect of blocking all future\n       * mutations to the scene graph. Once deactivated, a ModelKernel cannot be\n       * reactivated.\n       *\n       * The ModelKernel should be deactivated before it is disposed of, or else\n       * it will leak in memory.\n       */\n\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        this[$port].close();\n        this[$port].removeEventListener('message', this[$messageEventHandler]);\n      }\n    }, {\n      key: (_a = $elementsByLocalId, _b = $localIdsByElement, _c = $elementsByType, _d = $messageEventHandler, _e = $pendingMutations, _f = $nextMutationId, $onMessageEvent),\n      value: function value(event) {\n        var data = event.data;\n\n        switch (data && data.type) {\n          case ThreeDOMMessageType.MUTATION_RESULT:\n            {\n              var message = data;\n              var applied = message.applied,\n                  mutationId = message.mutationId;\n              var pendingMutation = this[$pendingMutations].get(mutationId);\n              this[$pendingMutations].delete(mutationId);\n\n              if (pendingMutation != null) {\n                applied ? pendingMutation.resolve() : pendingMutation.reject();\n              }\n\n              break;\n            }\n        }\n      }\n    }, {\n      key: \"model\",\n      get: function get() {\n        return this[$model];\n      }\n    }]);\n\n    return ModelKernel;\n  }();\n\n  return ModelKernel;\n}","map":{"version":3,"sources":["../../src/api/model-kernel.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ConstructedWithArguments, Constructor, Material, Model, PBRMetallicRoughness, ThreeDOMElement, ThreeDOMElementMap} from '../api.js';\nimport {MutationResultMessage, SerializedElementMap, SerializedMaterial, SerializedModel, SerializedPBRMetallicRoughness, ThreeDOMMessageType} from '../protocol.js';\n\nexport interface ModelKernelInterface {\n  readonly model: Model;\n\n  mutate(element: ThreeDOMElement, property: string, value: unknown):\n      Promise<void>;\n  deserialize<T extends keyof ThreeDOMElementMap>(\n      type: T, serialized: SerializedElementMap[T]): ThreeDOMElementMap[T];\n  getElementsByType<T extends keyof ThreeDOMElementMap>(type: T):\n      Array<ThreeDOMElementMap[T]>;\n  deactivate(): void;\n}\n\nexport type ModelKernelConstructor = Constructor<ModelKernelInterface>&\n    ConstructedWithArguments<[MessagePort, SerializedModel]>;\n\nexport type ModelKernel = InstanceType<ModelKernelConstructor>;\n\ntype ElementsByType<T = ThreeDOMElementMap, U extends keyof T = keyof T> =\n    Map<U, Set<T[U]>>;\n\ntype ModelConstructor = Constructor<Model>&\n    ConstructedWithArguments<[ModelKernelInterface, SerializedModel]>;\ntype MaterialConstructor = Constructor<Material>&\n    ConstructedWithArguments<[ModelKernelInterface, SerializedMaterial]>;\ntype PBRMetallicRoughnessConstructor =\n    Constructor<PBRMetallicRoughness>&ConstructedWithArguments<\n        [ModelKernelInterface, SerializedPBRMetallicRoughness]>;\n\ninterface Deferred {\n  resolve: () => void;\n  reject: () => void;\n}\n\n/**\n * A constructor factory for a ModelKernel class. The ModelKernel is defined\n * based on a provided implementation for all specified 3DOM scene graph\n * element types.\n *\n * The sole reason for using this factory pattern is to enable sound type\n * checking while also providing for the ability to stringify the factory so\n * that it can be part of a runtime-generated Worker script.\n */\nexport function defineModelKernel(\n    Model: ModelConstructor,\n    Material: MaterialConstructor,\n    PBRMetallicRoughness: PBRMetallicRoughnessConstructor):\n    ModelKernelConstructor {\n  const constructorsByType: {\n    [K in keyof ThreeDOMElementMap]: Constructor<ThreeDOMElementMap[K]>&\n    ConstructedWithArguments<[ModelKernelInterface, SerializedElementMap[K]]>\n  } = {\n    'model': Model,\n    'material': Material,\n    'pbr-metallic-roughness': PBRMetallicRoughness\n  };\n\n  const $onMessageEvent = Symbol('onMessageEvent');\n  const $messageEventHandler = Symbol('messageEventHandler');\n  const $port = Symbol('port');\n  const $model = Symbol('model');\n\n  const $elementsByLocalId = Symbol('elementsByLocalId');\n  const $localIdsByElement = Symbol('localIdsByElement');\n  const $elementsByType = Symbol('elementsByType');\n\n  const $pendingMutations = Symbol('pendingMutations');\n  const $nextMutationId = Symbol('nextMutationId');\n\n  /**\n   * A ModelKernel is the core business logic implementation for a distinct\n   * Model that has been exposed to a script execution context. The ModelKernel\n   * is an internal detail, and should never be explicitly exposed to users of\n   * a Model.\n   *\n   * The ModelKernel primarily handles deserializing scene graph elements, and\n   * communicating mutations from the 3DOM execution context to the host\n   * execution context where the backing scene graph lives.\n   *\n   * A ModelKernel also maintains a comprehensive map of elements by type to\n   * assist scene graph elements in querying for their contemporaries.\n   */\n  class ModelKernel implements ModelKernelInterface {\n    protected[$elementsByLocalId] = new Map<number, ThreeDOMElement>();\n    protected[$localIdsByElement] = new Map<ThreeDOMElement, number>();\n\n    protected[$elementsByType]: ElementsByType = new Map();\n\n    protected[$messageEventHandler] = (event: MessageEvent) =>\n        this[$onMessageEvent](event);\n    protected[$port]: MessagePort;\n\n    protected[$model]: Model;\n\n    protected[$pendingMutations]: Map<number, Deferred> = new Map();\n\n    protected[$nextMutationId] = 0;\n\n    constructor(port: MessagePort, serialized: SerializedModel) {\n      const types =\n          Object.keys(constructorsByType) as Array<keyof ThreeDOMElementMap>;\n\n      for (const type of types) {\n        this[$elementsByType].set(type, new Set());\n      }\n\n      this[$port] = port;\n      this[$port].addEventListener('message', this[$messageEventHandler]);\n      this[$port].start();\n\n      this[$model] = this.deserialize('model', serialized);\n    }\n\n    /**\n     * The root scene graph element, a Model, that is the entrypoint for the\n     * entire scene graph that is backed by this kernel.\n     */\n    get model() {\n      return this[$model];\n    }\n\n    /**\n     * Mutate a property of a property of a given scene graph element. All\n     * direct mutations of the scene graph are considered asynchronous. This\n     * method returns a Promise that resolves when the mutation has been\n     * successfully applied to the backing scene graph, and rejects if the\n     * mutation failed or is otherwise not allowed.\n     *\n     * TODO(#1006): How to validate values?\n     */\n    async mutate(element: ThreeDOMElement, property: string, value: unknown):\n        Promise<void> {\n      if (!this[$localIdsByElement].has(element)) {\n        throw new Error('Cannot mutate unknown element');\n      }\n\n      const id = this[$localIdsByElement].get(element);\n\n      return new Promise((resolve, reject) => {\n        const mutationId = this[$nextMutationId]++;\n        // TODO(#1006): Validate mutations before sending to host context:\n        this[$port].postMessage({\n          type: ThreeDOMMessageType.MUTATE,\n          id,\n          property,\n          value,\n          mutationId,\n        });\n\n        // TODO(#1011): Add timeout to reject this mutation:\n        this[$pendingMutations].set(mutationId, {\n          resolve,\n          reject,\n        });\n      });\n    }\n\n    /**\n     * Deserializes a JSON representation of a scene graph element into a live\n     * element that is backed by this ModelKernel.\n     */\n    deserialize<T extends keyof ThreeDOMElementMap>(\n        type: T, serialized: SerializedElementMap[T]): ThreeDOMElementMap[T] {\n      if (!(type in constructorsByType)) {\n        throw new Error(`Cannot deserialize unknown type: ${type}`);\n      }\n\n      const {id} = serialized;\n      const ElementConstructor = constructorsByType[type];\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const element = new ElementConstructor(this, serialized as any);\n\n      this[$elementsByLocalId].set(id, element);\n      this[$localIdsByElement].set(element, id);\n\n      // We know that the all accepted types have been pre-populated in the\n      // [$elementsByType] map:\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this[$elementsByType].get(type)!.add(element);\n\n      return element as ThreeDOMElementMap[T];\n    }\n\n    /**\n     * Look up all scene graph elements given a type string. Type strings\n     * are lower-cased, hyphenated versions of the constructor names of their\n     * corresponding classes. For example, a query for 'pbr-metallic-roughness'\n     * element types will yield the list of PBRMetallicRoughness elements in\n     * sparse tree order.\n     */\n    getElementsByType<T extends keyof ThreeDOMElementMap>(type: T):\n        Array<ThreeDOMElementMap[T]> {\n      if (!this[$elementsByType].has(type)) {\n        return [];\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return Array.from(this[$elementsByType].get(type)!) as\n          Array<ThreeDOMElementMap[T]>;\n    }\n\n    /**\n     * Deactivate the ModelKernel. This has the effect of blocking all future\n     * mutations to the scene graph. Once deactivated, a ModelKernel cannot be\n     * reactivated.\n     *\n     * The ModelKernel should be deactivated before it is disposed of, or else\n     * it will leak in memory.\n     */\n    deactivate() {\n      this[$port].close();\n      this[$port].removeEventListener('message', this[$messageEventHandler]);\n    }\n\n    protected[$onMessageEvent](event: MessageEvent) {\n      const {data} = event;\n\n      switch (data && data.type) {\n        case ThreeDOMMessageType.MUTATION_RESULT: {\n          const message: MutationResultMessage = data;\n          const {applied, mutationId} = message;\n          const pendingMutation = this[$pendingMutations].get(mutationId);\n\n          this[$pendingMutations].delete(mutationId);\n\n          if (pendingMutation != null) {\n            applied ? pendingMutation.resolve() : pendingMutation.reject();\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  return ModelKernel;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}