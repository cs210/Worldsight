{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { CacheEvictionPolicy } from '../utilities/cache-eviction-policy.js';\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\n\nexport var loadWithLoader = function loadWithLoader(url, loader) {\n  var progressCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\n  var onProgress = function onProgress(event) {\n    progressCallback(event.loaded / event.total);\n  };\n\n  return new Promise(function (resolve, reject) {\n    loader.load(url, resolve, onProgress, reject);\n  });\n};\nvar cache = new Map();\nvar preloaded = new Map();\nvar dracoDecoderLocation;\nvar dracoLoader = new DRACOLoader();\nexport var $loader = Symbol('loader');\nexport var $evictionPolicy = Symbol('evictionPolicy');\nvar $GLTFInstance = Symbol('GLTFInstance');\nexport var CachingGLTFLoader = /*#__PURE__*/function () {\n  function CachingGLTFLoader(GLTFInstance) {\n    _classCallCheck(this, CachingGLTFLoader);\n\n    this[_b] = new GLTFLoader();\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n  }\n\n  _createClass(CachingGLTFLoader, [{\n    key: \"preload\",\n\n    /**\n     * Preloads a glTF, populating the cache. Returns a promise that resolves\n     * when the cache is populated.\n     */\n    value: function () {\n      var _preload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n        var _this = this;\n\n        var progressCallback,\n            rawGLTFLoads,\n            gltfInstanceLoads,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                progressCallback = _args.length > 1 && _args[1] !== undefined ? _args[1] : function () {};\n\n                if (!cache.has(url)) {\n                  rawGLTFLoads = loadWithLoader(url, this[$loader], function (progress) {\n                    progressCallback(progress * 0.8);\n                  });\n                  gltfInstanceLoads = rawGLTFLoads.then(function (rawGLTF) {\n                    var GLTFInstance = _this[$GLTFInstance];\n                    var preparedGLTF = GLTFInstance.prepare(rawGLTF);\n                    progressCallback(0.9);\n                    return new GLTFInstance(preparedGLTF);\n                  });\n                  cache.set(url, gltfInstanceLoads);\n                }\n\n                _context.next = 4;\n                return cache.get(url);\n\n              case 4:\n                if (progressCallback) {\n                  progressCallback(1.0);\n                }\n\n                preloaded.set(url, true);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function preload(_x) {\n        return _preload.apply(this, arguments);\n      }\n\n      return preload;\n    }()\n    /**\n     * Loads a glTF from the specified url and resolves a unique clone of the\n     * glTF. If the glTF has already been loaded, makes a clone of the cached\n     * copy.\n     */\n\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url) {\n        var _this2 = this;\n\n        var progressCallback,\n            gltf,\n            clone,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                progressCallback = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : function () {};\n                _context2.next = 3;\n                return this.preload(url, progressCallback);\n\n              case 3:\n                _context2.next = 5;\n                return cache.get(url);\n\n              case 5:\n                gltf = _context2.sent;\n                clone = gltf.clone();\n                this[$evictionPolicy].retain(url); // Patch dispose so that we can properly account for instance use\n                // in the caching layer:\n\n                clone.dispose = function () {\n                  var originalDispose = clone.dispose;\n                  var disposed = false;\n                  return function () {\n                    if (disposed) {\n                      return;\n                    }\n\n                    disposed = true;\n                    originalDispose.apply(clone);\n\n                    _this2[$evictionPolicy].release(url);\n                  };\n                }();\n\n                return _context2.abrupt(\"return\", clone);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function load(_x2) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: (_a = $evictionPolicy, _b = $loader, $evictionPolicy),\n    get: function get() {\n      return this.constructor[$evictionPolicy];\n    }\n  }], [{\n    key: \"setDRACODecoderLocation\",\n    value: function setDRACODecoderLocation(url) {\n      dracoDecoderLocation = url;\n      dracoLoader.setDecoderPath(url);\n    }\n  }, {\n    key: \"getDRACODecoderLocation\",\n    value: function getDRACODecoderLocation() {\n      return dracoDecoderLocation;\n    }\n  }, {\n    key: \"clearCache\",\n\n    /** @nocollapse */\n    value: function clearCache() {\n      var _this3 = this;\n\n      cache.forEach(function (_value, url) {\n        _this3.delete(url);\n      });\n      this[$evictionPolicy].reset();\n    }\n  }, {\n    key: \"has\",\n    value: function has(url) {\n      return cache.has(url);\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url) {\n        var gltfLoads, gltf;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.has(url)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                gltfLoads = cache.get(url);\n                preloaded.delete(url);\n                cache.delete(url);\n                _context3.next = 7;\n                return gltfLoads;\n\n              case 7:\n                gltf = _context3.sent;\n                // Dispose of the cached glTF's materials and geometries:\n                gltf.dispose();\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _delete(_x3) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * Returns true if the model that corresponds to the specified url is\n     * available in our local cache.\n     */\n\n  }, {\n    key: \"hasFinishedLoading\",\n    value: function hasFinishedLoading(url) {\n      return !!preloaded.get(url);\n    }\n  }, {\n    key: \"cache\",\n    get: function get() {\n      return cache;\n    }\n  }]);\n\n  return CachingGLTFLoader;\n}();\nCachingGLTFLoader[_a] = new CacheEvictionPolicy(CachingGLTFLoader);","map":{"version":3,"sources":["../../src/three-components/CachingGLTFLoader.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {DRACOLoader} from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport {GLTF, GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {CacheEvictionPolicy} from '../utilities/cache-eviction-policy.js';\n\nimport {GLTFInstance, GLTFInstanceConstructor} from './GLTFInstance.js';\n\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\nexport const loadWithLoader =\n    (url: string,\n     loader: GLTFLoader,\n     progressCallback: ProgressCallback = () => {}) => {\n      const onProgress = (event: ProgressEvent) => {\n        progressCallback!(event.loaded / event.total);\n      };\n      return new Promise<GLTF>((resolve, reject) => {\n        loader.load(url, resolve, onProgress, reject);\n      });\n    };\n\nconst cache = new Map<string, Promise<GLTFInstance>>();\nconst preloaded = new Map<string, boolean>();\n\nlet dracoDecoderLocation: string;\nconst dracoLoader = new DRACOLoader();\n\nexport const $loader = Symbol('loader');\nexport const $evictionPolicy = Symbol('evictionPolicy');\nconst $GLTFInstance = Symbol('GLTFInstance');\n\nexport class CachingGLTFLoader<T extends GLTFInstanceConstructor =\n                                             GLTFInstanceConstructor> {\n  static setDRACODecoderLocation(url: string) {\n    dracoDecoderLocation = url;\n    dracoLoader.setDecoderPath(url);\n  }\n\n  static getDRACODecoderLocation() {\n    return dracoDecoderLocation;\n  }\n\n  static[$evictionPolicy]: CacheEvictionPolicy =\n      new CacheEvictionPolicy(CachingGLTFLoader);\n\n  static get cache() {\n    return cache;\n  }\n\n  /** @nocollapse */\n  static clearCache() {\n    cache.forEach((_value, url) => {\n      this.delete(url);\n    });\n    this[$evictionPolicy].reset();\n  }\n\n  static has(url: string) {\n    return cache.has(url);\n  }\n\n  /** @nocollapse */\n  static async delete(url: string) {\n    if (!this.has(url)) {\n      return;\n    }\n\n    const gltfLoads = cache.get(url);\n    preloaded.delete(url);\n    cache.delete(url);\n\n    const gltf = await gltfLoads;\n    // Dispose of the cached glTF's materials and geometries:\n\n    gltf!.dispose();\n  }\n\n  /**\n   * Returns true if the model that corresponds to the specified url is\n   * available in our local cache.\n   */\n  static hasFinishedLoading(url: string) {\n    return !!preloaded.get(url);\n  }\n\n  constructor(GLTFInstance: T) {\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n  }\n\n  protected[$loader]: GLTFLoader = new GLTFLoader();\n  protected[$GLTFInstance]: T;\n\n  protected get[$evictionPolicy](): CacheEvictionPolicy {\n    return (this.constructor as typeof CachingGLTFLoader)[$evictionPolicy];\n  }\n\n  /**\n   * Preloads a glTF, populating the cache. Returns a promise that resolves\n   * when the cache is populated.\n   */\n  async preload(url: string, progressCallback: ProgressCallback = () => {}) {\n    if (!cache.has(url)) {\n      const rawGLTFLoads =\n          loadWithLoader(url, this[$loader], (progress: number) => {\n            progressCallback(progress * 0.8);\n          });\n\n      const gltfInstanceLoads = rawGLTFLoads.then((rawGLTF: GLTF) => {\n        const GLTFInstance = this[$GLTFInstance];\n        const preparedGLTF = GLTFInstance.prepare(rawGLTF);\n\n        progressCallback(0.9);\n\n        return new GLTFInstance(preparedGLTF);\n      });\n\n      cache.set(url, gltfInstanceLoads);\n    }\n\n    await cache.get(url);\n\n    if (progressCallback) {\n      progressCallback(1.0);\n    }\n\n    preloaded.set(url, true);\n  }\n\n  /**\n   * Loads a glTF from the specified url and resolves a unique clone of the\n   * glTF. If the glTF has already been loaded, makes a clone of the cached\n   * copy.\n   */\n  async load(url: string, progressCallback: ProgressCallback = () => {}):\n      Promise<InstanceType<T>> {\n    await this.preload(url, progressCallback);\n\n    const gltf = await cache.get(url)!;\n    const clone = gltf.clone() as InstanceType<T>;\n\n    this[$evictionPolicy].retain(url);\n\n    // Patch dispose so that we can properly account for instance use\n    // in the caching layer:\n    clone.dispose = (() => {\n      const originalDispose = clone.dispose;\n      let disposed = false;\n\n      return () => {\n        if (disposed) {\n          return;\n        }\n\n        disposed = true;\n        originalDispose.apply(clone);\n        this[$evictionPolicy].release(url);\n      };\n    })();\n\n    return clone;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}