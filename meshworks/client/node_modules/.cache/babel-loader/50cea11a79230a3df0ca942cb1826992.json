{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { ThreeDOMExecutionContext } from '@google/3dom/lib/context.js';\nimport { ModelGraft } from '@google/3dom/lib/facade/three-js/model-graft.js';\nimport { property } from 'lit-element';\nimport { $needsRender, $onModelLoad, $scene } from '../model-viewer-base.js';\nvar SCENE_GRAPH_SCRIPT_TYPE = 'experimental-scene-graph-worklet';\nvar VALID_CAPABILITIES = new Set(['messaging', 'fetch', 'material-properties']);\nvar $onChildListMutation = Symbol('onChildListMutation');\nvar $childListMutationHandler = Symbol('childListMutationHandler');\nvar $mutationObserver = Symbol('mutationObserver');\nvar $createExecutionContext = Symbol('createExecutionContext');\nvar $onScriptElementAdded = Symbol('onScriptElementAdded');\nvar $executionContext = Symbol('executionContext');\nvar $updateExecutionContextModel = Symbol('updateExecutionContextModel');\nvar $modelGraft = Symbol('modelGraft');\nvar $onModelGraftMutation = Symbol('onModelGraftMutation');\nvar $modelGraftMutationHandler = Symbol('modelGraftMutationHandler');\nvar $isValid3DOMScript = Symbol('isValid3DOMScript');\n/**\n * SceneGraphMixin manages a `<model-viewer>` integration with the 3DOM library\n * in order to support custom scripts that operate on the <model-viewer> scene\n * graph.\n *\n * When applied, users can specify a special `<script>` type that can be added\n * as a child of `<model-viewer>`. The script will be invoked in a special\n * Web Worker, conventionally referred to as a \"scene graph worklet.\"\n *\n * Script on the browser main thread can communicate with the scene graph\n * worklet via `modelViewer.worklet` using `postMessage`, much like they would\n * with any other Web Worker.\n *\n * Scene graph worklet scripts must be bestowed capabilities by the author of\n * the `<model-viewer>` markup. The three capabilities currently available\n * include:\n *\n *  - `messaging`: The ability to communicate with other contexts via\n *    `postMessage` and `MessageChannel`\n *  - `fetch`: Access to the global `fetch` method for network operations\n *  - `material-properties`: The ability to manipulate the basic properties of\n *    a Material and its associated constructs in the scene graph\n *\n * A trivial example of creating a scene graph worklet that can manipulate\n * material properties looks like this:\n *\n * ```html\n * <model-viewer>\n *   <script type=\"experimental-scene-graph-worklet\"\n *       allow=\"material-properties\">\n *\n *     console.log('Hello from the scene graph worklet!');\n *\n *     self.addEventListener('model-change', () => {\n *       model.materials[0].pbrMetallicRoughness\n *         .setBaseColorFactor([1, 0, 0, 1]);\n *     });\n *\n *   </script>\n * </model-viewer>\n * ```\n *\n * Only one worklet is allowed per `<model-viewer>` at a time. If a new worklet\n * script is appended to a `<model-viewer>` with a running worklet, a new\n * worklet will be created and the previous one will be terminated. If there\n * is more than one worklet script at HTML parse time, the last one in tree\n * order will be used.\n *\n * When a worklet is created, `<model-viewer>` will dispatch a 'worklet-created'\n * event. At the time that this event is dispatched, the worklet will be created\n * but the model is not guaranteed to have been made available to the worklet.\n */\n\nexport var SceneGraphMixin = function SceneGraphMixin(ModelViewerElement) {\n  var _a, _b, _c, _d;\n\n  var _e;\n\n  var SceneGraphModelViewerElement = /*#__PURE__*/function (_ModelViewerElement) {\n    _inherits(SceneGraphModelViewerElement, _ModelViewerElement);\n\n    var _super = _createSuper(SceneGraphModelViewerElement);\n\n    function SceneGraphModelViewerElement() {\n      var _this;\n\n      _classCallCheck(this, SceneGraphModelViewerElement);\n\n      _this = _super.apply(this, arguments);\n      _this[_e] = null;\n\n      _this[_a] = function (records) {\n        return _this[$onChildListMutation](records);\n      };\n\n      _this[_b] = function (event) {\n        return _this[$onModelGraftMutation](event);\n      };\n\n      _this[_c] = new MutationObserver(_this[$childListMutationHandler]);\n      _this[_d] = null;\n      return _this;\n    }\n    /**\n     * A reference to the active worklet if one exists, or else `null`. A\n     * worklet is not created until a scene graph worklet script has been\n     * detected as a child of this `<model-viewer>`.\n     */\n\n\n    _createClass(SceneGraphModelViewerElement, [{\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(SceneGraphModelViewerElement.prototype), \"connectedCallback\", this).call(this);\n\n        this[$mutationObserver].observe(this, {\n          childList: true\n        });\n        var script = this.querySelector(\"script[type=\\\"\".concat(SCENE_GRAPH_SCRIPT_TYPE, \"\\\"]:last-of-type\"));\n\n        if (script != null && this[$isValid3DOMScript](script)) {\n          this[$onScriptElementAdded](script);\n        }\n      }\n    }, {\n      key: \"disconnectedCallback\",\n      value: function () {\n        var _disconnectedCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var executionContext;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _get(_getPrototypeOf(SceneGraphModelViewerElement.prototype), \"disconnectedCallback\", this).call(this);\n\n                  this[$mutationObserver].disconnect();\n                  executionContext = this[$executionContext];\n\n                  if (!(executionContext != null)) {\n                    _context.next = 7;\n                    break;\n                  }\n\n                  _context.next = 6;\n                  return executionContext.terminate();\n\n                case 6:\n                  this[$executionContext] = null;\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function disconnectedCallback() {\n          return _disconnectedCallback.apply(this, arguments);\n        }\n\n        return disconnectedCallback;\n      }()\n    }, {\n      key: \"updated\",\n      value: function updated(changedProperties) {\n        _get(_getPrototypeOf(SceneGraphModelViewerElement.prototype), \"updated\", this).call(this, changedProperties);\n\n        if (changedProperties.has($modelGraft)) {\n          var oldModelGraft = changedProperties.get($modelGraft);\n\n          if (oldModelGraft != null) {\n            oldModelGraft.removeEventListener('mutation', this[$modelGraftMutationHandler]);\n          }\n\n          var modelGraft = this[$modelGraft];\n\n          if (modelGraft != null) {\n            modelGraft.addEventListener('mutation', this[$modelGraftMutationHandler]);\n          }\n        }\n      }\n    }, {\n      key: (_e = $modelGraft, _a = $childListMutationHandler, _b = $modelGraftMutationHandler, _c = $mutationObserver, _d = $executionContext, $onModelLoad),\n      value: function value(event) {\n        _get(_getPrototypeOf(SceneGraphModelViewerElement.prototype), $onModelLoad, this).call(this, event);\n\n        this[$updateExecutionContextModel]();\n      }\n    }, {\n      key: $isValid3DOMScript,\n      value: function value(node) {\n        return node instanceof HTMLScriptElement && (node.textContent || node.src) && node.getAttribute('type') === SCENE_GRAPH_SCRIPT_TYPE;\n      }\n    }, {\n      key: $onChildListMutation,\n      value: function value(records) {\n        if (this.parentNode == null) {\n          // Ignore a lazily reported list of mutations if we are detached from\n          // the document...\n          return;\n        }\n\n        var lastScriptElement = null;\n\n        var _iterator = _createForOfIteratorHelper(records),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var record = _step.value;\n\n            for (var _i = 0, _Array$from = Array.from(record.addedNodes); _i < _Array$from.length; _i++) {\n              var node = _Array$from[_i];\n\n              if (this[$isValid3DOMScript](node)) {\n                lastScriptElement = node;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (lastScriptElement != null) {\n          this[$onScriptElementAdded](lastScriptElement);\n        }\n      }\n    }, {\n      key: $onScriptElementAdded,\n      value: function value(script) {\n        if (!this[$isValid3DOMScript](script)) {\n          return;\n        }\n\n        var allowString = script.getAttribute('allow') || '';\n        var allowList = allowString.split(';').map(function (fragment) {\n          return fragment.trim();\n        }).filter(function (capability) {\n          return VALID_CAPABILITIES.has(capability);\n        });\n\n        if (script.src) {\n          this[$createExecutionContext](script.src, allowList);\n        } else {\n          this[$createExecutionContext](script.textContent, allowList, {\n            eval: true\n          });\n        }\n      }\n    }, {\n      key: $createExecutionContext,\n      value: function () {\n        var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(scriptSource, capabilities) {\n          var options,\n              executionContext,\n              _args2 = arguments;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {\n                    eval: false\n                  };\n                  executionContext = this[$executionContext];\n\n                  if (!(executionContext != null)) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  _context2.next = 5;\n                  return executionContext.terminate();\n\n                case 5:\n                  this[$executionContext] = executionContext = new ThreeDOMExecutionContext(capabilities);\n                  this.dispatchEvent(new CustomEvent('worklet-created', {\n                    detail: {\n                      worklet: this.worklet\n                    }\n                  }));\n\n                  if (!options.eval) {\n                    _context2.next = 12;\n                    break;\n                  }\n\n                  _context2.next = 10;\n                  return executionContext.eval(scriptSource);\n\n                case 10:\n                  _context2.next = 14;\n                  break;\n\n                case 12:\n                  _context2.next = 14;\n                  return executionContext.import(scriptSource);\n\n                case 14:\n                  this[$updateExecutionContextModel]();\n\n                case 15:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function value(_x, _x2) {\n          return _value.apply(this, arguments);\n        }\n\n        return value;\n      }()\n    }, {\n      key: $updateExecutionContextModel,\n      value: function value() {\n        var executionContext = this[$executionContext];\n\n        if (executionContext == null || this.parentNode == null) {\n          // Ignore if we don't have a 3DOM script to run, or if we are currently\n          // detached from the document\n          return;\n        }\n\n        var scene = this[$scene];\n        var modelGraft = this.loaded ? // TODO: Use a proper GLTF artifact as cached by the loader for this:\n        new ModelGraft(scene.model.url || '', {\n          scene: scene,\n          scenes: [scene],\n          animations: [],\n          cameras: [],\n          parser: {},\n          asset: {},\n          userData: {}\n        }) : null;\n        executionContext.changeModel(modelGraft);\n        this[$modelGraft] = modelGraft;\n      }\n    }, {\n      key: $onModelGraftMutation,\n      value: function value(_event) {\n        this[$needsRender]();\n      }\n    }, {\n      key: \"worklet\",\n      get: function get() {\n        var executionContext = this[$executionContext];\n        return executionContext != null ? executionContext.worker : null;\n      }\n    }]);\n\n    return SceneGraphModelViewerElement;\n  }(ModelViewerElement);\n\n  __decorate([property({\n    type: Object\n  })], SceneGraphModelViewerElement.prototype, _e, void 0);\n\n  return SceneGraphModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/scene-graph.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ThreeDOMCapability} from '@google/3dom/lib/api.js';\nimport {ThreeDOMExecutionContext} from '@google/3dom/lib/context.js';\nimport {ModelGraft} from '@google/3dom/lib/facade/three-js/model-graft.js';\nimport {property} from 'lit-element';\nimport {Group} from 'three';\nimport {GLTFParser} from 'three/examples/jsm/loaders/GLTFLoader';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $scene} from '../model-viewer-base.js';\nimport {Constructor} from '../utilities.js';\n\nconst SCENE_GRAPH_SCRIPT_TYPE = 'experimental-scene-graph-worklet';\nconst VALID_CAPABILITIES: Set<ThreeDOMCapability> =\n    new Set(['messaging', 'fetch', 'material-properties']);\n\nconst $onChildListMutation = Symbol('onChildListMutation');\nconst $childListMutationHandler = Symbol('childListMutationHandler');\nconst $mutationObserver = Symbol('mutationObserver');\nconst $createExecutionContext = Symbol('createExecutionContext');\nconst $onScriptElementAdded = Symbol('onScriptElementAdded');\nconst $executionContext = Symbol('executionContext');\nconst $updateExecutionContextModel = Symbol('updateExecutionContextModel');\nconst $modelGraft = Symbol('modelGraft');\nconst $onModelGraftMutation = Symbol('onModelGraftMutation');\nconst $modelGraftMutationHandler = Symbol('modelGraftMutationHandler');\nconst $isValid3DOMScript = Symbol('isValid3DOMScript');\n\nexport interface SceneGraphInterface {\n  worklet: Worker|null;\n}\n\n/**\n * SceneGraphMixin manages a `<model-viewer>` integration with the 3DOM library\n * in order to support custom scripts that operate on the <model-viewer> scene\n * graph.\n *\n * When applied, users can specify a special `<script>` type that can be added\n * as a child of `<model-viewer>`. The script will be invoked in a special\n * Web Worker, conventionally referred to as a \"scene graph worklet.\"\n *\n * Script on the browser main thread can communicate with the scene graph\n * worklet via `modelViewer.worklet` using `postMessage`, much like they would\n * with any other Web Worker.\n *\n * Scene graph worklet scripts must be bestowed capabilities by the author of\n * the `<model-viewer>` markup. The three capabilities currently available\n * include:\n *\n *  - `messaging`: The ability to communicate with other contexts via\n *    `postMessage` and `MessageChannel`\n *  - `fetch`: Access to the global `fetch` method for network operations\n *  - `material-properties`: The ability to manipulate the basic properties of\n *    a Material and its associated constructs in the scene graph\n *\n * A trivial example of creating a scene graph worklet that can manipulate\n * material properties looks like this:\n *\n * ```html\n * <model-viewer>\n *   <script type=\"experimental-scene-graph-worklet\"\n *       allow=\"material-properties\">\n *\n *     console.log('Hello from the scene graph worklet!');\n *\n *     self.addEventListener('model-change', () => {\n *       model.materials[0].pbrMetallicRoughness\n *         .setBaseColorFactor([1, 0, 0, 1]);\n *     });\n *\n *   </script>\n * </model-viewer>\n * ```\n *\n * Only one worklet is allowed per `<model-viewer>` at a time. If a new worklet\n * script is appended to a `<model-viewer>` with a running worklet, a new\n * worklet will be created and the previous one will be terminated. If there\n * is more than one worklet script at HTML parse time, the last one in tree\n * order will be used.\n *\n * When a worklet is created, `<model-viewer>` will dispatch a 'worklet-created'\n * event. At the time that this event is dispatched, the worklet will be created\n * but the model is not guaranteed to have been made available to the worklet.\n */\nexport const SceneGraphMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<SceneGraphInterface>&T => {\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    @property({type: Object}) protected[$modelGraft]: ModelGraft|null = null;\n\n    protected[$childListMutationHandler] = (records: Array<MutationRecord>) =>\n        this[$onChildListMutation](records);\n\n    protected[$modelGraftMutationHandler] = (event: Event) =>\n        this[$onModelGraftMutation](event);\n\n    protected[$mutationObserver] =\n        new MutationObserver(this[$childListMutationHandler]);\n\n    protected[$executionContext]: ThreeDOMExecutionContext|null = null;\n\n    /**\n     * A reference to the active worklet if one exists, or else `null`. A\n     * worklet is not created until a scene graph worklet script has been\n     * detected as a child of this `<model-viewer>`.\n     */\n    get worklet() {\n      const executionContext = this[$executionContext];\n      return executionContext != null ? executionContext.worker : null;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      this[$mutationObserver].observe(this, {childList: true});\n\n      const script = this.querySelector<HTMLScriptElement>(\n          `script[type=\"${SCENE_GRAPH_SCRIPT_TYPE}\"]:last-of-type`);\n\n      if (script != null && this[$isValid3DOMScript](script)) {\n        this[$onScriptElementAdded](script);\n      }\n    }\n\n    async disconnectedCallback() {\n      super.disconnectedCallback();\n\n      this[$mutationObserver].disconnect();\n\n      const executionContext = this[$executionContext];\n\n      if (executionContext != null) {\n        await executionContext.terminate();\n        this[$executionContext] = null;\n      }\n    }\n\n    updated(changedProperties: Map<string|symbol, unknown>): void {\n      super.updated(changedProperties);\n      if (changedProperties.has($modelGraft)) {\n        const oldModelGraft =\n            changedProperties.get($modelGraft) as ModelGraft | null;\n        if (oldModelGraft != null) {\n          oldModelGraft.removeEventListener(\n              'mutation', this[$modelGraftMutationHandler]);\n        }\n\n        const modelGraft = this[$modelGraft];\n\n        if (modelGraft != null) {\n          modelGraft.addEventListener(\n              'mutation', this[$modelGraftMutationHandler]);\n        }\n      }\n    }\n\n    [$onModelLoad](event: any) {\n      super[$onModelLoad](event);\n\n      this[$updateExecutionContextModel]();\n    }\n\n    [$isValid3DOMScript](node: Node) {\n      return node instanceof HTMLScriptElement &&\n          (node.textContent || node.src) &&\n          node.getAttribute('type') === SCENE_GRAPH_SCRIPT_TYPE\n    }\n\n    [$onChildListMutation](records: Array<MutationRecord>) {\n      if (this.parentNode == null) {\n        // Ignore a lazily reported list of mutations if we are detached from\n        // the document...\n        return;\n      }\n\n      let lastScriptElement: HTMLScriptElement|null = null;\n\n      for (const record of records) {\n        for (const node of Array.from(record.addedNodes)) {\n          if (this[$isValid3DOMScript](node)) {\n            lastScriptElement = node as HTMLScriptElement;\n          }\n        }\n      }\n\n      if (lastScriptElement != null) {\n        this[$onScriptElementAdded](lastScriptElement);\n      }\n    }\n\n    [$onScriptElementAdded](script: HTMLScriptElement) {\n      if (!this[$isValid3DOMScript](script)) {\n        return;\n      }\n\n      const allowString = script.getAttribute('allow') || '';\n      const allowList =\n          allowString.split(';')\n              .map((fragment) => fragment.trim())\n              .filter<ThreeDOMCapability>(\n                  (capability): capability is ThreeDOMCapability =>\n                      VALID_CAPABILITIES.has(capability as ThreeDOMCapability));\n\n      if (script.src) {\n        this[$createExecutionContext](script.src, allowList);\n      } else {\n        this[$createExecutionContext](\n            script.textContent!, allowList, {eval: true});\n      }\n    }\n\n    async[$createExecutionContext](\n        scriptSource: string, capabilities: Array<ThreeDOMCapability>,\n        options = {eval: false}) {\n      let executionContext = this[$executionContext];\n\n      if (executionContext != null) {\n        await executionContext.terminate();\n      }\n\n      this[$executionContext] = executionContext =\n          new ThreeDOMExecutionContext(capabilities);\n\n      this.dispatchEvent(new CustomEvent(\n          'worklet-created', {detail: {worklet: this.worklet}}));\n\n      if (options.eval) {\n        await executionContext.eval(scriptSource);\n      } else {\n        await executionContext.import(scriptSource);\n      }\n\n      this[$updateExecutionContextModel]();\n    }\n\n    [$updateExecutionContextModel]() {\n      const executionContext = this[$executionContext];\n\n      if (executionContext == null || this.parentNode == null) {\n        // Ignore if we don't have a 3DOM script to run, or if we are currently\n        // detached from the document\n        return;\n      }\n\n      const scene = this[$scene];\n      const modelGraft: ModelGraft|null = this.loaded ?\n          // TODO: Use a proper GLTF artifact as cached by the loader for this:\n          new ModelGraft(scene.model.url || '', {\n            scene: scene as unknown as Group,\n            scenes: [scene as unknown as Group],\n            animations: [],\n            cameras: [],\n            parser: {} as unknown as GLTFParser,\n            asset: {},\n            userData: {}\n          }) :\n          null;\n\n      executionContext.changeModel(modelGraft);\n\n      this[$modelGraft] = modelGraft;\n    }\n\n    [$onModelGraftMutation](_event: Event) {\n      this[$needsRender]();\n    }\n  }\n\n  return SceneGraphModelViewerElement;\n};"],"sourceRoot":""},"metadata":{},"sourceType":"module"}