{"ast":null,"code":"import _slicedToArray from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { Spherical, Vector3 } from 'three';\nimport { style } from '../decorators.js';\nimport { $ariaLabel, $container, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $userInputElement } from '../model-viewer-base.js';\nimport { degreesToRadians, normalizeUnit } from '../styles/conversions.js';\nimport { StyleEvaluator } from '../styles/evaluators.js';\nimport { numberNode, parseExpressions } from '../styles/parsers.js';\nimport { SAFE_RADIUS_RATIO } from '../three-components/Model.js';\nimport { ChangeSource, SmoothControls } from '../three-components/SmoothControls.js';\nimport { timeline } from '../utilities/animation.js'; // NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/GoogleWebComponents/model-viewer/issues/839\n\nvar PROMPT_ANIMATION_TIME = 5000; // For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the keyframe.\n\nvar wiggle = timeline(0, [{\n  frames: 6,\n  value: 0\n}, {\n  frames: 5,\n  value: -1\n}, {\n  frames: 1,\n  value: -1\n}, {\n  frames: 8,\n  value: 1\n}, {\n  frames: 1,\n  value: 1\n}, {\n  frames: 5,\n  value: 0\n}, {\n  frames: 12,\n  value: 0\n}]);\nvar fade = timeline(0, [{\n  frames: 2,\n  value: 0\n}, {\n  frames: 1,\n  value: 1\n}, {\n  frames: 5,\n  value: 1\n}, {\n  frames: 1,\n  value: 0\n}, {\n  frames: 4,\n  value: 0\n}]);\nexport var DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nvar DEFAULT_CAMERA_TARGET = 'auto auto auto';\nvar DEFAULT_FIELD_OF_VIEW = 'auto';\nvar MINIMUM_RADIUS_RATIO = 1.1 * SAFE_RADIUS_RATIO;\nvar AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nvar POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\nexport var DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport var INTERACTION_PROMPT = 'Use mouse, touch or arrow keys to control the camera!';\nexport var InteractionPromptStrategy = {\n  AUTO: 'auto',\n  WHEN_FOCUSED: 'when-focused',\n  NONE: 'none'\n};\nexport var InteractionPromptStyle = {\n  BASIC: 'basic',\n  WIGGLE: 'wiggle'\n};\nexport var InteractionPolicy = {\n  ALWAYS_ALLOW: 'always-allow',\n  WHEN_FOCUSED: 'allow-when-focused'\n};\nexport var fieldOfViewIntrinsics = function fieldOfViewIntrinsics(element) {\n  return {\n    basis: [numberNode(element[$zoomAdjustedFieldOfView] * Math.PI / 180, 'rad')],\n    keywords: {\n      auto: [null]\n    }\n  };\n};\nvar minFieldOfViewIntrinsics = {\n  basis: [degreesToRadians(numberNode(25, 'deg'))],\n  keywords: {\n    auto: [null]\n  }\n};\n\nvar maxFieldOfViewIntrinsics = function maxFieldOfViewIntrinsics(element) {\n  var scene = element[$scene];\n  return {\n    basis: [degreesToRadians(numberNode(45, 'deg'))],\n    keywords: {\n      auto: [numberNode(scene.framedFieldOfView, 'deg')]\n    }\n  };\n};\n\nexport var cameraOrbitIntrinsics = function () {\n  var defaultTerms = parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms;\n  var theta = normalizeUnit(defaultTerms[0]);\n  var phi = normalizeUnit(defaultTerms[1]);\n  return function (element) {\n    var radius = element[$scene].model.idealCameraDistance;\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {\n        auto: [null, null, numberNode(105, '%')]\n      }\n    };\n  };\n}();\n\nvar minCameraOrbitIntrinsics = function minCameraOrbitIntrinsics(element) {\n  var radius = MINIMUM_RADIUS_RATIO * element[$scene].model.idealCameraDistance;\n  return {\n    basis: [numberNode(-Infinity, 'rad'), numberNode(Math.PI / 8, 'rad'), numberNode(radius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\n\nvar maxCameraOrbitIntrinsics = function maxCameraOrbitIntrinsics(element) {\n  var orbitIntrinsics = cameraOrbitIntrinsics(element);\n  var evaluator = new StyleEvaluator([], orbitIntrinsics);\n  var defaultRadius = evaluator.evaluate()[2];\n  return {\n    basis: [numberNode(Infinity, 'rad'), numberNode(Math.PI - Math.PI / 8, 'rad'), numberNode(defaultRadius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\n\nexport var cameraTargetIntrinsics = function cameraTargetIntrinsics(element) {\n  var center = element[$scene].model.boundingBox.getCenter(new Vector3());\n  return {\n    basis: [numberNode(center.x, 'm'), numberNode(center.y, 'm'), numberNode(center.z, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nvar HALF_PI = Math.PI / 2.0;\nvar THIRD_PI = Math.PI / 3.0;\nvar QUARTER_PI = HALF_PI / 2.0;\nvar TAU = 2.0 * Math.PI;\nexport var $controls = Symbol('controls');\nexport var $promptElement = Symbol('promptElement');\nexport var $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport var $idealCameraDistance = Symbol('idealCameraDistance');\nvar $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nvar $updateAria = Symbol('updateAria');\nvar $updateCameraForRadius = Symbol('updateCameraForRadius');\nvar $blurHandler = Symbol('blurHandler');\nvar $focusHandler = Symbol('focusHandler');\nvar $changeHandler = Symbol('changeHandler');\nvar $pointerChangeHandler = Symbol('pointerChangeHandler');\nvar $onBlur = Symbol('onBlur');\nvar $onFocus = Symbol('onFocus');\nvar $onChange = Symbol('onChange');\nvar $onPointerChange = Symbol('onPointerChange');\nvar $waitingToPromptUser = Symbol('waitingToPromptUser');\nvar $userHasInteracted = Symbol('userHasInteracted');\nvar $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nvar $lastPromptOffset = Symbol('lastPromptOffset');\nvar $focusedTime = Symbol('focusedTime');\nvar $zoomAdjustedFieldOfView = Symbol('zoomAdjustedFieldOfView');\nvar $lastSpherical = Symbol('lastSpherical');\nvar $jumpCamera = Symbol('jumpCamera');\nvar $syncCameraOrbit = Symbol('syncCameraOrbit');\nvar $syncFieldOfView = Symbol('syncFieldOfView');\nvar $syncCameraTarget = Symbol('syncCameraTarget');\nvar $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nvar $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nvar $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nvar $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\nexport var ControlsMixin = function ControlsMixin(ModelViewerElement) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n  var ControlsModelViewerElement = /*#__PURE__*/function (_ModelViewerElement) {\n    _inherits(ControlsModelViewerElement, _ModelViewerElement);\n\n    var _super = _createSuper(ControlsModelViewerElement);\n\n    function ControlsModelViewerElement() {\n      var _this;\n\n      _classCallCheck(this, ControlsModelViewerElement);\n\n      _this = _super.apply(this, arguments);\n      _this.cameraControls = false;\n      _this.cameraOrbit = DEFAULT_CAMERA_ORBIT;\n      _this.cameraTarget = DEFAULT_CAMERA_TARGET;\n      _this.fieldOfView = DEFAULT_FIELD_OF_VIEW;\n      _this.minCameraOrbit = 'auto';\n      _this.maxCameraOrbit = 'auto';\n      _this.minFieldOfView = 'auto';\n      _this.maxFieldOfView = 'auto';\n      _this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n      _this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;\n      _this.interactionPrompt = InteractionPromptStrategy.AUTO;\n      _this.interactionPolicy = InteractionPolicy.ALWAYS_ALLOW;\n      _this[_a] = _this.shadowRoot.querySelector('.interaction-prompt');\n      _this[_b] = _this.shadowRoot.querySelector('.interaction-prompt > .animated-container');\n      _this[_c] = Infinity;\n      _this[_d] = 0;\n      _this[_e] = Infinity;\n      _this[_f] = false;\n      _this[_g] = false;\n      _this[_h] = new SmoothControls(_this[$scene].camera, _this[$userInputElement]);\n      _this[_j] = 0;\n      _this[_k] = new Spherical();\n      _this[_l] = false;\n\n      _this[_m] = function (event) {\n        return _this[$onChange](event);\n      };\n\n      _this[_o] = function (event) {\n        return _this[$onPointerChange](event);\n      };\n\n      _this[_p] = function () {\n        return _this[$onFocus]();\n      };\n\n      _this[_q] = function () {\n        return _this[$onBlur]();\n      };\n\n      return _this;\n    }\n\n    _createClass(ControlsModelViewerElement, [{\n      key: \"getCameraOrbit\",\n      value: function getCameraOrbit() {\n        var _this$$lastSpherical = this[$lastSpherical],\n            theta = _this$$lastSpherical.theta,\n            phi = _this$$lastSpherical.phi,\n            radius = _this$$lastSpherical.radius;\n        return {\n          theta: theta,\n          phi: phi,\n          radius: radius\n        };\n      }\n    }, {\n      key: \"getCameraTarget\",\n      value: function getCameraTarget() {\n        return this[$scene].getTarget();\n      }\n    }, {\n      key: \"getFieldOfView\",\n      value: function getFieldOfView() {\n        return this[$controls].getFieldOfView();\n      }\n    }, {\n      key: \"jumpCameraToGoal\",\n      value: function jumpCameraToGoal() {\n        this[$jumpCamera] = true;\n        this.requestUpdate($jumpCamera, false);\n      }\n    }, {\n      key: \"resetInteractionPrompt\",\n      value: function resetInteractionPrompt() {\n        this[$lastPromptOffset] = 0;\n        this[$promptElementVisibleTime] = Infinity;\n        this[$userHasInteracted] = false;\n        this[$waitingToPromptUser] = this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls;\n      }\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(ControlsModelViewerElement.prototype), \"connectedCallback\", this).call(this);\n\n        this[$controls].addEventListener('change', this[$changeHandler]);\n        this[$controls].addEventListener('pointer-change-start', this[$pointerChangeHandler]);\n        this[$controls].addEventListener('pointer-change-end', this[$pointerChangeHandler]);\n      }\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(ControlsModelViewerElement.prototype), \"disconnectedCallback\", this).call(this);\n\n        this[$controls].removeEventListener('change', this[$changeHandler]);\n        this[$controls].removeEventListener('pointer-change-start', this[$pointerChangeHandler]);\n        this[$controls].removeEventListener('pointer-change-end', this[$pointerChangeHandler]);\n      }\n    }, {\n      key: \"updated\",\n      value: function updated(changedProperties) {\n        var _this2 = this;\n\n        _get(_getPrototypeOf(ControlsModelViewerElement.prototype), \"updated\", this).call(this, changedProperties);\n\n        var controls = this[$controls];\n        var input = this[$userInputElement];\n\n        if (changedProperties.has('cameraControls')) {\n          if (this.cameraControls) {\n            controls.enableInteraction();\n\n            if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n              this[$waitingToPromptUser] = true;\n            }\n\n            input.addEventListener('focus', this[$focusHandler]);\n            input.addEventListener('blur', this[$blurHandler]);\n          } else {\n            input.removeEventListener('focus', this[$focusHandler]);\n            input.removeEventListener('blur', this[$blurHandler]);\n            controls.disableInteraction();\n            this[$deferInteractionPrompt]();\n          }\n        }\n\n        if (changedProperties.has('interactionPrompt') || changedProperties.has('cameraControls') || changedProperties.has('src')) {\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls) {\n            this[$waitingToPromptUser] = true;\n          } else {\n            this[$deferInteractionPrompt]();\n          }\n        }\n\n        if (changedProperties.has('interactionPromptStyle')) {\n          this[$promptElement].classList.toggle('wiggle', this.interactionPromptStyle === InteractionPromptStyle.WIGGLE);\n        }\n\n        if (changedProperties.has('interactionPolicy')) {\n          var interactionPolicy = this.interactionPolicy;\n          controls.applyOptions({\n            interactionPolicy: interactionPolicy\n          });\n        }\n\n        if (this[$jumpCamera] === true) {\n          Promise.resolve().then(function () {\n            _this2[$controls].jumpToGoal();\n\n            _this2[$scene].jumpToGoal();\n\n            _this2[$jumpCamera] = false;\n          });\n        }\n      }\n    }, {\n      key: (_a = $promptElement, _b = $promptAnimatedContainer, _c = $focusedTime, _d = $lastPromptOffset, _e = $promptElementVisibleTime, _f = $userHasInteracted, _g = $waitingToPromptUser, _h = $controls, _j = $zoomAdjustedFieldOfView, _k = $lastSpherical, _l = $jumpCamera, _m = $changeHandler, _o = $pointerChangeHandler, _p = $focusHandler, _q = $blurHandler, $syncFieldOfView),\n      value: function value(style) {\n        this[$controls].setFieldOfView(style[0] * 180 / Math.PI);\n      }\n    }, {\n      key: $syncCameraOrbit,\n      value: function value(style) {\n        this[$updateCameraForRadius](style[2]);\n        this[$controls].setOrbit(style[0], style[1], style[2]);\n      }\n    }, {\n      key: $syncMinCameraOrbit,\n      value: function value(style) {\n        this[$controls].applyOptions({\n          minimumAzimuthalAngle: style[0],\n          minimumPolarAngle: style[1],\n          minimumRadius: style[2]\n        });\n        this.jumpCameraToGoal();\n      }\n    }, {\n      key: $syncMaxCameraOrbit,\n      value: function value(style) {\n        this[$controls].applyOptions({\n          maximumAzimuthalAngle: style[0],\n          maximumPolarAngle: style[1],\n          maximumRadius: style[2]\n        });\n        this.jumpCameraToGoal();\n      }\n    }, {\n      key: $syncMinFieldOfView,\n      value: function value(style) {\n        this[$controls].applyOptions({\n          minimumFieldOfView: style[0] * 180 / Math.PI\n        });\n        this.jumpCameraToGoal();\n      }\n    }, {\n      key: $syncMaxFieldOfView,\n      value: function value(style) {\n        this[$controls].applyOptions({\n          maximumFieldOfView: style[0] * 180 / Math.PI\n        });\n        this.jumpCameraToGoal();\n      }\n    }, {\n      key: $syncCameraTarget,\n      value: function value(style) {\n        var _style = _slicedToArray(style, 3),\n            x = _style[0],\n            y = _style[1],\n            z = _style[2];\n\n        this[$scene].setTarget(x, y, z);\n      }\n    }, {\n      key: $tick,\n      value: function value(time, delta) {\n        _get(_getPrototypeOf(ControlsModelViewerElement.prototype), $tick, this).call(this, time, delta);\n\n        if (this[$renderer].isPresenting) {\n          return;\n        }\n\n        var now = performance.now();\n\n        if (this[$waitingToPromptUser]) {\n          var thresholdTime = this.interactionPrompt === InteractionPromptStrategy.AUTO ? this[$loadedTime] : this[$focusedTime];\n\n          if (this.loaded && now > thresholdTime + this.interactionPromptThreshold) {\n            this[$userInputElement].setAttribute('aria-label', INTERACTION_PROMPT);\n            this[$waitingToPromptUser] = false;\n            this[$promptElementVisibleTime] = now;\n            this[$promptElement].classList.add('visible');\n          }\n        }\n\n        if (isFinite(this[$promptElementVisibleTime]) && this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n          var scene = this[$scene];\n          var animationTime = (now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME % 1;\n          var offset = wiggle(animationTime);\n          var opacity = fade(animationTime);\n          var xOffset = offset * scene.width * 0.05;\n          var deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n          this[$promptAnimatedContainer].style.transform = \"translateX(\".concat(xOffset, \"px)\");\n          this[$promptAnimatedContainer].style.opacity = \"\".concat(opacity);\n          this[$controls].adjustOrbit(deltaTheta, 0, 0);\n          this[$lastPromptOffset] = offset;\n          this[$needsRender]();\n        }\n\n        this[$controls].update(time, delta);\n        this[$scene].updateTarget(delta);\n      }\n    }, {\n      key: $deferInteractionPrompt,\n      value: function value() {\n        // Effectively cancel the timer waiting for user interaction:\n        this[$waitingToPromptUser] = false;\n        this[$promptElement].classList.remove('visible');\n        this[$promptElementVisibleTime] = Infinity;\n      }\n      /**\n       * Updates the camera's near and far planes to enclose the scene when\n       * orbiting at the supplied radius.\n       */\n\n    }, {\n      key: $updateCameraForRadius,\n      value: function value(radius) {\n        var idealCameraDistance = this[$scene].model.idealCameraDistance;\n        var maximumRadius = Math.max(idealCameraDistance, radius);\n        var near = 0;\n        var far = 2 * maximumRadius;\n        this[$controls].updateNearFar(near, far);\n      }\n    }, {\n      key: $updateAria,\n      value: function value() {\n        // NOTE(cdata): It is possible that we might want to record the\n        // last spherical when the label actually changed. Right now, the\n        // side-effect the current implementation is that we will only\n        // announce the first view change that occurs after the element\n        // becomes focused.\n        var _this$$lastSpherical2 = this[$lastSpherical],\n            lastTheta = _this$$lastSpherical2.theta,\n            lastPhi = _this$$lastSpherical2.phi;\n\n        var _this$$controls$getCa = this[$controls].getCameraSpherical(this[$lastSpherical]),\n            theta = _this$$controls$getCa.theta,\n            phi = _this$$controls$getCa.phi;\n\n        var rootNode = this.getRootNode(); // Only change the aria-label if <model-viewer> is currently focused:\n\n        if (rootNode != null && rootNode.activeElement === this) {\n          var lastAzimuthalQuadrant = (4 + Math.floor((lastTheta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n          var azimuthalQuadrant = (4 + Math.floor((theta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n          var lastPolarTrient = Math.floor(lastPhi / THIRD_PI);\n          var polarTrient = Math.floor(phi / THIRD_PI);\n\n          if (azimuthalQuadrant !== lastAzimuthalQuadrant || polarTrient !== lastPolarTrient) {\n            var azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n            var polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n            var ariaLabel = \"View from stage \".concat(polarTrientLabel).concat(azimuthalQuadrantLabel);\n            this[$userInputElement].setAttribute('aria-label', ariaLabel);\n          }\n        }\n      }\n    }, {\n      key: $onResize,\n      value: function value(event) {\n        var controls = this[$controls];\n        var oldFramedFieldOfView = this[$scene].framedFieldOfView; // The super of $onResize will update the scene's framedFieldOfView, so we\n        // compare the before and after to calculate the proper zoom.\n\n        _get(_getPrototypeOf(ControlsModelViewerElement.prototype), $onResize, this).call(this, event);\n\n        var newFramedFieldOfView = this[$scene].framedFieldOfView;\n        var zoom = controls.getFieldOfView() / oldFramedFieldOfView;\n        this[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n        controls.updateAspect(this[$scene].aspect);\n        this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n        this.requestUpdate('fieldOfView', this.fieldOfView);\n        this.jumpCameraToGoal();\n      }\n    }, {\n      key: $onModelLoad,\n      value: function value(event) {\n        _get(_getPrototypeOf(ControlsModelViewerElement.prototype), $onModelLoad, this).call(this, event);\n\n        var framedFieldOfView = this[$scene].framedFieldOfView;\n        this[$zoomAdjustedFieldOfView] = framedFieldOfView;\n        this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n        this.requestUpdate('fieldOfView', this.fieldOfView);\n        this.requestUpdate('cameraOrbit', this.cameraOrbit);\n        this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n        this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n        this.requestUpdate('cameraTarget', this.cameraTarget);\n        this.jumpCameraToGoal();\n      }\n    }, {\n      key: $onFocus,\n      value: function value() {\n        var input = this[$userInputElement];\n\n        if (!isFinite(this[$focusedTime])) {\n          this[$focusedTime] = performance.now();\n        } // NOTE(cdata): On every re-focus, we switch the aria-label back to\n        // the original, non-prompt label if appropriate. If the user has\n        // already interacted, they no longer need to hear the prompt.\n        // Otherwise, they will hear it again after the idle prompt threshold\n        // has been crossed.\n\n\n        var ariaLabel = this[$ariaLabel];\n\n        if (input.getAttribute('aria-label') !== ariaLabel) {\n          input.setAttribute('aria-label', ariaLabel);\n        }\n\n        if (this.interactionPrompt === InteractionPromptStrategy.WHEN_FOCUSED && !this[$userHasInteracted]) {\n          this[$waitingToPromptUser] = true;\n        }\n      }\n    }, {\n      key: $onBlur,\n      value: function value() {\n        this[$waitingToPromptUser] = false;\n        this[$promptElement].classList.remove('visible');\n        this[$promptElementVisibleTime] = Infinity;\n        this[$focusedTime] = Infinity;\n      }\n    }, {\n      key: $onChange,\n      value: function value(_ref) {\n        var source = _ref.source;\n        this[$updateAria]();\n        this[$needsRender]();\n\n        if (source === ChangeSource.USER_INTERACTION) {\n          this[$userHasInteracted] = true;\n          this[$deferInteractionPrompt]();\n        }\n\n        this.dispatchEvent(new CustomEvent('camera-change', {\n          detail: {\n            source: source\n          }\n        }));\n      }\n    }, {\n      key: $onPointerChange,\n      value: function value(event) {\n        if (event.type === 'pointer-change-start') {\n          this[$container].classList.add('pointer-tumbling');\n        } else {\n          this[$container].classList.remove('pointer-tumbling');\n        }\n      }\n    }]);\n\n    return ControlsModelViewerElement;\n  }(ModelViewerElement);\n\n  __decorate([property({\n    type: Boolean,\n    attribute: 'camera-controls'\n  })], ControlsModelViewerElement.prototype, \"cameraControls\", void 0);\n\n  __decorate([style({\n    intrinsics: cameraOrbitIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'camera-orbit',\n    hasChanged: function hasChanged() {\n      return true;\n    }\n  })], ControlsModelViewerElement.prototype, \"cameraOrbit\", void 0);\n\n  __decorate([style({\n    intrinsics: cameraTargetIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraTarget\n  }), property({\n    type: String,\n    attribute: 'camera-target',\n    hasChanged: function hasChanged() {\n      return true;\n    }\n  })], ControlsModelViewerElement.prototype, \"cameraTarget\", void 0);\n\n  __decorate([style({\n    intrinsics: fieldOfViewIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncFieldOfView\n  }), property({\n    type: String,\n    attribute: 'field-of-view',\n    hasChanged: function hasChanged() {\n      return true;\n    }\n  })], ControlsModelViewerElement.prototype, \"fieldOfView\", void 0);\n\n  __decorate([style({\n    intrinsics: minCameraOrbitIntrinsics,\n    updateHandler: $syncMinCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'min-camera-orbit',\n    hasChanged: function hasChanged() {\n      return true;\n    }\n  })], ControlsModelViewerElement.prototype, \"minCameraOrbit\", void 0);\n\n  __decorate([style({\n    intrinsics: maxCameraOrbitIntrinsics,\n    updateHandler: $syncMaxCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'max-camera-orbit',\n    hasChanged: function hasChanged() {\n      return true;\n    }\n  })], ControlsModelViewerElement.prototype, \"maxCameraOrbit\", void 0);\n\n  __decorate([style({\n    intrinsics: minFieldOfViewIntrinsics,\n    updateHandler: $syncMinFieldOfView\n  }), property({\n    type: String,\n    attribute: 'min-field-of-view',\n    hasChanged: function hasChanged() {\n      return true;\n    }\n  })], ControlsModelViewerElement.prototype, \"minFieldOfView\", void 0);\n\n  __decorate([style({\n    intrinsics: maxFieldOfViewIntrinsics,\n    updateHandler: $syncMaxFieldOfView\n  }), property({\n    type: String,\n    attribute: 'max-field-of-view',\n    hasChanged: function hasChanged() {\n      return true;\n    }\n  })], ControlsModelViewerElement.prototype, \"maxFieldOfView\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'interaction-prompt-threshold'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptThreshold\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt-style'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptStyle\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt'\n  })], ControlsModelViewerElement.prototype, \"interactionPrompt\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-policy'\n  })], ControlsModelViewerElement.prototype, \"interactionPolicy\", void 0);\n\n  return ControlsModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/controls.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit-element';\nimport {Event, PerspectiveCamera, Spherical, Vector3} from 'three';\n\nimport {style} from '../decorators.js';\nimport ModelViewerElementBase, {$ariaLabel, $container, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $userInputElement, Vector3D} from '../model-viewer-base.js';\nimport {degreesToRadians, normalizeUnit} from '../styles/conversions.js';\nimport {EvaluatedStyle, Intrinsics, SphericalIntrinsics, StyleEvaluator, Vector3Intrinsics} from '../styles/evaluators.js';\nimport {IdentNode, NumberNode, numberNode, parseExpressions} from '../styles/parsers.js';\nimport {SAFE_RADIUS_RATIO} from '../three-components/Model.js';\nimport {ChangeEvent, ChangeSource, PointerChangeEvent, SmoothControls} from '../three-components/SmoothControls.js';\nimport {Constructor} from '../utilities.js';\nimport {timeline} from '../utilities/animation.js';\n\n\n\n// NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/GoogleWebComponents/model-viewer/issues/839\nconst PROMPT_ANIMATION_TIME = 5000;\n\n// For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the keyframe.\nconst wiggle = timeline(0, [\n  {frames: 6, value: 0},\n  {frames: 5, value: -1},\n  {frames: 1, value: -1},\n  {frames: 8, value: 1},\n  {frames: 1, value: 1},\n  {frames: 5, value: 0},\n  {frames: 12, value: 0}\n]);\n\nconst fade = timeline(0, [\n  {frames: 2, value: 0},\n  {frames: 1, value: 1},\n  {frames: 5, value: 1},\n  {frames: 1, value: 0},\n  {frames: 4, value: 0}\n]);\n\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\n\nconst MINIMUM_RADIUS_RATIO = 1.1 * SAFE_RADIUS_RATIO;\n\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\n\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT =\n    'Use mouse, touch or arrow keys to control the camera!';\n\nexport interface CameraChangeDetails {\n  source: ChangeSource;\n}\n\nexport interface SphericalPosition {\n  theta: number;  // equator angle around the y (up) axis.\n  phi: number;    // polar angle from the y (up) axis.\n  radius: number;\n}\n\nexport type InteractionPromptStrategy = 'auto'|'when-focused'|'none';\nexport type InteractionPromptStyle = 'basic'|'wiggle';\nexport type InteractionPolicy = 'always-allow'|'allow-when-focused';\n\nexport const InteractionPromptStrategy:\n    {[index: string]: InteractionPromptStrategy} = {\n      AUTO: 'auto',\n      WHEN_FOCUSED: 'when-focused',\n      NONE: 'none'\n    };\n\nexport const InteractionPromptStyle:\n    {[index: string]: InteractionPromptStyle} = {\n      BASIC: 'basic',\n      WIGGLE: 'wiggle'\n    };\n\nexport const InteractionPolicy: {[index: string]: InteractionPolicy} = {\n  ALWAYS_ALLOW: 'always-allow',\n  WHEN_FOCUSED: 'allow-when-focused'\n};\n\nexport const fieldOfViewIntrinsics = (element: ModelViewerElementBase) => {\n  return {\n    basis: [numberNode(\n        (element as any)[$zoomAdjustedFieldOfView] * Math.PI / 180, 'rad')],\n    keywords: {auto: [null]}\n  };\n};\n\nconst minFieldOfViewIntrinsics = {\n  basis: [degreesToRadians(numberNode(25, 'deg')) as NumberNode<'rad'>],\n  keywords: {auto: [null]}\n};\n\nconst maxFieldOfViewIntrinsics = (element: ModelViewerElementBase) => {\n  const scene = element[$scene];\n\n  return {\n    basis: [degreesToRadians(numberNode(45, 'deg')) as NumberNode<'rad'>],\n    keywords: {auto: [numberNode(scene.framedFieldOfView, 'deg')]}\n  };\n};\n\nexport const cameraOrbitIntrinsics = (() => {\n  const defaultTerms =\n      parseExpressions(DEFAULT_CAMERA_ORBIT)[0]\n          .terms as [NumberNode<'rad'>, NumberNode<'rad'>, IdentNode];\n\n  const theta = normalizeUnit(defaultTerms[0]) as NumberNode<'rad'>;\n  const phi = normalizeUnit(defaultTerms[1]) as NumberNode<'rad'>;\n\n  return (element: ModelViewerElementBase) => {\n    const radius = element[$scene].model.idealCameraDistance;\n\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {auto: [null, null, numberNode(105, '%')]}\n    };\n  };\n})();\n\nconst minCameraOrbitIntrinsics = (element: ModelViewerElementBase) => {\n  const radius =\n      MINIMUM_RADIUS_RATIO * element[$scene].model.idealCameraDistance;\n\n  return {\n    basis: [\n      numberNode(-Infinity, 'rad'),\n      numberNode(Math.PI / 8, 'rad'),\n      numberNode(radius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst maxCameraOrbitIntrinsics = (element: ModelViewerElementBase) => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n\n  return {\n    basis: [\n      numberNode(Infinity, 'rad'),\n      numberNode(Math.PI - Math.PI / 8, 'rad'),\n      numberNode(defaultRadius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nexport const cameraTargetIntrinsics = (element: ModelViewerElementBase) => {\n  const center = element[$scene].model.boundingBox.getCenter(new Vector3);\n\n  return {\n    basis: [\n      numberNode(center.x, 'm'),\n      numberNode(center.y, 'm'),\n      numberNode(center.z, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\n\nexport const $controls = Symbol('controls');\nexport const $promptElement = Symbol('promptElement');\nexport const $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport const $idealCameraDistance = Symbol('idealCameraDistance');\n\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\n\nconst $blurHandler = Symbol('blurHandler');\nconst $focusHandler = Symbol('focusHandler');\nconst $changeHandler = Symbol('changeHandler');\nconst $pointerChangeHandler = Symbol('pointerChangeHandler');\n\nconst $onBlur = Symbol('onBlur');\nconst $onFocus = Symbol('onFocus');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\n\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $focusedTime = Symbol('focusedTime');\n\nconst $zoomAdjustedFieldOfView = Symbol('zoomAdjustedFieldOfView');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\n\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\n\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\n\nexport declare interface ControlsInterface {\n  cameraControls: boolean;\n  cameraOrbit: string;\n  cameraTarget: string;\n  fieldOfView: string;\n  minCameraOrbit: string;\n  maxCameraOrbit: string;\n  minFieldOfView: string;\n  maxFieldOfView: string;\n  interactionPrompt: InteractionPromptStrategy;\n  interactionPromptStyle: InteractionPromptStyle;\n  interactionPolicy: InteractionPolicy;\n  interactionPromptThreshold: number;\n  getCameraOrbit(): SphericalPosition;\n  getCameraTarget(): Vector3D;\n  getFieldOfView(): number;\n  jumpCameraToGoal(): void;\n  resetInteractionPrompt(): void;\n}\n\nexport const ControlsMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<ControlsInterface>&T => {\n  class ControlsModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean, attribute: 'camera-controls'})\n    cameraControls: boolean = false;\n\n    @style({\n      intrinsics: cameraOrbitIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraOrbit\n    })\n    @property({type: String, attribute: 'camera-orbit', hasChanged: () => true})\n    cameraOrbit: string = DEFAULT_CAMERA_ORBIT;\n\n    @style({\n      intrinsics: cameraTargetIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraTarget\n    })\n    @property(\n        {type: String, attribute: 'camera-target', hasChanged: () => true})\n    cameraTarget: string = DEFAULT_CAMERA_TARGET;\n\n    @style({\n      intrinsics: fieldOfViewIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'field-of-view', hasChanged: () => true})\n    fieldOfView: string = DEFAULT_FIELD_OF_VIEW;\n\n    @style({\n      intrinsics: minCameraOrbitIntrinsics,\n      updateHandler: $syncMinCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'min-camera-orbit', hasChanged: () => true})\n    minCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: maxCameraOrbitIntrinsics,\n      updateHandler: $syncMaxCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'max-camera-orbit', hasChanged: () => true})\n    maxCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: minFieldOfViewIntrinsics,\n      updateHandler: $syncMinFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'min-field-of-view', hasChanged: () => true})\n    minFieldOfView: string = 'auto';\n\n    @style({\n      intrinsics: maxFieldOfViewIntrinsics,\n      updateHandler: $syncMaxFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'max-field-of-view', hasChanged: () => true})\n    maxFieldOfView: string = 'auto';\n\n    @property({type: Number, attribute: 'interaction-prompt-threshold'})\n    interactionPromptThreshold: number = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n\n    @property({type: String, attribute: 'interaction-prompt-style'})\n    interactionPromptStyle: InteractionPromptStyle =\n        InteractionPromptStyle.WIGGLE;\n\n    @property({type: String, attribute: 'interaction-prompt'})\n    interactionPrompt: InteractionPromptStrategy =\n        InteractionPromptStrategy.AUTO;\n\n    @property({type: String, attribute: 'interaction-policy'})\n    interactionPolicy: InteractionPolicy = InteractionPolicy.ALWAYS_ALLOW;\n\n    protected[$promptElement] =\n        this.shadowRoot!.querySelector('.interaction-prompt') as HTMLElement;\n    protected[$promptAnimatedContainer] =\n        this.shadowRoot!.querySelector(\n            '.interaction-prompt > .animated-container') as HTMLElement;\n\n    protected[$focusedTime] = Infinity;\n    protected[$lastPromptOffset] = 0;\n    protected[$promptElementVisibleTime] = Infinity;\n    protected[$userHasInteracted] = false;\n    protected[$waitingToPromptUser] = false;\n\n    protected[$controls] = new SmoothControls(\n        this[$scene].camera as PerspectiveCamera, this[$userInputElement]);\n\n    protected[$zoomAdjustedFieldOfView] = 0;\n    protected[$lastSpherical] = new Spherical();\n    protected[$jumpCamera] = false;\n\n    protected[$changeHandler] = (event: Event) =>\n        this[$onChange](event as ChangeEvent);\n\n    protected[$pointerChangeHandler] = (event: Event) =>\n        this[$onPointerChange](event as PointerChangeEvent);\n\n    protected[$focusHandler] = () => this[$onFocus]();\n    protected[$blurHandler] = () => this[$onBlur]();\n\n    getCameraOrbit(): SphericalPosition {\n      const {theta, phi, radius} = this[$lastSpherical];\n      return {theta, phi, radius};\n    }\n\n    getCameraTarget(): Vector3D {\n      return this[$scene].getTarget();\n    }\n\n    getFieldOfView(): number {\n      return this[$controls].getFieldOfView();\n    }\n\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] =\n          this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n          this.cameraControls;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      this[$controls].addEventListener('change', this[$changeHandler]);\n      this[$controls].addEventListener(\n          'pointer-change-start', this[$pointerChangeHandler]);\n      this[$controls].addEventListener(\n          'pointer-change-end', this[$pointerChangeHandler]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      this[$controls].removeEventListener('change', this[$changeHandler]);\n      this[$controls].removeEventListener(\n          'pointer-change-start', this[$pointerChangeHandler]);\n      this[$controls].removeEventListener(\n          'pointer-change-end', this[$pointerChangeHandler]);\n    }\n\n    updated(changedProperties: Map<string|number|symbol, unknown>) {\n      super.updated(changedProperties);\n\n      const controls = this[$controls];\n      const input = this[$userInputElement];\n\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n\n          input.addEventListener('focus', this[$focusHandler]);\n          input.addEventListener('blur', this[$blurHandler]);\n        } else {\n          input.removeEventListener('focus', this[$focusHandler]);\n          input.removeEventListener('blur', this[$blurHandler]);\n\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPrompt') ||\n          changedProperties.has('cameraControls') ||\n          changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n            this.cameraControls) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptElement].classList.toggle(\n            'wiggle',\n            this.interactionPromptStyle === InteractionPromptStyle.WIGGLE);\n      }\n\n      if (changedProperties.has('interactionPolicy')) {\n        const interactionPolicy = this.interactionPolicy;\n        controls.applyOptions({interactionPolicy});\n      }\n\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          this[$controls].jumpToGoal();\n          this[$scene].jumpToGoal();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n\n    [$syncFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].setFieldOfView(style[0] * 180 / Math.PI);\n    }\n\n    [$syncCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$updateCameraForRadius](style[2]);\n      this[$controls].setOrbit(style[0], style[1], style[2]);\n    }\n\n    [$syncMinCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMinFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].applyOptions(\n          {minimumFieldOfView: style[0] * 180 / Math.PI});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].applyOptions(\n          {maximumFieldOfView: style[0] * 180 / Math.PI});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncCameraTarget](style: EvaluatedStyle<Vector3Intrinsics>) {\n      const [x, y, z] = style;\n      this[$scene].setTarget(x, y, z);\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n\n      if (this[$renderer].isPresenting) {\n        return;\n      }\n\n      const now = performance.now();\n      if (this[$waitingToPromptUser]) {\n        const thresholdTime =\n            this.interactionPrompt === InteractionPromptStrategy.AUTO ?\n            this[$loadedTime] :\n            this[$focusedTime];\n\n        if (this.loaded &&\n            now > thresholdTime + this.interactionPromptThreshold) {\n          this[$userInputElement].setAttribute(\n              'aria-label', INTERACTION_PROMPT);\n\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n\n          this[$promptElement].classList.add('visible');\n        }\n      }\n\n\n      if (isFinite(this[$promptElementVisibleTime]) &&\n          this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const scene = this[$scene];\n        const animationTime =\n            ((now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME) %\n            1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n\n        const xOffset = offset * scene.width * 0.05;\n        const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n\n        this[$promptAnimatedContainer].style.transform =\n            `translateX(${xOffset}px)`;\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n\n        this[$controls].adjustOrbit(deltaTheta, 0, 0);\n\n        this[$lastPromptOffset] = offset;\n        this[$needsRender]();\n      }\n\n      this[$controls].update(time, delta);\n      this[$scene].updateTarget(delta);\n    }\n\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n    [$updateCameraForRadius](radius: number) {\n      const {idealCameraDistance} = this[$scene].model;\n      const maximumRadius = Math.max(idealCameraDistance, radius);\n\n      const near = 0;\n      const far = 2 * maximumRadius;\n      this[$controls].updateNearFar(near, far);\n    }\n\n    [$updateAria]() {\n      // NOTE(cdata): It is possible that we might want to record the\n      // last spherical when the label actually changed. Right now, the\n      // side-effect the current implementation is that we will only\n      // announce the first view change that occurs after the element\n      // becomes focused.\n      const {theta: lastTheta, phi: lastPhi} = this[$lastSpherical];\n      const {theta, phi} =\n          this[$controls]!.getCameraSpherical(this[$lastSpherical]);\n\n      const rootNode = this.getRootNode() as Document | ShadowRoot | null;\n\n      // Only change the aria-label if <model-viewer> is currently focused:\n      if (rootNode != null && rootNode.activeElement === this) {\n        const lastAzimuthalQuadrant =\n            (4 + Math.floor(((lastTheta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n        const azimuthalQuadrant =\n            (4 + Math.floor(((theta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n\n        const lastPolarTrient = Math.floor(lastPhi / THIRD_PI);\n        const polarTrient = Math.floor(phi / THIRD_PI);\n\n        if (azimuthalQuadrant !== lastAzimuthalQuadrant ||\n            polarTrient !== lastPolarTrient) {\n          const azimuthalQuadrantLabel =\n              AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n          const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n\n          const ariaLabel =\n              `View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`;\n\n          this[$userInputElement].setAttribute('aria-label', ariaLabel);\n        }\n      }\n    }\n\n    [$onResize](event: any) {\n      const controls = this[$controls];\n      const oldFramedFieldOfView = this[$scene].framedFieldOfView;\n\n      // The super of $onResize will update the scene's framedFieldOfView, so we\n      // compare the before and after to calculate the proper zoom.\n      super[$onResize](event);\n\n      const newFramedFieldOfView = this[$scene].framedFieldOfView;\n      const zoom = controls.getFieldOfView() / oldFramedFieldOfView;\n      this[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n\n      controls.updateAspect(this[$scene].aspect);\n\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.jumpCameraToGoal();\n    }\n\n    [$onModelLoad](event: any) {\n      super[$onModelLoad](event);\n\n      const {framedFieldOfView} = this[$scene];\n      this[$zoomAdjustedFieldOfView] = framedFieldOfView;\n\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n\n    [$onFocus]() {\n      const input = this[$userInputElement];\n\n      if (!isFinite(this[$focusedTime])) {\n        this[$focusedTime] = performance.now();\n      }\n\n      // NOTE(cdata): On every re-focus, we switch the aria-label back to\n      // the original, non-prompt label if appropriate. If the user has\n      // already interacted, they no longer need to hear the prompt.\n      // Otherwise, they will hear it again after the idle prompt threshold\n      // has been crossed.\n      const ariaLabel = this[$ariaLabel];\n\n      if (input.getAttribute('aria-label') !== ariaLabel) {\n        input.setAttribute('aria-label', ariaLabel);\n      }\n\n      if (this.interactionPrompt === InteractionPromptStrategy.WHEN_FOCUSED &&\n          !this[$userHasInteracted]) {\n        this[$waitingToPromptUser] = true;\n      }\n    }\n\n    [$onBlur]() {\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n\n      this[$promptElementVisibleTime] = Infinity;\n      this[$focusedTime] = Infinity;\n    }\n\n    [$onChange]({source}: ChangeEvent) {\n      this[$updateAria]();\n      this[$needsRender]();\n\n      if (source === ChangeSource.USER_INTERACTION) {\n        this[$userHasInteracted] = true;\n        this[$deferInteractionPrompt]();\n      }\n\n      this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n          'camera-change', {detail: {source}}));\n    }\n\n    [$onPointerChange](event: PointerChangeEvent) {\n      if (event.type === 'pointer-change-start') {\n        this[$container].classList.add('pointer-tumbling');\n      } else {\n        this[$container].classList.remove('pointer-tumbling');\n      }\n    }\n  }\n\n  return ControlsModelViewerElement;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}