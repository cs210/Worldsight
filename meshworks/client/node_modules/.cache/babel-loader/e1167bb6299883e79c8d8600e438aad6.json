{"ast":null,"code":"import _classCallCheck from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/aakankshasaxena/Documents/Junior/Meshworks/Worldsight/meshworks/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SkeletonUtils } from 'three/examples/jsm/utils/SkeletonUtils.js';\nexport var $prepared = Symbol('prepared');\nexport var $prepare = Symbol('prepare');\nexport var $preparedGLTF = Symbol('preparedGLTF');\nexport var $clone = Symbol('clone');\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\n\nexport var GLTFInstance = /*#__PURE__*/function () {\n  function GLTFInstance(preparedGLTF) {\n    _classCallCheck(this, GLTFInstance);\n\n    this[$preparedGLTF] = preparedGLTF;\n  }\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n\n\n  _createClass(GLTFInstance, [{\n    key: \"clone\",\n\n    /**\n     * Creates and returns a copy of this instance.\n     */\n    value: function clone() {\n      var GLTFInstanceConstructor = this.constructor;\n      var clonedGLTF = this[$clone]();\n      return new GLTFInstanceConstructor(clonedGLTF);\n    }\n    /**\n     * Cleans up any retained memory that might not otherwise be released when\n     * this instance is done being used.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.scenes.forEach(function (scene) {\n        scene.traverse(function (object) {\n          if (!object.isMesh) {\n            return;\n          }\n\n          var mesh = object;\n          var materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n          materials.forEach(function (material) {\n            material.dispose();\n          });\n          mesh.geometry.dispose();\n        });\n      });\n    }\n    /**\n     * Override in an inheriting class to implement specialized cloning strategies\n     */\n\n  }, {\n    key: $clone,\n    value: function value() {\n      var source = this[$preparedGLTF]; // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n      // bother cloning extra scenes for now:\n\n      var scene = SkeletonUtils.clone(this.scene);\n      var scenes = [scene];\n      var userData = source.userData ? Object.assign({}, source.userData) : {};\n      return Object.assign(Object.assign({}, source), {\n        scene: scene,\n        scenes: scenes,\n        userData: userData\n      });\n    }\n  }, {\n    key: \"parser\",\n    get: function get() {\n      return this[$preparedGLTF].parser;\n    }\n  }, {\n    key: \"animations\",\n    get: function get() {\n      return this[$preparedGLTF].animations;\n    }\n  }, {\n    key: \"scene\",\n    get: function get() {\n      return this[$preparedGLTF].scene;\n    }\n  }, {\n    key: \"scenes\",\n    get: function get() {\n      return this[$preparedGLTF].scenes;\n    }\n  }, {\n    key: \"cameras\",\n    get: function get() {\n      return this[$preparedGLTF].cameras;\n    }\n  }, {\n    key: \"asset\",\n    get: function get() {\n      return this[$preparedGLTF].asset;\n    }\n  }, {\n    key: \"userData\",\n    get: function get() {\n      return this[$preparedGLTF].userData;\n    }\n  }], [{\n    key: \"prepare\",\n    value: function prepare(source) {\n      if (source.scene == null) {\n        throw new Error('Model does not have a scene');\n      }\n\n      if (source[$prepared]) {\n        return source;\n      }\n\n      var prepared = this[$prepare](source); // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n      // so {...prepared, [$prepared]: true} does not work\n\n      prepared[$prepared] = true;\n      return prepared;\n    }\n    /**\n     * Override in an inheriting class to apply specialty one-time preparations\n     * for a given input GLTF.\n     */\n\n  }, {\n    key: $prepare,\n    value: function value(source) {\n      // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n      // bother preparing extra scenes for now:\n      var scene = source.scene;\n      var scenes = [scene];\n      return Object.assign(Object.assign({}, source), {\n        scene: scene,\n        scenes: scenes\n      });\n    }\n  }]);\n\n  return GLTFInstance;\n}();","map":{"version":3,"sources":["../../src/three-components/GLTFInstance.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Group, Mesh, Object3D} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport {SkeletonUtils} from 'three/examples/jsm/utils/SkeletonUtils.js';\n\nimport {Constructor} from '../utilities.js';\n\nexport const $prepared = Symbol('prepared');\n\nexport interface PreparedGLTF extends GLTF {\n  [$prepared]?: boolean;\n}\n\nexport const $prepare = Symbol('prepare');\nexport const $preparedGLTF = Symbol('preparedGLTF');\nexport const $clone = Symbol('clone');\n\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\nexport class GLTFInstance implements GLTF {\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n  static prepare(source: GLTF): PreparedGLTF {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n\n    if ((source as PreparedGLTF)[$prepared]) {\n      return source;\n    }\n\n    const prepared = this[$prepare](source) as Partial<PreparedGLTF>;\n\n    // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n    prepared[$prepared] = true;\n\n    return prepared as PreparedGLTF;\n  }\n\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n  protected static[$prepare](source: GLTF): GLTF {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const {scene} = source;\n    const scenes = [scene];\n\n    return {...source, scene, scenes};\n  }\n\n  protected[$preparedGLTF]: PreparedGLTF;\n\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n\n  constructor(preparedGLTF: PreparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n\n  /**\n   * Creates and returns a copy of this instance.\n   */\n  clone<T extends GLTFInstance>(): T {\n    const GLTFInstanceConstructor = this.constructor as Constructor<T>;\n\n    const clonedGLTF = this[$clone]();\n\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n  dispose(): void {\n    this.scenes.forEach((scene: Group) => {\n      scene.traverse((object: Object3D) => {\n        if (!(object as Mesh).isMesh) {\n          return;\n        }\n        const mesh = object as Mesh;\n        const materials =\n            Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n  protected[$clone](): PreparedGLTF {\n    const source = this[$preparedGLTF];\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n    const scene = SkeletonUtils.clone(this.scene) as Group;\n    const scenes = [scene];\n    const userData = source.userData ? {...source.userData} : {};\n    return {...source, scene, scenes, userData};\n  }\n}\n\nexport type GLTFInstanceConstructor =\n    Constructor<GLTFInstance, {prepare: typeof GLTFInstance['prepare']}>;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}